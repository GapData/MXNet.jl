



<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-0.17.2, mkdocs-material-2.2.6">
    
    
      
        <title>NDArray API - MXNet.jl</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.6525f7f6.css">
      
    
    
      <script src="../../assets/javascripts/modernizr.1aa3b519.js"></script>
    
    
      
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    
    
      <link rel="stylesheet" href="../../assets/Documenter.css">
    
    
  </head>
  
    <body>
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="drawer">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="search">
    <label class="md-overlay" data-md-component="overlay" for="drawer"></label>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="MXNet.jl" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            
              <span class="md-header-nav__topic">
                MXNet.jl
              </span>
              <span class="md-header-nav__topic">
                NDArray API
              </span>
            
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          
            <label class="md-icon md-icon--search md-header-nav__button" for="search"></label>
            
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="search"></label>
  <div class="md-search__inner">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" required placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query">
      <label class="md-icon md-search__icon" for="search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset">&#xE5CD;</button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
          
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  


  <a href="https://github.com/dmlc/MXNet.jl/" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      GitHub
    </div>
  </a>

          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="drawer">
    <span class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </span>
    MXNet.jl
  </label>
  
    <div class="md-nav__source">
      


  


  <a href="https://github.com/dmlc/MXNet.jl/" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      GitHub
    </div>
  </a>

    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Tutorial
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Tutorial
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorial/mnist/" title="Digit Recognition on MNIST" class="md-nav__link">
      Digit Recognition on MNIST
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorial/char-lstm/" title="Generating Random Sentence with LSTM RNN" class="md-nav__link">
      Generating Random Sentence with LSTM RNN
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      User Guide
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        User Guide
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../user-guide/install/" title="Installation Guide" class="md-nav__link">
      Installation Guide
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../user-guide/overview/" title="Overview" class="md-nav__link">
      Overview
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../user-guide/faq/" title="FAQ" class="md-nav__link">
      FAQ
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" checked>
    
    <label class="md-nav__link" for="nav-4">
      API Documentation
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        API Documentation
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../context/" title="Context" class="md-nav__link">
      Context
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../model/" title="Models" class="md-nav__link">
      Models
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../initializer/" title="Initializers" class="md-nav__link">
      Initializers
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../optimizer/" title="Optimizers" class="md-nav__link">
      Optimizers
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../callback/" title="Callbacks in training" class="md-nav__link">
      Callbacks in training
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../metric/" title="Evaluation Metrics" class="md-nav__link">
      Evaluation Metrics
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../io/" title="Data Providers" class="md-nav__link">
      Data Providers
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="toc">
        NDArray API
      </label>
    
    <a href="./" title="NDArray API" class="md-nav__link md-nav__link--active">
      NDArray API
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#arithmetic-operations" title="Arithmetic Operations" class="md-nav__link">
    Arithmetic Operations
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#trigonometric-functions" title="Trigonometric Functions" class="md-nav__link">
    Trigonometric Functions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hyperbolic-functions" title="Hyperbolic Functions" class="md-nav__link">
    Hyperbolic Functions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#activation-functions" title="Activation Functions" class="md-nav__link">
    Activation Functions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#reference" title="Reference" class="md-nav__link">
    Reference
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#forward-softmax-output" title="forward softmax output" class="md-nav__link">
    forward softmax output
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#backward-gradient-output" title="backward gradient output" class="md-nav__link">
    backward gradient output
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#notice-that-the-first-row-is-all-0-because-label0-is-1-which-is-equal-to-ignore_label" title="notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label." class="md-nav__link">
    notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.
  </a>
  
</li>
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../symbolic-node/" title="Symbolic API" class="md-nav__link">
      Symbolic API
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../nn-factory/" title="Neural Networks Factory" class="md-nav__link">
      Neural Networks Factory
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../executor/" title="Executor" class="md-nav__link">
      Executor
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../visualize/" title="Network Visualization" class="md-nav__link">
      Network Visualization
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#arithmetic-operations" title="Arithmetic Operations" class="md-nav__link">
    Arithmetic Operations
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#trigonometric-functions" title="Trigonometric Functions" class="md-nav__link">
    Trigonometric Functions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hyperbolic-functions" title="Hyperbolic Functions" class="md-nav__link">
    Hyperbolic Functions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#activation-functions" title="Activation Functions" class="md-nav__link">
    Activation Functions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#reference" title="Reference" class="md-nav__link">
    Reference
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#forward-softmax-output" title="forward softmax output" class="md-nav__link">
    forward softmax output
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#backward-gradient-output" title="backward gradient output" class="md-nav__link">
    backward gradient output
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#notice-that-the-first-row-is-all-0-because-label0-is-1-which-is-equal-to-ignore_label" title="notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label." class="md-nav__link">
    notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.
  </a>
  
</li>
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/dmlc/MXNet.jl/edit/master/docs/api/ndarray.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <p><a id='NDArray-API-1'></a></p>
<h1 id="ndarray-api">NDArray API</h1>
<p><a id='Arithmetic-Operations-1'></a></p>
<h2 id="arithmetic-operations">Arithmetic Operations</h2>
<p>In the following example <code>y</code> can be a <code>Real</code> value or another <code>NDArray</code></p>
<table>
<thead>
<tr>
<th align="right">API</th>
<th align="right">Example</th>
<th align="right"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="right"><code>+</code></td>
<td align="right"><code>x .+ y</code></td>
<td align="right">Elementwise summation</td>
</tr>
<tr>
<td align="right"><code>-</code></td>
<td align="right"><code>x .- y</code></td>
<td align="right">Elementwise minus</td>
</tr>
<tr>
<td align="right"><code>*</code></td>
<td align="right"><code>x .* y</code></td>
<td align="right">Elementwise multiplication</td>
</tr>
<tr>
<td align="right"><code>/</code></td>
<td align="right"><code>x ./ y</code></td>
<td align="right">Elementwise division</td>
</tr>
<tr>
<td align="right"><code>^</code></td>
<td align="right"><code>x .^ y</code></td>
<td align="right">Elementwise power</td>
</tr>
</tbody>
</table>
<p><a id='Trigonometric-Functions-1'></a></p>
<h2 id="trigonometric-functions">Trigonometric Functions</h2>
<table>
<thead>
<tr>
<th align="right">API</th>
<th align="right">Example</th>
<th align="right"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="right"><a href="./#Base.sin"><code>sin</code></a></td>
<td align="right"><code>sin.(x)</code></td>
<td align="right">Elementwise sine</td>
</tr>
<tr>
<td align="right"><a href="./#Base.cos"><code>cos</code></a></td>
<td align="right"><code>cos.(x)</code></td>
<td align="right">Elementwise cosine</td>
</tr>
<tr>
<td align="right"><a href="./#Base.tan"><code>tan</code></a></td>
<td align="right"><code>tan.(x)</code></td>
<td align="right">Elementwise tangent</td>
</tr>
<tr>
<td align="right"><a href="./#Base.asin"><code>asin</code></a></td>
<td align="right"><code>asin.(x)</code></td>
<td align="right">Elementwise inverse sine</td>
</tr>
<tr>
<td align="right"><a href="./#Base.acos"><code>acos</code></a></td>
<td align="right"><code>acos.(x)</code></td>
<td align="right">Elementwise inverse cosine</td>
</tr>
<tr>
<td align="right"><a href="./#Base.atan"><code>atan</code></a></td>
<td align="right"><code>atan.(x)</code></td>
<td align="right">Elementwise inverse tangent</td>
</tr>
</tbody>
</table>
<p><a id='Hyperbolic-Functions-1'></a></p>
<h2 id="hyperbolic-functions">Hyperbolic Functions</h2>
<table>
<thead>
<tr>
<th align="right">API</th>
<th align="right">Example</th>
<th align="right"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="right"><a href="./#Base.sinh"><code>sinh</code></a></td>
<td align="right"><code>sinh.(x)</code></td>
<td align="right">Elementwise hyperbolic sine</td>
</tr>
<tr>
<td align="right"><a href="./#Base.cosh"><code>cosh</code></a></td>
<td align="right"><code>cosh.(x)</code></td>
<td align="right">Elementwise hyperbolic cosine</td>
</tr>
<tr>
<td align="right"><a href="./#Base.tanh"><code>tanh</code></a></td>
<td align="right"><code>tanh.(x)</code></td>
<td align="right">Elementwise hyperbolic tangent</td>
</tr>
<tr>
<td align="right"><a href="./#Base.asinh"><code>asinh</code></a></td>
<td align="right"><code>asinh.(x)</code></td>
<td align="right">Elementwise inverse hyperbolic sine</td>
</tr>
<tr>
<td align="right"><a href="./#Base.acosh"><code>acosh</code></a></td>
<td align="right"><code>acosh.(x)</code></td>
<td align="right">Elementwise inverse hyperbolic cosine</td>
</tr>
<tr>
<td align="right"><a href="./#Base.atanh"><code>atanh</code></a></td>
<td align="right"><code>atanh.(x)</code></td>
<td align="right">Elementwise inverse hyperbolic tangent</td>
</tr>
</tbody>
</table>
<p><a id='Activation-Functions-1'></a></p>
<h2 id="activation-functions">Activation Functions</h2>
<table>
<thead>
<tr>
<th align="right">API</th>
<th align="right">Example</th>
<th align="right"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="right"><a href="./#MXNet.mx.σ"><code>σ</code></a></td>
<td align="right"><code>σ.(x)</code></td>
<td align="right">Sigmoid function</td>
</tr>
<tr>
<td align="right"><a href="./#MXNet.mx.sigmoid"><code>sigmoid</code></a></td>
<td align="right"><code>sigmoid.(x)</code></td>
<td align="right">Sigmoid function</td>
</tr>
<tr>
<td align="right"><a href="./#MXNet.mx.relu"><code>relu</code></a></td>
<td align="right"><code>relu.(x)</code></td>
<td align="right">ReLU function</td>
</tr>
<tr>
<td align="right"><a href="./#MXNet.mx.softmax"><code>softmax</code></a></td>
<td align="right"><code>softmax.(x)</code></td>
<td align="right">Softmax function</td>
</tr>
<tr>
<td align="right"><a href="./#MXNet.mx.log_softmax"><code>log_softmax</code></a></td>
<td align="right"><code>log_softmax.(x)</code></td>
<td align="right">Softmax followed by log</td>
</tr>
</tbody>
</table>
<p><a id='Reference-1'></a></p>
<h2 id="reference">Reference</h2>
<p><a id='MXNet.mx.NDArray' href='#MXNet.mx.NDArray'>#</a>
<strong><code>MXNet.mx.NDArray</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>NDArray
</code></pre>

<p>Wrapper of the <code>NDArray</code> type in <code>libmxnet</code>. This is the basic building block of tensor-based computation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>since C/C++ use row-major ordering for arrays while Julia follows a   column-major ordering. To keep things consistent, we keep the underlying data   in their original layout, but use <em>language-native</em> convention when we talk   about shapes. For example, a mini-batch of 100 MNIST images is a tensor of   C/C++/Python shape (100,1,28,28), while in Julia, the same piece of memory   have shape (28,28,1,100).</p>
</div>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L78-L91' class='documenter-source'>source</a><br></p>
<p><a id='Base.cos' href='#Base.cos'>#</a>
<strong><code>Base.cos</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>cos.(x::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1217' class='documenter-source'>source</a><br></p>
<p><a id='Base.cosh' href='#Base.cosh'>#</a>
<strong><code>Base.cosh</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>cosh.(x::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1225' class='documenter-source'>source</a><br></p>
<p><a id='Base.reshape-Tuple{MXNet.mx.NDArray,Any}' href='#Base.reshape-Tuple{MXNet.mx.NDArray,Any}'>#</a>
<strong><code>Base.reshape</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>reshape(arr::NDArray, dim; reverse=false)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1162' class='documenter-source'>source</a><br></p>
<p><a id='Base.reshape-Tuple{MXNet.mx.NDArray,Vararg{Any,N} where N}' href='#Base.reshape-Tuple{MXNet.mx.NDArray,Vararg{Any,N} where N}'>#</a>
<strong><code>Base.reshape</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>reshape(arr::NDArray, dim...; reverse=false)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1161' class='documenter-source'>source</a><br></p>
<p><a id='Base.sin' href='#Base.sin'>#</a>
<strong><code>Base.sin</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>sin.(x::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1216' class='documenter-source'>source</a><br></p>
<p><a id='Base.sinh' href='#Base.sinh'>#</a>
<strong><code>Base.sinh</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>sinh.(x::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1224' class='documenter-source'>source</a><br></p>
<p><a id='Base.tan' href='#Base.tan'>#</a>
<strong><code>Base.tan</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>tan.(x::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1218' class='documenter-source'>source</a><br></p>
<p><a id='Base.tanh' href='#Base.tanh'>#</a>
<strong><code>Base.tanh</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>tanh.(x::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1226' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.context-Tuple{MXNet.mx.NDArray}' href='#MXNet.mx.context-Tuple{MXNet.mx.NDArray}'>#</a>
<strong><code>MXNet.mx.context</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>context(arr::NDArray)
</code></pre>

<p>Get the context that this <code>NDArray</code> lives on.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L130-L134' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.empty-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64,N}},MXNet.mx.Context}, Tuple{Tuple{Vararg{Int64,N}}}} where N' href='#MXNet.mx.empty-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64,N}},MXNet.mx.Context}, Tuple{Tuple{Vararg{Int64,N}}}} where N'>#</a>
<strong><code>MXNet.mx.empty</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>empty(dims::Tuple[, ctx::Context = cpu()])
empty(dim1, dim2, ...)
</code></pre>

<p>Allocate memory for an uninitialized <code>NDArray</code> with specific shape of type Float32.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L154-L159' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.empty-Union{Tuple{N}, Tuple{T}, Tuple{Type{T},Tuple{Vararg{Int64,N}},MXNet.mx.Context}, Tuple{Type{T},Tuple{Vararg{Int64,N}}}} where T<:Union{Float16, Float32, Float64, Int32, Int64, Int8, UInt8} where N' href='#MXNet.mx.empty-Union{Tuple{N}, Tuple{T}, Tuple{Type{T},Tuple{Vararg{Int64,N}},MXNet.mx.Context}, Tuple{Type{T},Tuple{Vararg{Int64,N}}}} where T<:Union{Float16, Float32, Float64, Int32, Int64, Int8, UInt8} where N'>#</a>
<strong><code>MXNet.mx.empty</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>empty(DType, dims[, ctx::Context = cpu()])
empty(DType, dims)
empty(DType, dim1, dim2, ...)
</code></pre>

<p>Allocate memory for an uninitialized <code>NDArray</code> with a specified type.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L143-L149' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.expand_dims-Tuple{MXNet.mx.NDArray,Any}' href='#MXNet.mx.expand_dims-Tuple{MXNet.mx.NDArray,Any}'>#</a>
<strong><code>MXNet.mx.expand_dims</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>expand_dims(x::NDArray, dim)
</code></pre>

<p>Insert a new axis into <code>dim</code>.</p>
<pre><code class="julia">julia&gt; x
4 mx.NDArray{Float64,1} @ CPU0:
 1.0
 2.0
 3.0
 4.0

julia&gt; mx.expand_dims(x, 1)
1×4 mx.NDArray{Float64,2} @ CPU0:
 1.0  2.0  3.0  4.0

julia&gt; mx.expand_dims(x, 2)
4×1 mx.NDArray{Float64,2} @ CPU0:
 1.0
 2.0
 3.0
 4.0
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1213-L1237' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.log_softmax' href='#MXNet.mx.log_softmax'>#</a>
<strong><code>MXNet.mx.log_softmax</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>log_softmax.(x::NDArray, [dim = ndims(x)])
</code></pre>

<p>Computes the log softmax of the input. This is equivalent to computing softmax followed by log.</p>
<p>julia&gt; x 2×3 mx.NDArray{Float64,2} @ CPU0:  1.0  2.0  0.1  0.1  2.0  1.0</p>
<p>julia&gt; mx.log_softmax.(x) 2×3 mx.NDArray{Float64,2} @ CPU0:  -1.41703  -0.41703  -2.31703  -2.31703  -0.41703  -1.41703</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1289-L1304' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.relu' href='#MXNet.mx.relu'>#</a>
<strong><code>MXNet.mx.relu</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>relu.(x::NDArray)
</code></pre>

<p>Computes rectified linear.</p>
<p>
<script type="math/tex; mode=display">
\max(x, 0)
</script>
</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1256' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sigmoid' href='#MXNet.mx.sigmoid'>#</a>
<strong><code>MXNet.mx.sigmoid</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>σ.(x::NDArray)
sigmoid.(x::NDArray)
</code></pre>

<p>Computes sigmoid of x element-wise.</p>
<p>
<script type="math/tex; mode=display">
σ(x) = \frac{1}{(1 + exp(-x))}
</script>
</p>
<p>The storage type of <code>sigmoid</code> output is always dense.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1245' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.softmax' href='#MXNet.mx.softmax'>#</a>
<strong><code>MXNet.mx.softmax</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>softmax.(x::NDArray, [dim = ndims(x)])
</code></pre>

<p>Applies the softmax function.</p>
<p>The resulting array contains elements in the range <code>(0, 1)</code> and the elements along the given axis sum up to 1.</p>
<p>
<script type="math/tex; mode=display">
softmax(\mathbf{z})_j = \frac{e^{z_j}}{\sum_{k=1}^K e^{z_k}}
</script>
</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1270' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.σ' href='#MXNet.mx.σ'>#</a>
<strong><code>MXNet.mx.σ</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>σ.(x::NDArray)
sigmoid.(x::NDArray)
</code></pre>

<p>Computes sigmoid of x element-wise.</p>
<p>
<script type="math/tex; mode=display">
σ(x) = \frac{1}{(1 + exp(-x))}
</script>
</p>
<p>The storage type of <code>sigmoid</code> output is always dense.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1244' class='documenter-source'>source</a><br></p>
<p><a id='Base.Iterators.Flatten-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.Iterators.Flatten-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.Iterators.Flatten</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Flatten(data)
</code></pre>

<p>Flattens the input array into a 2-D array by collapsing the higher dimensions.</p>
<p>.. note:: <code>Flatten</code> is deprecated. Use <code>flatten</code> instead.</p>
<p>For an input array with shape $(d1, d2, ..., dk)$, <code>flatten</code> operation reshapes the input array into an output array of shape $(d1, d2<em>...</em>dk)$.</p>
<p>Example::</p>
<pre><code>x = [[
    [1,2,3],
    [4,5,6],
    [7,8,9]
],
[    [1,2,3],
    [4,5,6],
    [7,8,9]
]],

flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],
   [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]
</code></pre>

<p>Defined in src/operator/tensor/matrix_op.cc:L208</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1515' class='documenter-source'>source</a><br></p>
<p><a id='Base.:%-Tuple{MXNet.mx.NDArray,Real}' href='#Base.:%-Tuple{MXNet.mx.NDArray,Real}'>#</a>
<strong><code>Base.:%</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>.%(x::NDArray, y::NDArray)
.%(x::NDArray, y::Real)
.%(x::Real, y::NDArray)
</code></pre>

<p>Elementwise modulo for <code>NDArray</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L753-L759' class='documenter-source'>source</a><br></p>
<p><a id='Base.:*-Tuple{MXNet.mx.NDArray,Real}' href='#Base.:*-Tuple{MXNet.mx.NDArray,Real}'>#</a>
<strong><code>Base.:*</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>.*(x, y)
</code></pre>

<p>Elementwise multiplication for <code>NDArray</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L674-L678' class='documenter-source'>source</a><br></p>
<p><a id='Base.:*-Union{Tuple{MXNet.mx.NDArray{T,D} where D,MXNet.mx.NDArray{T,D} where D}, Tuple{T}} where T' href='#Base.:*-Union{Tuple{MXNet.mx.NDArray{T,D} where D,MXNet.mx.NDArray{T,D} where D}, Tuple{T}} where T'>#</a>
<strong><code>Base.:*</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>*(A::NDArray, B::NDArray)
</code></pre>

<p>Matrix/tensor multiplication.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L686-L690' class='documenter-source'>source</a><br></p>
<p><a id='Base.:+-Tuple{MXNet.mx.NDArray}' href='#Base.:+-Tuple{MXNet.mx.NDArray}'>#</a>
<strong><code>Base.:+</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>+(args...)
.+(args...)
</code></pre>

<p>Summation. Multiple arguments of either scalar or <code>NDArray</code> could be added together. Note at least the first or second argument needs to be an <code>NDArray</code> to avoid ambiguity of built-in summation.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L607-L614' class='documenter-source'>source</a><br></p>
<p><a id='Base.:--Tuple{MXNet.mx.NDArray}' href='#Base.:--Tuple{MXNet.mx.NDArray}'>#</a>
<strong><code>Base.:-</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>-(x::NDArray)
-(x, y)
.-(x, y)
</code></pre>

<p>Subtraction <code>x - y</code>, of scalar types or <code>NDArray</code>. Or create the negative of <code>x</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L640-L647' class='documenter-source'>source</a><br></p>
<p><a id='Base.:/-Tuple{MXNet.mx.NDArray,Real}' href='#Base.:/-Tuple{MXNet.mx.NDArray,Real}'>#</a>
<strong><code>Base.:/</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>./(x::NDArray, y::NDArray)
./(x::NDArray, y::Real)
./(x::Real, y::NDArray)
</code></pre>

<ul>
<li>Elementwise dividing an <code>NDArray</code> by a scalar or another <code>NDArray</code></li>
</ul>
<p>of the same shape.</p>
<ul>
<li>Elementwise divide a scalar by an <code>NDArray</code>.</li>
<li>Matrix division (solving linear systems) is not implemented yet.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L728-L739' class='documenter-source'>source</a><br></p>
<p><a id='Base.LinAlg.dot-Tuple{MXNet.mx.NDArray,MXNet.mx.NDArray}' href='#Base.LinAlg.dot-Tuple{MXNet.mx.NDArray,MXNet.mx.NDArray}'>#</a>
<strong><code>Base.LinAlg.dot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>dot(x::NDArray, y::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1177' class='documenter-source'>source</a><br></p>
<p><a id='Base.LinAlg.norm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.LinAlg.norm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.LinAlg.norm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>norm(data)
</code></pre>

<p>Flattens the input array and then computes the l2 norm.</p>
<p>Examples::</p>
<p>x = [[1, 2],        [3, 4]]</p>
<p>norm(x) = [5.47722578]</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L257</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1502' class='documenter-source'>source</a><br></p>
<p><a id='Base.Math.cbrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.Math.cbrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.Math.cbrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cbrt(data)
</code></pre>

<p>Returns element-wise cube-root value of the input.</p>
<p>.. math::    cbrt(x) = \sqrt[3]{x}</p>
<p>Example::</p>
<p>cbrt([1, 8, -125]) = [1, 2, -5]</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L602</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1502' class='documenter-source'>source</a><br></p>
<p><a id='Base.Math.gamma-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.Math.gamma-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.Math.gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>gamma(data)
</code></pre>

<p>Returns the gamma function (extension of the factorial function 
to the reals), computed element-wise on the input array.</p>
<p>The storage type of $gamma$ output is always dense</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1496' class='documenter-source'>source</a><br></p>
<p><a id='Base._div-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base._div-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base._div</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_div(lhs, rhs)
</code></pre>

<p>_div is an alias of elemwise_div.</p>
<p>Divides arguments element-wise.</p>
<p>The storage type of $elemwise_div$ output is always dense</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1499' class='documenter-source'>source</a><br></p>
<p><a id='Base._sub-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base._sub-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base._sub</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sub(lhs, rhs)
</code></pre>

<p>_sub is an alias of elemwise_sub.</p>
<p>Subtracts arguments element-wise.</p>
<p>The storage type of $elemwise_sub$ output depends on storage types of inputs</p>
<ul>
<li>elemwise_sub(row_sparse, row_sparse) = row_sparse</li>
<li>elemwise_sub(csr, csr) = csr</li>
<li>otherwise, $elemwise_sub$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1503' class='documenter-source'>source</a><br></p>
<p><a id='Base.abs-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.abs-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.abs</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>abs(data)
</code></pre>

<p>Returns element-wise absolute value of the input.</p>
<p>Example::</p>
<p>abs([-2, 0, 3]) = [2, 0, 3]</p>
<p>The storage type of $abs$ output depends upon the input storage type:</p>
<ul>
<li>abs(default) = default</li>
<li>abs(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L386</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1504' class='documenter-source'>source</a><br></p>
<p><a id='Base.acos' href='#Base.acos'>#</a>
<strong><code>Base.acos</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>acos.(x::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1220' class='documenter-source'>source</a><br></p>
<p><a id='Base.acosh' href='#Base.acosh'>#</a>
<strong><code>Base.acosh</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>acosh.(x::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1228' class='documenter-source'>source</a><br></p>
<p><a id='Base.asin' href='#Base.asin'>#</a>
<strong><code>Base.asin</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>asin.(x::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1219' class='documenter-source'>source</a><br></p>
<p><a id='Base.asinh' href='#Base.asinh'>#</a>
<strong><code>Base.asinh</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>asinh.(x::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1227' class='documenter-source'>source</a><br></p>
<p><a id='Base.atan' href='#Base.atan'>#</a>
<strong><code>Base.atan</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>atan.(x::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1221' class='documenter-source'>source</a><br></p>
<p><a id='Base.atanh' href='#Base.atanh'>#</a>
<strong><code>Base.atanh</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>atanh.(x::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1229' class='documenter-source'>source</a><br></p>
<p><a id='Base.cat-Union{Tuple{Int64,Vararg{MXNet.mx.NDArray{T,D} where D,N} where N}, Tuple{T}} where T' href='#Base.cat-Union{Tuple{Int64,Vararg{MXNet.mx.NDArray{T,D} where D,N} where N}, Tuple{T}} where T'>#</a>
<strong><code>Base.cat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cat(dim, xs::NDArray...)
</code></pre>

<p>Concate the <code>NDArray</code>s which have the same element type along the <code>dim</code>. Building a diagonal matrix is not supported yet.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L535-L540' class='documenter-source'>source</a><br></p>
<p><a id='Base.ceil-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.ceil-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.ceil</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ceil(data)
</code></pre>

<p>Returns element-wise ceiling of the input.</p>
<p>The ceil of the scalar x is the smallest integer i, such that i &gt;= x.</p>
<p>Example::</p>
<p>ceil([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  2.,  2.,  3.]</p>
<p>The storage type of $ceil$ output depends upon the input storage type:</p>
<ul>
<li>ceil(default) = default</li>
<li>ceil(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L464</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1506' class='documenter-source'>source</a><br></p>
<p><a id='Base.convert-Tuple{Type{Array{#s147,N} where N where #s147<:Real},MXNet.mx.NDArray}' href='#Base.convert-Tuple{Type{Array{#s147,N} where N where #s147<:Real},MXNet.mx.NDArray}'>#</a>
<strong><code>Base.convert</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>convert(::Type{Array{&lt;:Real}}, x::NDArray)
</code></pre>

<p>Convert an <code>NDArray</code> into a Julia <code>Array</code> of specific type. Data will be copied.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L505-L510' class='documenter-source'>source</a><br></p>
<p><a id='Base.copy!-Tuple{MXNet.mx.NDArray,MXNet.mx.NDArray}' href='#Base.copy!-Tuple{MXNet.mx.NDArray,MXNet.mx.NDArray}'>#</a>
<strong><code>Base.copy!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>copy!(dst :: Union{NDArray, Array}, src :: Union{NDArray, Array})
</code></pre>

<p>Copy contents of <code>src</code> into <code>dst</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L439-L443' class='documenter-source'>source</a><br></p>
<p><a id='Base.copy-Union{Tuple{D}, Tuple{MXNet.mx.NDArray{T,D}}, Tuple{T}} where D where T' href='#Base.copy-Union{Tuple{D}, Tuple{MXNet.mx.NDArray{T,D}}, Tuple{T}} where D where T'>#</a>
<strong><code>Base.copy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>copy(arr :: NDArray)
copy(arr :: NDArray, ctx :: Context)
copy(arr :: Array, ctx :: Context)
</code></pre>

<p>Create a copy of an array. When no <code>Context</code> is given, create a Julia <code>Array</code>. Otherwise, create an <code>NDArray</code> on the specified context.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L483-L490' class='documenter-source'>source</a><br></p>
<p><a id='Base.deepcopy-Tuple{MXNet.mx.NDArray}' href='#Base.deepcopy-Tuple{MXNet.mx.NDArray}'>#</a>
<strong><code>Base.deepcopy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>deepcopy(arr::NDArray)
</code></pre>

<p>Get a deep copy of the data blob in the form of an NDArray of default storage type. This function blocks. Do not use it in performance critical code.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L513-L518' class='documenter-source'>source</a><br></p>
<p><a id='Base.eltype-Tuple{Union{MXNet.mx.MX_NDArrayHandle, MXNet.mx.NDArray}}' href='#Base.eltype-Tuple{Union{MXNet.mx.MX_NDArrayHandle, MXNet.mx.NDArray}}'>#</a>
<strong><code>Base.eltype</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>eltype(x::NDArray)
</code></pre>

<p>Get the element type of an <code>NDArray</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L275-L279' class='documenter-source'>source</a><br></p>
<p><a id='Base.exp-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.exp-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.exp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>exp(data)
</code></pre>

<p>Returns element-wise exponential value of the input.</p>
<p>.. math::    exp(x) = e^x \approx 2.718^x</p>
<p>Example::</p>
<p>exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]</p>
<p>The storage type of $exp$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L642</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1504' class='documenter-source'>source</a><br></p>
<p><a id='Base.expm1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.expm1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.expm1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>expm1(data)
</code></pre>

<p>Returns $exp(x) - 1$ computed element-wise on the input.</p>
<p>This function provides greater precision than $exp(x) - 1$ for small values of $x$.</p>
<p>The storage type of $expm1$ output depends upon the input storage type:</p>
<ul>
<li>expm1(default) = default</li>
<li>expm1(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L721</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1502' class='documenter-source'>source</a><br></p>
<p><a id='Base.fill!-Tuple{MXNet.mx.NDArray,Any}' href='#Base.fill!-Tuple{MXNet.mx.NDArray,Any}'>#</a>
<strong><code>Base.fill!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>fill!(arr::NDArray, x)
</code></pre>

<p>Create an <code>NDArray</code> filled with the value <code>x</code>, like <code>Base.fill!</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L778-L782' class='documenter-source'>source</a><br></p>
<p><a id='Base.floor-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.floor-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.floor</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>floor(data)
</code></pre>

<p>Returns element-wise floor of the input.</p>
<p>The floor of the scalar x is the largest integer i, such that i &lt;= x.</p>
<p>Example::</p>
<p>floor([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-3., -2.,  1.,  1.,  2.]</p>
<p>The storage type of $floor$ output depends upon the input storage type:</p>
<ul>
<li>floor(default) = default</li>
<li>floor(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L483</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1506' class='documenter-source'>source</a><br></p>
<p><a id='Base.getindex-Tuple{MXNet.mx.NDArray,Colon}' href='#Base.getindex-Tuple{MXNet.mx.NDArray,Colon}'>#</a>
<strong><code>Base.getindex</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>getindex(arr::NDArray, idx)
</code></pre>

<p>Shortcut for <a href="../symbolic-node/#MXNet.mx.slice-Tuple{Vararg{MXNet.mx.SymbolicNode,N} where N}"><code>slice</code></a>. A typical use is to write</p>
<pre><code class="julia">  arr[:] += 5
</code></pre>

<p>which translates into</p>
<pre><code class="julia">  arr[:] = arr[:] + 5
</code></pre>

<p>which furthur translates into</p>
<pre><code class="julia">  setindex!(getindex(arr, Colon()), 5, Colon())
</code></pre>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The behavior is quite different from indexing into Julia's <code>Array</code>. For example, <code>arr[2:5]</code> create a <strong>copy</strong> of the sub-array for Julia <code>Array</code>, while for <code>NDArray</code>, this is a <em>slice</em> that shares the memory.</p>
</div>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L378-L403' class='documenter-source'>source</a><br></p>
<p><a id='Base.getindex-Tuple{MXNet.mx.NDArray,UnitRange{Int64}}' href='#Base.getindex-Tuple{MXNet.mx.NDArray,UnitRange{Int64}}'>#</a>
<strong><code>Base.getindex</code></strong> &mdash; <em>Method</em>.</p>
<p>Shortcut for <a href="../symbolic-node/#MXNet.mx.slice-Tuple{Vararg{MXNet.mx.SymbolicNode,N} where N}"><code>slice</code></a>. <strong>NOTE</strong> the behavior for Julia's built-in index slicing is to create a copy of the sub-array, while here we simply call <code>slice</code>, which shares the underlying memory.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L406-L411' class='documenter-source'>source</a><br></p>
<p><a id='Base.hcat-Union{Tuple{T}, Tuple{Vararg{MXNet.mx.NDArray{T,D} where D,N} where N}} where T' href='#Base.hcat-Union{Tuple{T}, Tuple{Vararg{MXNet.mx.NDArray{T,D} where D,N} where N}} where T'>#</a>
<strong><code>Base.hcat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>hcat(x::NDArray...)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L525-L527' class='documenter-source'>source</a><br></p>
<p><a id='Base.identity-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.identity-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.identity</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>identity(data)
</code></pre>

<p>identity is an alias of _copy.</p>
<p>Returns a copy of the input.</p>
<p>From:src/operator/tensor/elemwise_unary_op_basic.cc:112</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='Base.length-Tuple{MXNet.mx.NDArray}' href='#Base.length-Tuple{MXNet.mx.NDArray}'>#</a>
<strong><code>Base.length</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>length(x::NDArray)
</code></pre>

<p>Get the number of elements in an <code>NDArray</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L252-L256' class='documenter-source'>source</a><br></p>
<p><a id='Base.log-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.log-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.log</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>log(data)
</code></pre>

<p>Returns element-wise Natural logarithmic value of the input.</p>
<p>The natural logarithm is logarithm in base <em>e</em>, so that $log(exp(x)) = x$</p>
<p>The storage type of $log$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L654</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1499' class='documenter-source'>source</a><br></p>
<p><a id='Base.log10-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.log10-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.log10</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>log10(data)
</code></pre>

<p>Returns element-wise Base-10 logarithmic value of the input.</p>
<p>$10**log10(x) = x$</p>
<p>The storage type of $log10$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L666</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1499' class='documenter-source'>source</a><br></p>
<p><a id='Base.log1p-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.log1p-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.log1p</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>log1p(data)
</code></pre>

<p>Returns element-wise $log(1 + x)$ value of the input.</p>
<p>This function is more accurate than $log(1 + x)$  for small $x$ so that :math:<code>1+x\approx 1</code></p>
<p>The storage type of $log1p$ output depends upon the input storage type:</p>
<ul>
<li>log1p(default) = default</li>
<li>log1p(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L703</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1503' class='documenter-source'>source</a><br></p>
<p><a id='Base.log2-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.log2-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.log2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>log2(data)
</code></pre>

<p>Returns element-wise Base-2 logarithmic value of the input.</p>
<p>$2**log2(x) = x$</p>
<p>The storage type of $log2$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L678</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1499' class='documenter-source'>source</a><br></p>
<p><a id='Base.maximum-Tuple{MXNet.mx.NDArray,Any}' href='#Base.maximum-Tuple{MXNet.mx.NDArray,Any}'>#</a>
<strong><code>Base.maximum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>maximum(arr::NDArray, dims)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1171' class='documenter-source'>source</a><br></p>
<p><a id='Base.maximum-Tuple{MXNet.mx.NDArray}' href='#Base.maximum-Tuple{MXNet.mx.NDArray}'>#</a>
<strong><code>Base.maximum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>maximum(arr::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1170' class='documenter-source'>source</a><br></p>
<p><a id='Base.mean-Tuple{MXNet.mx.NDArray,Any}' href='#Base.mean-Tuple{MXNet.mx.NDArray,Any}'>#</a>
<strong><code>Base.mean</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>mean(arr::NDArray, region)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1165' class='documenter-source'>source</a><br></p>
<p><a id='Base.mean-Tuple{MXNet.mx.NDArray}' href='#Base.mean-Tuple{MXNet.mx.NDArray}'>#</a>
<strong><code>Base.mean</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>mean(arr::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1164' class='documenter-source'>source</a><br></p>
<p><a id='Base.minimum-Tuple{MXNet.mx.NDArray,Any}' href='#Base.minimum-Tuple{MXNet.mx.NDArray,Any}'>#</a>
<strong><code>Base.minimum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>minimum(arr::NDArray, dims)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1174' class='documenter-source'>source</a><br></p>
<p><a id='Base.minimum-Tuple{MXNet.mx.NDArray}' href='#Base.minimum-Tuple{MXNet.mx.NDArray}'>#</a>
<strong><code>Base.minimum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>minimum(arr::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1173' class='documenter-source'>source</a><br></p>
<p><a id='Base.ndims-Tuple{MXNet.mx.NDArray}' href='#Base.ndims-Tuple{MXNet.mx.NDArray}'>#</a>
<strong><code>Base.ndims</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ndims(x::NDArray)
</code></pre>

<p>Get the number of dimensions of an <code>NDArray</code>. Is equivalent to <code>length(size(arr))</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L259-L264' class='documenter-source'>source</a><br></p>
<p><a id='Base.permutedims-Tuple{MXNet.mx.NDArray,Any}' href='#Base.permutedims-Tuple{MXNet.mx.NDArray,Any}'>#</a>
<strong><code>Base.permutedims</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>permutedims(arr::NDArray, axes)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1182' class='documenter-source'>source</a><br></p>
<p><a id='Base.prod-Tuple{MXNet.mx.NDArray,Any}' href='#Base.prod-Tuple{MXNet.mx.NDArray,Any}'>#</a>
<strong><code>Base.prod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>prod(arr::NDArray, dims)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1185' class='documenter-source'>source</a><br></p>
<p><a id='Base.prod-Tuple{MXNet.mx.NDArray}' href='#Base.prod-Tuple{MXNet.mx.NDArray}'>#</a>
<strong><code>Base.prod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>prod(arr::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1184' class='documenter-source'>source</a><br></p>
<p><a id='Base.repeat-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.repeat-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.repeat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>repeat(data, repeats, axis)
</code></pre>

<p>Repeats elements of an array.</p>
<p>By default, $repeat$ flattens the input array into 1-D and then repeats the elements::</p>
<p>x = [[ 1, 2],        [ 3, 4]]</p>
<p>repeat(x, repeats=2) = [ 1.,  1.,  2.,  2.,  3.,  3.,  4.,  4.]</p>
<p>The parameter $axis$ specifies the axis along which to perform repeat::</p>
<p>repeat(x, repeats=2, axis=1) = [[ 1.,  1.,  2.,  2.],                                   [ 3.,  3.,  4.,  4.]]</p>
<p>repeat(x, repeats=2, axis=0) = [[ 1.,  2.],                                   [ 1.,  2.],                                   [ 3.,  4.],                                   [ 3.,  4.]]</p>
<p>repeat(x, repeats=2, axis=-1) = [[ 1.,  1.,  2.,  2.],                                    [ 3.,  3.,  4.,  4.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L560</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data array</li>
<li><code>repeats::int, required</code>: The number of repetitions for each element.</li>
<li><code>axis::int or None, optional, default='None'</code>: The axis along which to repeat values. The negative numbers are interpreted counting from the backward. By default, use the flattened input array, and return a flat output array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1520' class='documenter-source'>source</a><br></p>
<p><a id='Base.reverse-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.reverse-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.reverse</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>reverse(data, axis)
</code></pre>

<p>Reverses the order of elements along given axis while preserving array shape.</p>
<p>Note: reverse and flip are equivalent. We use reverse in the following examples.</p>
<p>Examples::</p>
<p>x = [[ 0.,  1.,  2.,  3.,  4.],        [ 5.,  6.,  7.,  8.,  9.]]</p>
<p>reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],                         [ 0.,  1.,  2.,  3.,  4.]]</p>
<p>reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],                         [ 9.,  8.,  7.,  6.,  5.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L662</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data array</li>
<li><code>axis::Shape(tuple), required</code>: The axis which to reverse elements.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1509' class='documenter-source'>source</a><br></p>
<p><a id='Base.round-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.round-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.round</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>round(data)
</code></pre>

<p>Returns element-wise rounded value to the nearest integer of the input.</p>
<p>Example::</p>
<p>round([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  2., -2.,  2.,  2.]</p>
<p>The storage type of $round$ output depends upon the input storage type:</p>
<ul>
<li>round(default) = default</li>
<li>round(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L424</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1504' class='documenter-source'>source</a><br></p>
<p><a id='Base.setindex!-Tuple{MXNet.mx.NDArray,Real,Integer}' href='#Base.setindex!-Tuple{MXNet.mx.NDArray,Real,Integer}'>#</a>
<strong><code>Base.setindex!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>setindex!(arr::NDArray, val, idx)
</code></pre>

<p>Assign values to an <code>NDArray</code>. The following scenarios are supported</p>
<ul>
<li>single value assignment via linear indexing: <code>arr[42] = 24</code></li>
<li><code>arr[:] = val</code>: whole array assignment, <code>val</code> could be a scalar or an array (Julia <code>Array</code> or <code>NDArray</code>) of the same shape.</li>
<li><code>arr[start:stop] = val</code>: assignment to a <em>slice</em>, <code>val</code> could be a scalar or an array of the same shape to the slice. See also <a href="../symbolic-node/#MXNet.mx.slice-Tuple{Vararg{MXNet.mx.SymbolicNode,N} where N}"><code>slice</code></a>.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L337-L349' class='documenter-source'>source</a><br></p>
<p><a id='Base.sign-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.sign-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.sign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sign(data)
</code></pre>

<p>Returns element-wise sign of the input.</p>
<p>Example::</p>
<p>sign([-2, 0, 3]) = [-1, 0, 1]</p>
<p>The storage type of $sign$ output depends upon the input storage type:</p>
<ul>
<li>sign(default) = default</li>
<li>sign(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L405</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1504' class='documenter-source'>source</a><br></p>
<p><a id='Base.similar-Union{Tuple{MXNet.mx.NDArray{T,D} where D}, Tuple{T}} where T' href='#Base.similar-Union{Tuple{MXNet.mx.NDArray{T,D} where D}, Tuple{T}} where T'>#</a>
<strong><code>Base.similar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>similar(x::NDArray)
</code></pre>

<p>Create an <code>NDArray</code> with similar shape, data type, and context with the given one. Note that the returned <code>NDArray</code> is uninitialized.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L164-L170' class='documenter-source'>source</a><br></p>
<p><a id='Base.size-Tuple{MXNet.mx.NDArray}' href='#Base.size-Tuple{MXNet.mx.NDArray}'>#</a>
<strong><code>Base.size</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>size(x::NDArray)
size(x::NDArray, dims...)
</code></pre>

<p>Get the shape of an <code>NDArray</code>. The shape is in Julia's column-major convention. See also the notes on NDArray shapes <a href="./#MXNet.mx.NDArray"><code>NDArray</code></a>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L227-L233' class='documenter-source'>source</a><br></p>
<p><a id='Base.sort-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.sort-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.sort</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sort(data, axis, is_ascend)
</code></pre>

<p>Returns a sorted copy of an input array along the given axis.</p>
<p>Examples::</p>
<p>x = [[ 1, 4],        [ 3, 1]]</p>
<p>// sorts along the last axis   sort(x) = [[ 1.,  4.],              [ 1.,  3.]]</p>
<p>// flattens and then sorts   sort(x) = [ 1.,  1.,  3.,  4.]</p>
<p>// sorts along the first axis   sort(x, axis=0) = [[ 1.,  1.],                      [ 3.,  4.]]</p>
<p>// in a descend order   sort(x, is_ascend=0) = [[ 4.,  1.],                           [ 3.,  1.]]</p>
<p>Defined in src/operator/tensor/ordering_op.cc:L126</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>axis::int or None, optional, default='-1'</code>: Axis along which to choose sort the input tensor. If not given, the flattened array is used. Default is -1.</li>
<li><code>is_ascend::boolean, optional, default=1</code>: Whether to sort in ascending or descending order.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1519' class='documenter-source'>source</a><br></p>
<p><a id='Base.split-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.split-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.split</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>split(data, num_outputs, axis, squeeze_axis)
</code></pre>

<p>split is an alias of SliceChannel.</p>
<p>Splits an array along a particular axis into multiple sub-arrays.</p>
<p>.. note:: $SliceChannel$ is deprecated. Use $split$ instead.</p>
<p><strong>Note</strong> that <code>num_outputs</code> should evenly divide the length of the axis along which to split the array.</p>
<p>Example::</p>
<p>x  = [[[ 1.]           [ 2.]]          [[ 3.]           [ 4.]]          [[ 5.]           [ 6.]]]    x.shape = (3, 2, 1)</p>
<p>y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)    y = [[[ 1.]]         [[ 3.]]         [[ 5.]]]</p>
<pre><code>   [[[ 2.]]
    [[ 4.]]
    [[ 6.]]]
</code></pre>

<p>y[0].shape = (3, 1, 1)</p>
<p>z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)    z = [[[ 1.]          [ 2.]]]</p>
<pre><code>   [[[ 3.]
     [ 4.]]]

   [[[ 5.]
     [ 6.]]]
</code></pre>

<p>z[0].shape = (1, 2, 1)</p>
<p><code>squeeze_axis=1</code> removes the axis with length 1 from the shapes of the output arrays. <strong>Note</strong> that setting <code>squeeze_axis</code> to $1$ removes axis with length 1 only along the <code>axis</code> which it is split. Also <code>squeeze_axis</code> can be set to true only if $input.shape[axis] == num_outputs$.</p>
<p>Example::</p>
<p>z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)    z = [[ 1.]         [ 2.]]</p>
<pre><code>   [[ 3.]
    [ 4.]]

   [[ 5.]
    [ 6.]]
</code></pre>

<p>z[0].shape = (2 ,1 )</p>
<p>Defined in src/operator/slice_channel.cc:L107</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>num_outputs::int, required</code>: Number of splits. Note that this should evenly divide the length of the <code>axis</code>.</li>
<li><code>axis::int, optional, default='1'</code>: Axis along which to split.</li>
<li><code>squeeze_axis::boolean, optional, default=0</code>: If true, Removes the axis with length 1 from the shapes of the output arrays. <strong>Note</strong> that setting <code>squeeze_axis</code> to $true$ removes axis with length 1 only along the <code>axis</code> which it is split. Also <code>squeeze_axis</code> can be set to $true$ only if $input.shape[axis] == num_outputs$.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1559' class='documenter-source'>source</a><br></p>
<p><a id='Base.sqrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.sqrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.sqrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sqrt(data)
</code></pre>

<p>Returns element-wise square-root value of the input.</p>
<p>.. math::    \textrm{sqrt}(x) = \sqrt{x}</p>
<p>Example::</p>
<p>sqrt([4, 9, 16]) = [2, 3, 4]</p>
<p>The storage type of $sqrt$ output depends upon the input storage type:</p>
<ul>
<li>sqrt(default) = default</li>
<li>sqrt(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L565</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1507' class='documenter-source'>source</a><br></p>
<p><a id='Base.sum-Tuple{MXNet.mx.NDArray,Any}' href='#Base.sum-Tuple{MXNet.mx.NDArray,Any}'>#</a>
<strong><code>Base.sum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sum(arr::NDArray, dims)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1168' class='documenter-source'>source</a><br></p>
<p><a id='Base.sum-Tuple{MXNet.mx.NDArray}' href='#Base.sum-Tuple{MXNet.mx.NDArray}'>#</a>
<strong><code>Base.sum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sum(arr::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1167' class='documenter-source'>source</a><br></p>
<p><a id='Base.transpose-Union{Tuple{MXNet.mx.NDArray{T,1}}, Tuple{T}} where T' href='#Base.transpose-Union{Tuple{MXNet.mx.NDArray{T,1}}, Tuple{T}} where T'>#</a>
<strong><code>Base.transpose</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>transpose(arr::NDArray{T, 1}) where T
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1180' class='documenter-source'>source</a><br></p>
<p><a id='Base.transpose-Union{Tuple{MXNet.mx.NDArray{T,2}}, Tuple{T}} where T' href='#Base.transpose-Union{Tuple{MXNet.mx.NDArray{T,2}}, Tuple{T}} where T'>#</a>
<strong><code>Base.transpose</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>transpose(arr::NDArray{T, 2}) where T
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1181' class='documenter-source'>source</a><br></p>
<p><a id='Base.trunc-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#Base.trunc-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>Base.trunc</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>trunc(data)
</code></pre>

<p>Return the element-wise truncated value of the input.</p>
<p>The truncated value of the scalar x is the nearest integer i which is closer to zero than x is. In short, the fractional part of the signed number x is discarded.</p>
<p>Example::</p>
<p>trunc([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  1.,  1.,  2.]</p>
<p>The storage type of $trunc$ output depends upon the input storage type:</p>
<ul>
<li>trunc(default) = default</li>
<li>trunc(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L503</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1507' class='documenter-source'>source</a><br></p>
<p><a id='Base.vcat-Union{Tuple{T}, Tuple{Vararg{MXNet.mx.NDArray{T,D} where D,N} where N}} where T' href='#Base.vcat-Union{Tuple{T}, Tuple{Vararg{MXNet.mx.NDArray{T,D} where D,N} where N}} where T'>#</a>
<strong><code>Base.vcat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>vcat(x::NDArray...)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L530-L532' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Activation-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.Activation-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.Activation</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Activation(data, act_type)
</code></pre>

<p>Applies an activation function element-wise to the input.</p>
<p>The following activation functions are supported:</p>
<ul>
<li><code>relu</code>: Rectified Linear Unit, :math:<code>y = max(x, 0)</code></li>
<li><code>sigmoid</code>: :math:<code>y = \frac{1}{1 + exp(-x)}</code></li>
<li><code>tanh</code>: Hyperbolic tangent, :math:<code>y = \frac{exp(x) - exp(-x)}{exp(x) + exp(-x)}</code></li>
<li><code>softrelu</code>: Soft ReLU, or SoftPlus, :math:<code>y = log(1 + exp(x))</code></li>
</ul>
<p>Defined in src/operator/nn/activation.cc:L92</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array to activation function.</li>
<li><code>act_type::{'relu', 'sigmoid', 'softrelu', 'tanh'}, required</code>: Activation function to be applied.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1504' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.BatchNorm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.BatchNorm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.BatchNorm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>BatchNorm(data, gamma, beta, moving_mean, moving_var, eps, momentum, fix_gamma, use_global_stats, output_mean_var, axis, cudnn_off)
</code></pre>

<p>Batch normalization.</p>
<p>Normalizes a data batch by mean and variance, and applies a scale $gamma$ as well as offset $beta$.</p>
<p>Assume the input has more than one dimension and we normalize along axis 1. We first compute the mean and variance along this axis:</p>
<p>.. math::</p>
<p>data_mean[i] = mean(data[:,i,:,...]) \
  data_var[i] = var(data[:,i,:,...])</p>
<p>Then compute the normalized output, which has the same shape as input, as following:</p>
<p>.. math::</p>
<p>out[:,i,:,...] = \frac{data[:,i,:,...] - data_mean[i]}{\sqrt{data_var[i]+\epsilon}} * gamma[i] + beta[i]</p>
<p>Both <em>mean</em> and <em>var</em> returns a scalar by treating the input as a vector.</p>
<p>Assume the input has size <em>k</em> on axis 1, then both $gamma$ and $beta$ have shape <em>(k,)</em>. If $output_mean_var$ is set to be true, then outputs both $data_mean$ and $data_var$ as well, which are needed for the backward pass.</p>
<p>Besides the inputs and the outputs, this operator accepts two auxiliary states, $moving_mean$ and $moving_var$, which are <em>k</em>-length vectors. They are global statistics for the whole dataset, which are updated by::</p>
<p>moving_mean = moving_mean * momentum + data_mean * (1 - momentum)   moving_var = moving_var * momentum + data_var * (1 - momentum)</p>
<p>If $use_global_stats$ is set to be true, then $moving_mean$ and $moving_var$ are used instead of $data_mean$ and $data_var$ to compute the output. It is often used during inference.</p>
<p>The parameter $axis$ specifies which axis of the input shape denotes the 'channel' (separately normalized groups).  The default is 1.  Specifying -1 sets the channel axis to be the last item in the input shape.</p>
<p>Both $gamma$ and $beta$ are learnable parameters. But if $fix_gamma$ is true, then set $gamma$ to 1 and its gradient to 0.</p>
<p>Defined in src/operator/nn/batch_norm.cc:L400</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to batch normalization</li>
<li><code>gamma::NDArray-or-SymbolicNode</code>: gamma array</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: beta array</li>
<li><code>moving_mean::NDArray-or-SymbolicNode</code>: running mean of input</li>
<li><code>moving_var::NDArray-or-SymbolicNode</code>: running variance of input</li>
<li><code>eps::double, optional, default=0.001</code>: Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</li>
<li><code>momentum::float, optional, default=0.9</code>: Momentum for moving average</li>
<li><code>fix_gamma::boolean, optional, default=1</code>: Fix gamma while training</li>
<li><code>use_global_stats::boolean, optional, default=0</code>: Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</li>
<li><code>output_mean_var::boolean, optional, default=0</code>: Output All,normal mean and var</li>
<li><code>axis::int, optional, default='1'</code>: Specify which shape axis the channel is specified</li>
<li><code>cudnn_off::boolean, optional, default=0</code>: Do not select CUDNN operator, if available</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1559' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.BatchNorm_v1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.BatchNorm_v1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.BatchNorm_v1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>BatchNorm_v1(data, gamma, beta, eps, momentum, fix_gamma, use_global_stats, output_mean_var)
</code></pre>

<p>Batch normalization.</p>
<p>Normalizes a data batch by mean and variance, and applies a scale $gamma$ as well as offset $beta$.</p>
<p>Assume the input has more than one dimension and we normalize along axis 1. We first compute the mean and variance along this axis:</p>
<p>.. math::</p>
<p>data_mean[i] = mean(data[:,i,:,...]) \
  data_var[i] = var(data[:,i,:,...])</p>
<p>Then compute the normalized output, which has the same shape as input, as following:</p>
<p>.. math::</p>
<p>out[:,i,:,...] = \frac{data[:,i,:,...] - data_mean[i]}{\sqrt{data_var[i]+\epsilon}} * gamma[i] + beta[i]</p>
<p>Both <em>mean</em> and <em>var</em> returns a scalar by treating the input as a vector.</p>
<p>Assume the input has size <em>k</em> on axis 1, then both $gamma$ and $beta$ have shape <em>(k,)</em>. If $output_mean_var$ is set to be true, then outputs both $data_mean$ and $data_var$ as well, which are needed for the backward pass.</p>
<p>Besides the inputs and the outputs, this operator accepts two auxiliary states, $moving_mean$ and $moving_var$, which are <em>k</em>-length vectors. They are global statistics for the whole dataset, which are updated by::</p>
<p>moving_mean = moving_mean * momentum + data_mean * (1 - momentum)   moving_var = moving_var * momentum + data_var * (1 - momentum)</p>
<p>If $use_global_stats$ is set to be true, then $moving_mean$ and $moving_var$ are used instead of $data_mean$ and $data_var$ to compute the output. It is often used during inference.</p>
<p>Both $gamma$ and $beta$ are learnable parameters. But if $fix_gamma$ is true, then set $gamma$ to 1 and its gradient to 0.</p>
<p>Defined in src/operator/batch_norm_v1.cc:L90</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to batch normalization</li>
<li><code>gamma::NDArray-or-SymbolicNode</code>: gamma array</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: beta array</li>
<li><code>eps::float, optional, default=0.001</code>: Epsilon to prevent div 0</li>
<li><code>momentum::float, optional, default=0.9</code>: Momentum for moving average</li>
<li><code>fix_gamma::boolean, optional, default=1</code>: Fix gamma while training</li>
<li><code>use_global_stats::boolean, optional, default=0</code>: Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</li>
<li><code>output_mean_var::boolean, optional, default=0</code>: Output All,normal mean and var</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1547' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.BilinearSampler-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.BilinearSampler-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.BilinearSampler</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>BilinearSampler(data, grid)
</code></pre>

<p>Applies bilinear sampling to input feature map.</p>
<p>Bilinear Sampling is the key of  [NIPS2015] \"Spatial Transformer Networks\". The usage of the operator is very similar to remap function in OpenCV, except that the operator has the backward pass.</p>
<p>Given :math:<code>data</code> and :math:<code>grid</code>, then the output is computed by</p>
<p>.. math::   x_{src} = grid[batch, 0, y_{dst}, x_{dst}] \
  y_{src} = grid[batch, 1, y_{dst}, x_{dst}] \
  output[batch, channel, y_{dst}, x_{dst}] = G(data[batch, channel, y_{src}, x_{src})</p>
<p>:math:<code>x_{dst}</code>, :math:<code>y_{dst}</code> enumerate all spatial locations in :math:<code>output</code>, and :math:<code>G()</code> denotes the bilinear interpolation kernel. The out-boundary points will be padded with zeros.The shape of the output will be (data.shape[0], data.shape[1], grid.shape[2], grid.shape[3]).</p>
<p>The operator assumes that :math:<code>data</code> has 'NCHW' layout and :math:<code>grid</code> has been normalized to [-1, 1].</p>
<p>BilinearSampler often cooperates with GridGenerator which generates sampling grids for BilinearSampler. GridGenerator supports two kinds of transformation: $affine$ and $warp$. If users want to design a CustomOp to manipulate :math:<code>grid</code>, please firstly refer to the code of GridGenerator.</p>
<p>Example 1::</p>
<p><strong>Zoom out data two times</strong></p>
<p>data = array([[[[1, 4, 3, 6],                   [1, 8, 8, 9],                   [0, 4, 1, 5],                   [1, 0, 1, 3]]]])</p>
<p>affine_matrix = array([[2, 0, 0],                          [0, 2, 0]])</p>
<p>affine_matrix = reshape(affine_matrix, shape=(1, 6))</p>
<p>grid = GridGenerator(data=affine_matrix, transform_type='affine', target_shape=(4, 4))</p>
<p>out = BilinearSampler(data, grid)</p>
<p>out   [[[[ 0,   0,     0,   0],      [ 0,   3.5,   6.5, 0],      [ 0,   1.25,  2.5, 0],      [ 0,   0,     0,   0]]]</p>
<p>Example 2::</p>
<p><strong>shift data horizontally by -1 pixel</strong></p>
<p>data = array([[[[1, 4, 3, 6],                   [1, 8, 8, 9],                   [0, 4, 1, 5],                   [1, 0, 1, 3]]]])</p>
<p>warp_maxtrix = array([[[[1, 1, 1, 1],                           [1, 1, 1, 1],                           [1, 1, 1, 1],                           [1, 1, 1, 1]],                          [[0, 0, 0, 0],                           [0, 0, 0, 0],                           [0, 0, 0, 0],                           [0, 0, 0, 0]]]])</p>
<p>grid = GridGenerator(data=warp_matrix, transform_type='warp')   out = BilinearSampler(data, grid)</p>
<p>out   [[[[ 4,  3,  6,  0],      [ 8,  8,  9,  0],      [ 4,  1,  5,  0],      [ 0,  1,  3,  0]]]</p>
<p>Defined in src/operator/bilinear_sampler.cc:L245</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the BilinearsamplerOp.</li>
<li><code>grid::NDArray-or-SymbolicNode</code>: Input grid to the BilinearsamplerOp.grid has two channels: x_src, y_src</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1566' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.BlockGrad-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.BlockGrad-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.BlockGrad</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>BlockGrad(data)
</code></pre>

<p>Stops gradient computation.</p>
<p>Stops the accumulated gradient of the inputs from flowing through this operator in the backward direction. In other words, this operator prevents the contribution of its inputs to be taken into account for computing gradients.</p>
<p>Example::</p>
<p>v1 = [1, 2]   v2 = [0, 1]   a = Variable('a')   b = Variable('b')   b_stop_grad = stop_gradient(3 * b)   loss = MakeLoss(b_stop_grad + a)</p>
<p>executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))   executor.forward(is_train=True, a=v1, b=v2)   executor.outputs   [ 1.  5.]</p>
<p>executor.backward()   executor.grad_arrays   [ 0.  0.]   [ 1.  1.]</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L167</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1518' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Cast-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.Cast-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.Cast</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Cast(data, dtype)
</code></pre>

<p>Casts all elements of the input to a new type.</p>
<p>.. note:: $Cast$ is deprecated. Use $cast$ instead.</p>
<p>Example::</p>
<p>cast([0.9, 1.3], dtype='int32') = [0, 1]    cast([1e20, 11.1], dtype='float16') = [inf, 11.09375]    cast([300, 11.1, 10.9, -1, -3], dtype='uint8') = [44, 11, 10, 255, 253]</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L311</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>dtype::{'float16', 'float32', 'float64', 'int32', 'uint8'}, required</code>: Output data type.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1505' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Concat-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.Concat-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.Concat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Concat(data, num_args, dim)
</code></pre>

<p><strong>Note</strong>: Concat takes variable number of positional inputs. So instead of calling as Concat([x, y, z], num_args=3), one should call via Concat(x, y, z), and num_args will be determined automatically.</p>
<p>Joins input arrays along a given axis.</p>
<p>.. note:: <code>Concat</code> is deprecated. Use <code>concat</code> instead.</p>
<p>The dimensions of the input arrays should be the same except the axis along which they will be concatenated. The dimension of the output array along the concatenated axis will be equal to the sum of the corresponding dimensions of the input arrays.</p>
<p>Example::</p>
<p>x = [[1,1],[2,2]]    y = [[3,3],[4,4],[5,5]]    z = [[6,6], [7,7],[8,8]]</p>
<p>concat(x,y,z,dim=0) = [[ 1.,  1.],                           [ 2.,  2.],                           [ 3.,  3.],                           [ 4.,  4.],                           [ 5.,  5.],                           [ 6.,  6.],                           [ 7.,  7.],                           [ 8.,  8.]]</p>
<p>Note that you cannot concat x,y,z along dimension 1 since dimension    0 is not the same for all the input arrays.</p>
<p>concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],                          [ 4.,  4.,  7.,  7.],                          [ 5.,  5.,  8.,  8.]]</p>
<p>Defined in src/operator/concat.cc:L104</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: List of arrays to concatenate</li>
<li><code>num_args::int, required</code>: Number of inputs to be concated.</li>
<li><code>dim::int, optional, default='1'</code>: the dimension to be concated.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1530' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Convolution-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.Convolution-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.Convolution</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Convolution(data, weight, bias, kernel, stride, dilate, pad, num_filter, num_group, workspace, no_bias, cudnn_tune, cudnn_off, layout)
</code></pre>

<p>Compute <em>N</em>-D convolution on <em>(N+2)</em>-D input.</p>
<p>In the 2-D convolution, given input data with shape <em>(batch_size, channel, height, width)</em>, the output is computed by</p>
<p>.. math::</p>
<p>out[n,i,:,:] = bias[i] + \sum_{j=0}^{channel} data[n,j,:,:] \star    weight[i,j,:,:]</p>
<p>where :math:<code>\star</code> is the 2-D cross-correlation operator.</p>
<p>For general 2-D convolution, the shapes are</p>
<ul>
<li><strong>data</strong>: <em>(batch_size, channel, height, width)</em></li>
<li><strong>weight</strong>: <em>(num_filter, channel, kernel[0], kernel[1])</em></li>
<li><strong>bias</strong>: <em>(num_filter,)</em></li>
<li><strong>out</strong>: <em>(batch_size, num_filter, out_height, out_width)</em>.</li>
</ul>
<p>Define::</p>
<p>f(x,k,p,s,d) = floor((x+2<em>p-d</em>(k-1)-1)/s)+1</p>
<p>then we have::</p>
<p>out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])</p>
<p>If $no_bias$ is set to be true, then the $bias$ term is ignored.</p>
<p>The default data $layout$ is <em>NCHW</em>, namely <em>(batch_size, channel, height, width)</em>. We can choose other layouts such as <em>NHWC</em>.</p>
<p>If $num_group$ is larger than 1, denoted by <em>g</em>, then split the input $data$ evenly into <em>g</em> parts along the channel axis, and also evenly split $weight$ along the first dimension. Next compute the convolution on the <em>i</em>-th part of the data with the <em>i</em>-th weight part. The output is obtained by concatenating all the <em>g</em> results.</p>
<p>1-D convolution does not have <em>height</em> dimension but only <em>width</em> in space.</p>
<ul>
<li><strong>data</strong>: <em>(batch_size, channel, width)</em></li>
<li><strong>weight</strong>: <em>(num_filter, channel, kernel[0])</em></li>
<li><strong>bias</strong>: <em>(num_filter,)</em></li>
<li><strong>out</strong>: <em>(batch_size, num_filter, out_width)</em>.</li>
</ul>
<p>3-D convolution adds an additional <em>depth</em> dimension besides <em>height</em> and <em>width</em>. The shapes are</p>
<ul>
<li><strong>data</strong>: <em>(batch_size, channel, depth, height, width)</em></li>
<li><strong>weight</strong>: <em>(num_filter, channel, kernel[0], kernel[1], kernel[2])</em></li>
<li><strong>bias</strong>: <em>(num_filter,)</em></li>
<li><strong>out</strong>: <em>(batch_size, num_filter, out_depth, out_height, out_width)</em>.</li>
</ul>
<p>Both $weight$ and $bias$ are learnable parameters.</p>
<p>There are other options to tune the performance.</p>
<ul>
<li>
<p><strong>cudnn_tune</strong>: enable this option leads to higher startup time but may give faster speed. Options are</p>
<ul>
<li><strong>off</strong>: no tuning</li>
<li><strong>limited_workspace</strong>:run test and pick the fastest algorithm that doesn't exceed workspace limit.</li>
<li><strong>fastest</strong>: pick the fastest algorithm and ignore workspace limit.</li>
<li><strong>None</strong> (default): the behavior is determined by environment variable $MXNET_CUDNN_AUTOTUNE_DEFAULT$. 0 for off, 1 for limited workspace (default), 2 for fastest.</li>
<li><strong>workspace</strong>: A large number leads to more (GPU) memory usage but may improve the performance.</li>
</ul>
</li>
</ul>
<p>Defined in src/operator/nn/convolution.cc:L170</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the ConvolutionOp.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight matrix.</li>
<li><code>bias::NDArray-or-SymbolicNode</code>: Bias parameter.</li>
<li><code>kernel::Shape(tuple), required</code>: Convolution kernel size: (h, w) or (d, h, w)</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: Convolution stride: (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>dilate::Shape(tuple), optional, default=[]</code>: Convolution dilate: (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: Zero pad for convolution: (h, w) or (d, h, w). Defaults to no padding.</li>
<li><code>num_filter::int (non-negative), required</code>: Convolution filter(channel) number</li>
<li><code>num_group::int (non-negative), optional, default=1</code>: Number of group partitions.</li>
<li><code>workspace::long (non-negative), optional, default=1024</code>: Maximum temporary workspace allowed for convolution (MB).</li>
<li><code>no_bias::boolean, optional, default=0</code>: Whether to disable bias parameter.</li>
<li><code>cudnn_tune::{None, 'fastest', 'limited_workspace', 'off'},optional, default='None'</code>: Whether to pick convolution algo by running performance test.</li>
<li><code>cudnn_off::boolean, optional, default=0</code>: Turn off cudnn for this layer.</li>
<li><code>layout::{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC'},optional, default='None'</code>: Set layout for input, output and weight. Empty for   default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1592' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Convolution_v1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.Convolution_v1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.Convolution_v1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Convolution_v1(data, weight, bias, kernel, stride, dilate, pad, num_filter, num_group, workspace, no_bias, cudnn_tune, cudnn_off, layout)
</code></pre>

<p>This operator is DEPRECATED. Apply convolution to input then add a bias.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the ConvolutionV1Op.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight matrix.</li>
<li><code>bias::NDArray-or-SymbolicNode</code>: Bias parameter.</li>
<li><code>kernel::Shape(tuple), required</code>: convolution kernel size: (h, w) or (d, h, w)</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: convolution stride: (h, w) or (d, h, w)</li>
<li><code>dilate::Shape(tuple), optional, default=[]</code>: convolution dilate: (h, w) or (d, h, w)</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: pad for convolution: (h, w) or (d, h, w)</li>
<li><code>num_filter::int (non-negative), required</code>: convolution filter(channel) number</li>
<li><code>num_group::int (non-negative), optional, default=1</code>: Number of group partitions. Equivalent to slicing input into num_group   partitions, apply convolution on each, then concatenate the results</li>
<li><code>workspace::long (non-negative), optional, default=1024</code>: Maximum tmp workspace allowed for convolution (MB).</li>
<li><code>no_bias::boolean, optional, default=0</code>: Whether to disable bias parameter.</li>
<li><code>cudnn_tune::{None, 'fastest', 'limited_workspace', 'off'},optional, default='None'</code>: Whether to pick convolution algo by running performance test.   Leads to higher startup time but may give faster speed. Options are:   'off': no tuning   'limited_workspace': run test and pick the fastest algorithm that doesn't exceed workspace limit.   'fastest': pick the fastest algorithm and ignore workspace limit.   If set to None (default), behavior is determined by environment   variable MXNET_CUDNN_AUTOTUNE_DEFAULT: 0 for off,   1 for limited workspace (default), 2 for fastest.</li>
<li><code>cudnn_off::boolean, optional, default=0</code>: Turn off cudnn for this layer.</li>
<li><code>layout::{None, 'NCDHW', 'NCHW', 'NDHWC', 'NHWC'},optional, default='None'</code>: Set layout for input, output and weight. Empty for   default layout: NCHW for 2d and NCDHW for 3d.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1526' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Correlation-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.Correlation-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.Correlation</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Correlation(data1, data2, kernel_size, max_displacement, stride1, stride2, pad_size, is_multiply)
</code></pre>

<p>Applies correlation to inputs.</p>
<p>The correlation layer performs multiplicative patch comparisons between two feature maps.</p>
<p>Given two multi-channel feature maps :math:<code>f_{1}, f_{2}</code>, with :math:<code>w</code>, :math:<code>h</code>, and :math:<code>c</code> being their width, height, and number of channels, the correlation layer lets the network compare each patch from :math:<code>f_{1}</code> with each patch from :math:<code>f_{2}</code>.</p>
<p>For now we consider only a single comparison of two patches. The 'correlation' of two patches centered at :math:<code>x_{1}</code> in the first map and :math:<code>x_{2}</code> in the second map is then defined as:</p>
<p>.. math::    c(x_{1}, x_{2}) = \sum_{o \in [-k,k] \times [-k,k]} <f_{1}(x_{1} + o), f_{2}(x_{2} + o)></p>
<p>for a square patch of size :math:<code>K:=2k+1</code>.</p>
<p>Note that the equation above is identical to one step of a convolution in neural networks, but instead of convolving data with a filter, it convolves data with other data. For this reason, it has no training weights.</p>
<p>Computing :math:<code>c(x_{1}, x_{2})</code> involves :math:<code>c * K^{2}</code> multiplications. Comparing all patch combinations involves :math:<code>w^{2}*h^{2}</code> such computations.</p>
<p>Given a maximum displacement :math:<code>d</code>, for each location :math:<code>x_{1}</code> it computes correlations :math:<code>c(x_{1}, x_{2})</code> only in a neighborhood of size :math:<code>D:=2d+1</code>, by limiting the range of :math:<code>x_{2}</code>. We use strides :math:<code>s_{1}, s_{2}</code>, to quantize :math:<code>x_{1}</code> globally and to quantize :math:<code>x_{2}</code> within the neighborhood centered around :math:<code>x_{1}</code>.</p>
<p>The final output is defined by the following expression:</p>
<p>.. math::   out[n, q, i, j] = c(x_{i, j}, x_{q})</p>
<p>where :math:<code>i</code> and :math:<code>j</code> enumerate spatial locations in :math:<code>f_{1}</code>, and :math:<code>q</code> denotes the :math:<code>q^{th}</code> neighborhood of :math:<code>x_{i,j}</code>.</p>
<p>Defined in src/operator/correlation.cc:L192</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data1::NDArray-or-SymbolicNode</code>: Input data1 to the correlation.</li>
<li><code>data2::NDArray-or-SymbolicNode</code>: Input data2 to the correlation.</li>
<li><code>kernel_size::int (non-negative), optional, default=1</code>: kernel size for Correlation must be an odd number</li>
<li><code>max_displacement::int (non-negative), optional, default=1</code>: Max displacement of Correlation</li>
<li><code>stride1::int (non-negative), optional, default=1</code>: stride1 quantize data1 globally</li>
<li><code>stride2::int (non-negative), optional, default=1</code>: stride2 quantize data2 within the neighborhood centered around data1</li>
<li><code>pad_size::int (non-negative), optional, default=0</code>: pad for Correlation</li>
<li><code>is_multiply::boolean, optional, default=1</code>: operation type is either multiplication or subduction</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1537' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Crop-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.Crop-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.Crop</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Crop(data, num_args, offset, h_w, center_crop)
</code></pre>

<p><strong>Note</strong>: Crop takes variable number of positional inputs. So instead of calling as Crop([x, y, z], num_args=3), one should call via Crop(x, y, z), and num_args will be determined automatically.</p>
<p>.. note:: <code>Crop</code> is deprecated. Use <code>slice</code> instead.</p>
<p>Crop the 2nd and 3rd dim of input data, with the corresponding size of h_w or with width and height of the second input symbol, i.e., with one input, we need h_w to specify the crop height and width, otherwise the second input symbol's size will be used</p>
<p>Defined in src/operator/crop.cc:L50</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::SymbolicNode or SymbolicNode[]</code>: Tensor or List of Tensors, the second input will be used as crop_like shape reference</li>
<li><code>num_args::int, required</code>: Number of inputs for crop, if equals one, then we will use the h_wfor crop height and width, else if equals two, then we will use the heightand width of the second input symbol, we name crop_like here</li>
<li><code>offset::Shape(tuple), optional, default=[0,0]</code>: crop offset coordinate: (y, x)</li>
<li><code>h_w::Shape(tuple), optional, default=[0,0]</code>: crop height and width: (h, w)</li>
<li><code>center_crop::boolean, optional, default=0</code>: If set to true, then it will use be the center_crop,or it will crop using the shape of crop_like</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1510' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Custom-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.Custom-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.Custom</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Custom(data, op_type)
</code></pre>

<p>Apply a custom operator implemented in a frontend language (like Python).</p>
<p>Custom operators should override required methods like <code>forward</code> and <code>backward</code>. The custom operator must be registered before it can be used. Please check the tutorial here: http://mxnet.io/how_to/new_op.html.</p>
<p>Defined in src/operator/custom/custom.cc:L378</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Input data for the custom operator.</li>
<li><code>op_type::string</code>: Name of the custom operator. This is the name that is passed to <code>mx.operator.register</code> to register the operator.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1501' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Deconvolution-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.Deconvolution-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.Deconvolution</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Deconvolution(data, weight, bias, kernel, stride, dilate, pad, adj, target_shape, num_filter, num_group, workspace, no_bias, cudnn_tune, cudnn_off, layout)
</code></pre>

<p>Computes 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input tensor to the deconvolution operation.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weights representing the kernel.</li>
<li><code>bias::NDArray-or-SymbolicNode</code>: Bias added to the result after the deconvolution operation.</li>
<li><code>kernel::Shape(tuple), required</code>: Deconvolution kernel size: (h, w) or (d, h, w). This is same as the kernel size used for the corresponding convolution</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: The stride used for the corresponding convolution: (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>dilate::Shape(tuple), optional, default=[]</code>: Dilation factor for each dimension of the input: (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: The amount of implicit zero padding added during convolution for each dimension of the input: (h, w) or (d, h, w). $(kernel-1)/2$ is usually a good choice. If <code>target_shape</code> is set, <code>pad</code> will be ignored and a padding that will generate the target shape will be used. Defaults to no padding.</li>
<li><code>adj::Shape(tuple), optional, default=[]</code>: Adjustment for output shape: (h, w) or (d, h, w). If <code>target_shape</code> is set, <code>adj</code> will be ignored and computed accordingly.</li>
<li><code>target_shape::Shape(tuple), optional, default=[]</code>: Shape of the output tensor: (h, w) or (d, h, w).</li>
<li><code>num_filter::int (non-negative), required</code>: Number of output filters.</li>
<li><code>num_group::int (non-negative), optional, default=1</code>: Number of groups partition.</li>
<li><code>workspace::long (non-negative), optional, default=512</code>: Maximum temporal workspace allowed for deconvolution (MB).</li>
<li><code>no_bias::boolean, optional, default=1</code>: Whether to disable bias parameter.</li>
<li><code>cudnn_tune::{None, 'fastest', 'limited_workspace', 'off'},optional, default='None'</code>: Whether to pick convolution algorithm by running performance test.</li>
<li><code>cudnn_off::boolean, optional, default=0</code>: Turn off cudnn for this layer.</li>
<li><code>layout::{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC'},optional, default='None'</code>: Set layout for input, output and weight. Empty for default layout, NCW for 1d, NCHW for 2d and NCDHW for 3d.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1521' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Dropout-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.Dropout-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.Dropout</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Dropout(data, p, mode)
</code></pre>

<p>Applies dropout operation to input array.</p>
<ul>
<li>During training, each element of the input is set to zero with probability p. The whole array is rescaled by :math:<code>1/(1-p)</code> to keep the expected sum of the input unchanged.</li>
<li>During testing, this operator does not change the input if mode is 'training'. If mode is 'always', the same computaion as during training will be applied.</li>
</ul>
<p>Example::</p>
<p>random.seed(998)   input_array = array([[3., 0.5,  -0.5,  2., 7.],                       [2., -0.4,   7.,  3., 0.2]])   a = symbol.Variable('a')   dropout = symbol.Dropout(a, p = 0.2)   executor = dropout.simple_bind(a = input_array.shape)</p>
<p><strong>If training</strong></p>
<p>executor.forward(is_train = True, a = input_array)   executor.outputs   [[ 3.75   0.625 -0.     2.5    8.75 ]    [ 2.5   -0.5    8.75   3.75   0.   ]]</p>
<p><strong>If testing</strong></p>
<p>executor.forward(is_train = False, a = input_array)   executor.outputs   [[ 3.     0.5   -0.5    2.     7.   ]    [ 2.    -0.4    7.     3.     0.2  ]]</p>
<p>Defined in src/operator/nn/dropout.cc:L78</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array to which dropout will be applied.</li>
<li><code>p::float, optional, default=0.5</code>: Fraction of the input that gets dropped out during training time.</li>
<li><code>mode::{'always', 'training'},optional, default='training'</code>: Whether to only turn on dropout during training or to also turn on for inference.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1526' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ElementWiseSum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.ElementWiseSum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.ElementWiseSum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ElementWiseSum(args)
</code></pre>

<p>ElementWiseSum is an alias of add_n.</p>
<p><strong>Note</strong>: ElementWiseSum takes variable number of positional inputs. So instead of calling as ElementWiseSum([x, y, z], num_args=3), one should call via ElementWiseSum(x, y, z), and num_args will be determined automatically.</p>
<p>Adds all input arguments element-wise.</p>
<p>.. math::    add_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n</p>
<p>$add_n$ is potentially more efficient than calling $add$ by <code>n</code> times.</p>
<p>The storage type of $add_n$ output depends on storage types of inputs</p>
<ul>
<li>add_n(row_sparse, row_sparse, ..) = row_sparse</li>
<li>otherwise, $add_n$ generates output with default storage</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_sum.cc:L123</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>args::NDArray-or-SymbolicNode[]</code>: Positional input arguments</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1509' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Embedding-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.Embedding-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.Embedding</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Embedding(data, weight, input_dim, output_dim, dtype)
</code></pre>

<p>Maps integer indices to vector representations (embeddings).</p>
<p>This operator maps words to real-valued vectors in a high-dimensional space, called word embeddings. These embeddings can capture semantic and syntactic properties of the words. For example, it has been noted that in the learned embedding spaces, similar words tend to be close to each other and dissimilar words far apart.</p>
<p>For an input array of shape (d1, ..., dK), the shape of an output array is (d1, ..., dK, output_dim). All the input values should be integers in the range [0, input_dim).</p>
<p>If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be (ip0, op0).</p>
<p>By default, if any index mentioned is too large, it is replaced by the index that addresses the last vector in an embedding matrix.</p>
<p>Examples::</p>
<p>input_dim = 4   output_dim = 5</p>
<p>// Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)   y = [[  0.,   1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.,   9.],        [ 10.,  11.,  12.,  13.,  14.],        [ 15.,  16.,  17.,  18.,  19.]]</p>
<p>// Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]   x = [[ 1.,  3.],        [ 0.,  2.]]</p>
<p>// Mapped input x to its vector representation y.   Embedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],                             [ 15.,  16.,  17.,  18.,  19.]],</p>
<pre><code>                       [[  0.,   1.,   2.,   3.,   4.],
                        [ 10.,  11.,  12.,  13.,  14.]]]
</code></pre>

<p>Defined in src/operator/tensor/indexing_op.cc:L185</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array to the embedding operator.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: The embedding weight matrix.</li>
<li><code>input_dim::int, required</code>: Vocabulary size of the input indices.</li>
<li><code>output_dim::int, required</code>: Dimension of the embedding vectors.</li>
<li><code>dtype::{'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='float32'</code>: Data type of weight.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1540' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.FullyConnected-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.FullyConnected-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.FullyConnected</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>FullyConnected(data, weight, bias, num_hidden, no_bias, flatten)
</code></pre>

<p>Applies a linear transformation: :math:<code>Y = XW^T + b</code>.</p>
<p>If $flatten$ is set to be true, then the shapes are:</p>
<ul>
<li><strong>data</strong>: <code>(batch_size, x1, x2, ..., xn)</code></li>
<li><strong>weight</strong>: <code>(num_hidden, x1 * x2 * ... * xn)</code></li>
<li><strong>bias</strong>: <code>(num_hidden,)</code></li>
<li><strong>out</strong>: <code>(batch_size, num_hidden)</code></li>
</ul>
<p>If $flatten$ is set to be false, then the shapes are:</p>
<ul>
<li><strong>data</strong>: <code>(x1, x2, ..., xn, input_dim)</code></li>
<li><strong>weight</strong>: <code>(num_hidden, input_dim)</code></li>
<li><strong>bias</strong>: <code>(num_hidden,)</code></li>
<li><strong>out</strong>: <code>(x1, x2, ..., xn, num_hidden)</code></li>
</ul>
<p>The learnable parameters include both $weight$ and $bias$.</p>
<p>If $no_bias$ is set to be true, then the $bias$ term is ignored.</p>
<p>Defined in src/operator/nn/fully_connected.cc:L98</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight matrix.</li>
<li><code>bias::NDArray-or-SymbolicNode</code>: Bias parameter.</li>
<li><code>num_hidden::int, required</code>: Number of hidden nodes of the output.</li>
<li><code>no_bias::boolean, optional, default=0</code>: Whether to disable bias parameter.</li>
<li><code>flatten::boolean, optional, default=1</code>: Whether to collapse all but the first axis of the input data tensor.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1523' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.GridGenerator-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.GridGenerator-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.GridGenerator</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>GridGenerator(data, transform_type, target_shape)
</code></pre>

<p>Generates 2D sampling grid for bilinear sampling.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the function.</li>
<li><code>transform_type::{'affine', 'warp'}, required</code>: The type of transformation. For <code>affine</code>, input data should be an affine matrix of size (batch, 6). For <code>warp</code>, input data should be an optical flow of size (batch, 2, h, w).</li>
<li><code>target_shape::Shape(tuple), optional, default=[0,0]</code>: Specifies the output shape (H, W). This is required if transformation type is <code>affine</code>. If transformation type is <code>warp</code>, this parameter is ignored.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.IdentityAttachKLSparseReg-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.IdentityAttachKLSparseReg-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.IdentityAttachKLSparseReg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>IdentityAttachKLSparseReg(data, sparseness_target, penalty, momentum)
</code></pre>

<p>Apply a sparse regularization to the output a sigmoid activation function.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data.</li>
<li><code>sparseness_target::float, optional, default=0.1</code>: The sparseness target</li>
<li><code>penalty::float, optional, default=0.001</code>: The tradeoff parameter for the sparseness penalty</li>
<li><code>momentum::float, optional, default=0.9</code>: The momentum for running average</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1497' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.InstanceNorm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.InstanceNorm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.InstanceNorm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>InstanceNorm(data, gamma, beta, eps)
</code></pre>

<p>Applies instance normalization to the n-dimensional input array.</p>
<p>This operator takes an n-dimensional input array where (n&gt;2) and normalizes the input using the following formula:</p>
<p>.. math::</p>
<p>out = \frac{x - mean[data]}{ \sqrt{Var[data]} + \epsilon} * gamma + beta</p>
<p>This layer is similar to batch normalization layer (<code>BatchNorm</code>) with two differences: first, the normalization is carried out per example (instance), not over a batch. Second, the same normalization is applied both at test and train time. This operation is also known as <code>contrast normalization</code>.</p>
<p>If the input data is of shape [batch, channel, spacial_dim1, spacial_dim2, ...], <code>gamma</code> and <code>beta</code> parameters must be vectors of shape [channel].</p>
<p>This implementation is based on paper:</p>
<p>.. [1] Instance Normalization: The Missing Ingredient for Fast Stylization,    D. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).</p>
<p>Examples::</p>
<p>// Input of shape (2,1,2)   x = [[[ 1.1,  2.2]],        [[ 3.3,  4.4]]]</p>
<p>// gamma parameter of length 1   gamma = [1.5]</p>
<p>// beta parameter of length 1   beta = [0.5]</p>
<p>// Instance normalization is calculated with the above formula   InstanceNorm(x,gamma,beta) = [[[-0.997527  ,  1.99752665]],                                 [[-0.99752653,  1.99752724]]]</p>
<p>Defined in src/operator/instance_norm.cc:L95</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: An n-dimensional input array (n &gt; 2) of the form [batch, channel, spatial_dim1, spatial_dim2, ...].</li>
<li><code>gamma::NDArray-or-SymbolicNode</code>: A vector of length 'channel', which multiplies the normalized input.</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: A vector of length 'channel', which is added to the product of the normalized input and the weight.</li>
<li><code>eps::float, optional, default=0.001</code>: An <code>epsilon</code> parameter to prevent division by 0.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1538' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.L2Normalization-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.L2Normalization-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.L2Normalization</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>L2Normalization(data, eps, mode)
</code></pre>

<p>Normalize the input array using the L2 norm.</p>
<p>For 1-D NDArray, it computes::</p>
<p>out = data / sqrt(sum(data ** 2) + eps)</p>
<p>For N-D NDArray, if the input array has shape (N, N, ..., N),</p>
<p>with $mode$ = $instance$, it normalizes each instance in the multidimensional array by its L2 norm.::</p>
<p>for i in 0...N     out[i,:,:,...,:] = data[i,:,:,...,:] / sqrt(sum(data[i,:,:,...,:] ** 2) + eps)</p>
<p>with $mode$ = $channel$, it normalizes each channel in the array by its L2 norm.::</p>
<p>for i in 0...N     out[:,i,:,...,:] = data[:,i,:,...,:] / sqrt(sum(data[:,i,:,...,:] ** 2) + eps)</p>
<p>with $mode$ = $spatial$, it normalizes the cross channel norm for each position in the array by its L2 norm.::</p>
<p>for dim in 2...N     for i in 0...N       out[.....,i,...] = take(out, indices=i, axis=dim) / sqrt(sum(take(out, indices=i, axis=dim) ** 2) + eps)           -dim-</p>
<p>Example::</p>
<p>x = [[[1,2],         [3,4]],        [[2,2],         [5,6]]]</p>
<p>L2Normalization(x, mode='instance')   =[[[ 0.18257418  0.36514837]      [ 0.54772252  0.73029673]]     [[ 0.24077171  0.24077171]      [ 0.60192931  0.72231513]]]</p>
<p>L2Normalization(x, mode='channel')   =[[[ 0.31622776  0.44721359]      [ 0.94868326  0.89442718]]     [[ 0.37139067  0.31622776]      [ 0.92847669  0.94868326]]]</p>
<p>L2Normalization(x, mode='spatial')   =[[[ 0.44721359  0.89442718]      [ 0.60000002  0.80000001]]     [[ 0.70710677  0.70710677]      [ 0.6401844   0.76822126]]]</p>
<p>Defined in src/operator/l2_normalization.cc:L93</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array to normalize.</li>
<li><code>eps::float, optional, default=1e-10</code>: A small constant for numerical stability.</li>
<li><code>mode::{'channel', 'instance', 'spatial'},optional, default='instance'</code>: Specify the dimension along which to compute L2 norm.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1549' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.LRN-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.LRN-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.LRN</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>LRN(data, alpha, beta, knorm, nsize)
</code></pre>

<p>Applies local response normalization to the input.</p>
<p>The local response normalization layer performs "lateral inhibition" by normalizing over local input regions.</p>
<p>If :math:<code>a_{x,y}^{i}</code> is the activity of a neuron computed by applying kernel :math:<code>i</code> at position :math:<code>(x, y)</code> and then applying the ReLU nonlinearity, the response-normalized activity :math:<code>b_{x,y}^{i}</code> is given by the expression:</p>
<p>.. math::    b_{x,y}^{i} = \frac{a_{x,y}^{i}}{\Bigg({k + \alpha \sum_{j=max(0, i-\frac{n}{2})}^{min(N-1, i+\frac{n}{2})} (a_{x,y}^{j})^{2}}\Bigg)^{\beta}}</p>
<p>where the sum runs over :math:<code>n</code> "adjacent" kernel maps at the same spatial position, and :math:<code>N</code> is the total number of kernels in the layer.</p>
<p>Defined in src/operator/lrn.cc:L73</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data.</li>
<li><code>alpha::float, optional, default=0.0001</code>: The variance scaling parameter :math:<code>lpha</code> in the LRN expression.</li>
<li><code>beta::float, optional, default=0.75</code>: The power parameter :math:<code>eta</code> in the LRN expression.</li>
<li><code>knorm::float, optional, default=2</code>: The parameter :math:<code>k</code> in the LRN expression.</li>
<li><code>nsize::int (non-negative), required</code>: normalization window width in elements.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1516' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.LeakyReLU-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.LeakyReLU-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.LeakyReLU</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>LeakyReLU(data, act_type, slope, lower_bound, upper_bound)
</code></pre>

<p>Applies Leaky rectified linear unit activation element-wise to the input.</p>
<p>Leaky ReLUs attempt to fix the "dying ReLU" problem by allowing a small <code>slope</code> when the input is negative and has a slope of one when input is positive.</p>
<p>The following modified ReLU Activation functions are supported:</p>
<ul>
<li><em>elu</em>: Exponential Linear Unit. <code>y = x &gt; 0 ? x : slope * (exp(x)-1)</code></li>
<li><em>leaky</em>: Leaky ReLU. <code>y = x &gt; 0 ? x : slope * x</code></li>
<li><em>prelu</em>: Parametric ReLU. This is same as <em>leaky</em> except that <code>slope</code> is learnt during training.</li>
<li><em>rrelu</em>: Randomized ReLU. same as <em>leaky</em> but the <code>slope</code> is uniformly and randomly chosen from <em>[lower_bound, upper_bound)</em> for training, while fixed to be <em>(lower_bound+upper_bound)/2</em> for inference.</li>
</ul>
<p>Defined in src/operator/leaky_relu.cc:L58</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to activation function.</li>
<li><code>act_type::{'elu', 'leaky', 'prelu', 'rrelu'},optional, default='leaky'</code>: Activation function to be applied.</li>
<li><code>slope::float, optional, default=0.25</code>: Init slope for the activation. (For leaky and elu only)</li>
<li><code>lower_bound::float, optional, default=0.125</code>: Lower bound of random slope. (For rrelu only)</li>
<li><code>upper_bound::float, optional, default=0.334</code>: Upper bound of random slope. (For rrelu only)</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1515' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.LinearRegressionOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.LinearRegressionOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.LinearRegressionOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>LinearRegressionOutput(data, label, grad_scale)
</code></pre>

<p>Computes and optimizes for squared loss during backward propagation. Just outputs $data$ during forward propagation.</p>
<p>If :math:<code>\hat{y}_i</code> is the predicted value of the i-th sample, and :math:<code>y_i</code> is the corresponding target value, then the squared loss estimated over :math:<code>n</code> samples is defined as</p>
<p>:math:<code>\text{SquaredLoss}(y, \hat{y} ) = \frac{1}{n} \sum_{i=0}^{n-1} \left( y_i - \hat{y}_i \right)^2</code></p>
<p>.. note::    Use the LinearRegressionOutput as the final output layer of a net.</p>
<p>By default, gradients of this loss function are scaled by factor <code>1/n</code>, where n is the number of training examples. The parameter <code>grad_scale</code> can be used to change this scale to <code>grad_scale/n</code>.</p>
<p>Defined in src/operator/regression_output.cc:L70</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the function.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Input label to the function.</li>
<li><code>grad_scale::float, optional, default=1</code>: Scale the gradient by a float factor</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1511' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.LogisticRegressionOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.LogisticRegressionOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.LogisticRegressionOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>LogisticRegressionOutput(data, label, grad_scale)
</code></pre>

<p>Applies a logistic function to the input.</p>
<p>The logistic function, also known as the sigmoid function, is computed as :math:<code>\frac{1}{1+exp(-x)}</code>.</p>
<p>Commonly, the sigmoid is used to squash the real-valued output of a linear model :math:wTx+b into the [0,1] range so that it can be interpreted as a probability. It is suitable for binary classification or probability prediction tasks.</p>
<p>.. note::    Use the LogisticRegressionOutput as the final output layer of a net.</p>
<p>By default, gradients of this loss function are scaled by factor <code>1/n</code>, where n is the number of training examples. The parameter <code>grad_scale</code> can be used to change this scale to <code>grad_scale/n</code>.</p>
<p>Defined in src/operator/regression_output.cc:L112</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the function.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Input label to the function.</li>
<li><code>grad_scale::float, optional, default=1</code>: Scale the gradient by a float factor</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1512' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.MAERegressionOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.MAERegressionOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.MAERegressionOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>MAERegressionOutput(data, label, grad_scale)
</code></pre>

<p>Computes mean absolute error of the input.</p>
<p>MAE is a risk metric corresponding to the expected value of the absolute error.</p>
<p>If :math:<code>\hat{y}_i</code> is the predicted value of the i-th sample, and :math:<code>y_i</code> is the corresponding target value, then the mean absolute error (MAE) estimated over :math:<code>n</code> samples is defined as</p>
<p>:math:<code>\text{MAE}(y, \hat{y} ) = \frac{1}{n} \sum_{i=0}^{n-1} \left| y_i - \hat{y}_i \right|</code></p>
<p>.. note::    Use the MAERegressionOutput as the final output layer of a net.</p>
<p>By default, gradients of this loss function are scaled by factor <code>1/n</code>, where n is the number of training examples. The parameter <code>grad_scale</code> can be used to change this scale to <code>grad_scale/n</code>.</p>
<p>Defined in src/operator/regression_output.cc:L91</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the function.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Input label to the function.</li>
<li><code>grad_scale::float, optional, default=1</code>: Scale the gradient by a float factor</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1512' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.MakeLoss-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.MakeLoss-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.MakeLoss</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>MakeLoss(data, grad_scale, valid_thresh, normalization)
</code></pre>

<p>Make your own loss function in network construction.</p>
<p>This operator accepts a customized loss function symbol as a terminal loss and the symbol should be an operator with no backward dependency. The output of this function is the gradient of loss with respect to the input data.</p>
<p>For example, if you are a making a cross entropy loss function. Assume $out$ is the predicted output and $label$ is the true label, then the cross entropy can be defined as::</p>
<p>cross_entropy = label * log(out) + (1 - label) * log(1 - out)   loss = MakeLoss(cross_entropy)</p>
<p>We will need to use $MakeLoss$ when we are creating our own loss function or we want to combine multiple loss functions. Also we may want to stop some variables' gradients from backpropagation. See more detail in $BlockGrad$ or $stop_gradient$.</p>
<p>In addition, we can give a scale to the loss by setting $grad_scale$, so that the gradient of the loss will be rescaled in the backpropagation.</p>
<p>.. note:: This operator should be used as a Symbol instead of NDArray.</p>
<p>Defined in src/operator/make_loss.cc:L71</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
<li><code>grad_scale::float, optional, default=1</code>: Gradient scale as a supplement to unary and binary operators</li>
<li><code>valid_thresh::float, optional, default=0</code>: clip each element in the array to 0 when it is less than $valid_thresh$. This is used when $normalization$ is set to $'valid'$.</li>
<li><code>normalization::{'batch', 'null', 'valid'},optional, default='null'</code>: If this is set to null, the output gradient will not be normalized. If this is set to batch, the output gradient will be divided by the batch size. If this is set to valid, the output gradient will be divided by the number of valid input elements.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1520' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Pad-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.Pad-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.Pad</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Pad(data, mode, pad_width, constant_value)
</code></pre>

<p>Pads an input array with a constant or edge values of the array.</p>
<p>.. note:: <code>Pad</code> is deprecated. Use <code>pad</code> instead.</p>
<p>.. note:: Current implementation only supports 4D and 5D input arrays with padding applied    only on axes 1, 2 and 3. Expects axes 4 and 5 in <code>pad_width</code> to be zero.</p>
<p>This operation pads an input array with either a <code>constant_value</code> or edge values along each axis of the input array. The amount of padding is specified by <code>pad_width</code>.</p>
<p><code>pad_width</code> is a tuple of integer padding widths for each axis of the format $(before_1, after_1, ... , before_N, after_N)$. The <code>pad_width</code> should be of length $2*N$ where $N$ is the number of dimensions of the array.</p>
<p>For dimension $N$ of the input array, $before_N$ and $after_N$ indicates how many values to add before and after the elements of the array along dimension $N$. The widths of the higher two dimensions $before_1$, $after_1$, $before_2$, $after_2$ must be 0.</p>
<p>Example::</p>
<p>x = [[[[  1.   2.   3.]           [  4.   5.   6.]]</p>
<pre><code>     [[  7.   8.   9.]
      [ 10.  11.  12.]]]


    [[[ 11.  12.  13.]
      [ 14.  15.  16.]]

     [[ 17.  18.  19.]
      [ 20.  21.  22.]]]]
</code></pre>

<p>pad(x,mode="edge", pad_width=(0,0,0,0,1,1,1,1)) =</p>
<pre><code>     [[[[  1.   1.   2.   3.   3.]
        [  1.   1.   2.   3.   3.]
        [  4.   4.   5.   6.   6.]
        [  4.   4.   5.   6.   6.]]

       [[  7.   7.   8.   9.   9.]
        [  7.   7.   8.   9.   9.]
        [ 10.  10.  11.  12.  12.]
        [ 10.  10.  11.  12.  12.]]]


      [[[ 11.  11.  12.  13.  13.]
        [ 11.  11.  12.  13.  13.]
        [ 14.  14.  15.  16.  16.]
        [ 14.  14.  15.  16.  16.]]

       [[ 17.  17.  18.  19.  19.]
        [ 17.  17.  18.  19.  19.]
        [ 20.  20.  21.  22.  22.]
        [ 20.  20.  21.  22.  22.]]]]
</code></pre>

<p>pad(x, mode="constant", constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =</p>
<pre><code>     [[[[  0.   0.   0.   0.   0.]
        [  0.   1.   2.   3.   0.]
        [  0.   4.   5.   6.   0.]
        [  0.   0.   0.   0.   0.]]

       [[  0.   0.   0.   0.   0.]
        [  0.   7.   8.   9.   0.]
        [  0.  10.  11.  12.   0.]
        [  0.   0.   0.   0.   0.]]]


      [[[  0.   0.   0.   0.   0.]
        [  0.  11.  12.  13.   0.]
        [  0.  14.  15.  16.   0.]
        [  0.   0.   0.   0.   0.]]

       [[  0.   0.   0.   0.   0.]
        [  0.  17.  18.  19.   0.]
        [  0.  20.  21.  22.   0.]
        [  0.   0.   0.   0.   0.]]]]
</code></pre>

<p>Defined in src/operator/pad.cc:L766</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: An n-dimensional input array.</li>
<li><code>mode::{'constant', 'edge', 'reflect'}, required</code>: Padding type to use. "constant" pads with <code>constant_value</code> "edge" pads using the edge values of the input array "reflect" pads by reflecting values with respect to the edges.</li>
<li><code>pad_width::Shape(tuple), required</code>: Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format $(before_1, after_1, ... , before_N, after_N)$. It should be of length $2*N$ where $N$ is the number of dimensions of the array.This is equivalent to pad_width in numpy.pad, but flattened.</li>
<li><code>constant_value::double, optional, default=0</code>: The value used for padding when <code>mode</code> is "constant".</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1580' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Pooling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.Pooling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.Pooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Pooling(data, global_pool, cudnn_off, kernel, pool_type, pooling_convention, stride, pad)
</code></pre>

<p>Performs pooling on the input.</p>
<p>The shapes for 1-D pooling are</p>
<ul>
<li><strong>data</strong>: <em>(batch_size, channel, width)</em>,</li>
<li><strong>out</strong>: <em>(batch_size, num_filter, out_width)</em>.</li>
</ul>
<p>The shapes for 2-D pooling are</p>
<ul>
<li><strong>data</strong>: <em>(batch_size, channel, height, width)</em></li>
<li>
<p><strong>out</strong>: <em>(batch_size, num_filter, out_height, out_width)</em>, with::</p>
<p>out_height = f(height, kernel[0], pad[0], stride[0])   out_width = f(width, kernel[1], pad[1], stride[1])</p>
</li>
</ul>
<p>The definition of <em>f</em> depends on $pooling_convention$, which has two options:</p>
<ul>
<li>
<p><strong>valid</strong> (default)::</p>
<p>f(x, k, p, s) = floor((x+2*p-k)/s)+1
  * <strong>full</strong>, which is compatible with Caffe::</p>
<p>f(x, k, p, s) = ceil((x+2*p-k)/s)+1</p>
</li>
</ul>
<p>But $global_pool$ is set to be true, then do a global pooling, namely reset $kernel=(height, width)$.</p>
<p>Three pooling options are supported by $pool_type$:</p>
<ul>
<li><strong>avg</strong>: average pooling</li>
<li><strong>max</strong>: max pooling</li>
<li><strong>sum</strong>: sum pooling</li>
</ul>
<p>For 3-D pooling, an additional <em>depth</em> dimension is added before <em>height</em>. Namely the input data will have shape <em>(batch_size, channel, depth, height, width)</em>.</p>
<p>Defined in src/operator/nn/pooling.cc:L133</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the pooling operator.</li>
<li><code>global_pool::boolean, optional, default=0</code>: Ignore kernel size, do global pooling based on current input feature map.</li>
<li><code>cudnn_off::boolean, optional, default=0</code>: Turn off cudnn pooling and use MXNet pooling operator.</li>
<li><code>kernel::Shape(tuple), required</code>: Pooling kernel size: (y, x) or (d, y, x)</li>
<li><code>pool_type::{'avg', 'max', 'sum'}, required</code>: Pooling type to be applied.</li>
<li><code>pooling_convention::{'full', 'valid'},optional, default='valid'</code>: Pooling convention to be applied.</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1545' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.Pooling_v1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.Pooling_v1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.Pooling_v1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Pooling_v1(data, global_pool, kernel, pool_type, pooling_convention, stride, pad)
</code></pre>

<p>This operator is DEPRECATED. Perform pooling on the input.</p>
<p>The shapes for 2-D pooling is</p>
<ul>
<li><strong>data</strong>: <em>(batch_size, channel, height, width)</em></li>
<li>
<p><strong>out</strong>: <em>(batch_size, num_filter, out_height, out_width)</em>, with::</p>
<p>out_height = f(height, kernel[0], pad[0], stride[0])   out_width = f(width, kernel[1], pad[1], stride[1])</p>
</li>
</ul>
<p>The definition of <em>f</em> depends on $pooling_convention$, which has two options:</p>
<ul>
<li>
<p><strong>valid</strong> (default)::</p>
<p>f(x, k, p, s) = floor((x+2*p-k)/s)+1
  * <strong>full</strong>, which is compatible with Caffe::</p>
<p>f(x, k, p, s) = ceil((x+2*p-k)/s)+1</p>
</li>
</ul>
<p>But $global_pool$ is set to be true, then do a global pooling, namely reset $kernel=(height, width)$.</p>
<p>Three pooling options are supported by $pool_type$:</p>
<ul>
<li><strong>avg</strong>: average pooling</li>
<li><strong>max</strong>: max pooling</li>
<li><strong>sum</strong>: sum pooling</li>
</ul>
<p>1-D pooling is special case of 2-D pooling with <em>weight=1</em> and <em>kernel[1]=1</em>.</p>
<p>For 3-D pooling, an additional <em>depth</em> dimension is added before <em>height</em>. Namely the input data will have shape <em>(batch_size, channel, depth, height, width)</em>.</p>
<p>Defined in src/operator/pooling_v1.cc:L104</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the pooling operator.</li>
<li><code>global_pool::boolean, optional, default=0</code>: Ignore kernel size, do global pooling based on current input feature map.</li>
<li><code>kernel::Shape(tuple), required</code>: pooling kernel size: (y, x) or (d, y, x)</li>
<li><code>pool_type::{'avg', 'max', 'sum'}, required</code>: Pooling type to be applied.</li>
<li><code>pooling_convention::{'full', 'valid'},optional, default='valid'</code>: Pooling convention to be applied.</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: stride: for pooling (y, x) or (d, y, x)</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: pad for pooling: (y, x) or (d, y, x)</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1542' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.RNN-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.RNN-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.RNN</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>RNN(data, parameters, state, state_cell, state_size, num_layers, bidirectional, mode, p, state_outputs)
</code></pre>

<p>Applies a recurrent layer to input.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to RNN</li>
<li><code>parameters::NDArray-or-SymbolicNode</code>: Vector of all RNN trainable parameters concatenated</li>
<li><code>state::NDArray-or-SymbolicNode</code>: initial hidden state of the RNN</li>
<li><code>state_cell::NDArray-or-SymbolicNode</code>: initial cell state for LSTM networks (only for LSTM)</li>
<li><code>state_size::int (non-negative), required</code>: size of the state for each layer</li>
<li><code>num_layers::int (non-negative), required</code>: number of stacked layers</li>
<li><code>bidirectional::boolean, optional, default=0</code>: whether to use bidirectional recurrent layers</li>
<li><code>mode::{'gru', 'lstm', 'rnn_relu', 'rnn_tanh'}, required</code>: the type of RNN to compute</li>
<li><code>p::float, optional, default=0</code>: Dropout probability, fraction of the input that gets dropped out at training time</li>
<li><code>state_outputs::boolean, optional, default=0</code>: Whether to have the states as symbol outputs.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1509' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ROIPooling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.ROIPooling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.ROIPooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ROIPooling(data, rois, pooled_size, spatial_scale)
</code></pre>

<p>Performs region of interest(ROI) pooling on the input array.</p>
<p>ROI pooling is a variant of a max pooling layer, in which the output size is fixed and region of interest is a parameter. Its purpose is to perform max pooling on the inputs of non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net layer mostly used in training a <code>Fast R-CNN</code> network for object detection.</p>
<p>This operator takes a 4D feature map as an input array and region proposals as <code>rois</code>, then it pools over sub-regions of input and produces a fixed-sized output array regardless of the ROI size.</p>
<p>To crop the feature map accordingly, you can resize the bounding box coordinates by changing the parameters <code>rois</code> and <code>spatial_scale</code>.</p>
<p>The cropped feature maps are pooled by standard max pooling operation to a fixed size output indicated by a <code>pooled_size</code> parameter. batch_size will change to the number of region bounding boxes after <code>ROIPooling</code>.</p>
<p>The size of each region of interest doesn't have to be perfectly divisible by the number of pooling sections(<code>pooled_size</code>).</p>
<p>Example::</p>
<p>x = [[[[  0.,   1.,   2.,   3.,   4.,   5.],          [  6.,   7.,   8.,   9.,  10.,  11.],          [ 12.,  13.,  14.,  15.,  16.,  17.],          [ 18.,  19.,  20.,  21.,  22.,  23.],          [ 24.,  25.,  26.,  27.,  28.,  29.],          [ 30.,  31.,  32.,  33.,  34.,  35.],          [ 36.,  37.,  38.,  39.,  40.,  41.],          [ 42.,  43.,  44.,  45.,  46.,  47.]]]]</p>
<p>// region of interest i.e. bounding box coordinates.   y = [[0,0,0,4,4]]</p>
<p>// returns array of shape (2,2) according to the given roi with max pooling.   ROIPooling(x, y, (2,2), 1.0) = [[[[ 14.,  16.],                                     [ 26.,  28.]]]]</p>
<p>// region of interest is changed due to the change in <code>spacial_scale</code> parameter.   ROIPooling(x, y, (2,2), 0.7) = [[[[  7.,   9.],                                     [ 19.,  21.]]]]</p>
<p>Defined in src/operator/roi_pooling.cc:L287</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array to the pooling operator,  a 4D Feature maps</li>
<li><code>rois::NDArray-or-SymbolicNode</code>: Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]], where (x1, y1) and (x2, y2) are top left and bottom right corners of designated region of interest. <code>batch_index</code> indicates the index of corresponding image in the input array</li>
<li><code>pooled_size::Shape(tuple), required</code>: ROI pooling output shape (h,w)</li>
<li><code>spatial_scale::float, required</code>: Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1542' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SVMOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.SVMOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.SVMOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>SVMOutput(data, label, margin, regularization_coefficient, use_linear)
</code></pre>

<p>Computes support vector machine based transformation of the input.</p>
<p>This tutorial demonstrates using SVM as output layer for classification instead of softmax: https://github.com/dmlc/mxnet/tree/master/example/svm_mnist.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data for SVM transformation.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Class label for the input data.</li>
<li><code>margin::float, optional, default=1</code>: The loss function penalizes outputs that lie outside this margin. Default margin is 1.</li>
<li><code>regularization_coefficient::float, optional, default=1</code>: Regularization parameter for the SVM. This balances the tradeoff between coefficient size and error.</li>
<li><code>use_linear::boolean, optional, default=0</code>: Whether to use L1-SVM objective. L2-SVM objective is used by default.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1504' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SequenceLast-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.SequenceLast-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.SequenceLast</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>SequenceLast(data, sequence_length, use_sequence_length)
</code></pre>

<p>Takes the last element of a sequence.</p>
<p>This function takes an n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] and returns a (n-1)-dimensional array of the form [batch_size, other_feature_dims].</p>
<p>Parameter <code>sequence_length</code> is used to handle variable-length sequences. <code>sequence_length</code> should be an input array of positive ints of dimension [batch_size]. To use this parameter, set <code>use_sequence_length</code> to <code>True</code>, otherwise each example in the batch is assumed to have the max sequence length.</p>
<p>.. note:: Alternatively, you can also use <code>take</code> operator.</p>
<p>Example::</p>
<p>x = [[[  1.,   2.,   3.],          [  4.,   5.,   6.],          [  7.,   8.,   9.]],</p>
<pre><code>    [[ 10.,   11.,   12.],
     [ 13.,   14.,   15.],
     [ 16.,   17.,   18.]],

    [[  19.,   20.,   21.],
     [  22.,   23.,   24.],
     [  25.,   26.,   27.]]]
</code></pre>

<p>// returns last sequence when sequence_length parameter is not used    SequenceLast(x) = [[  19.,   20.,   21.],                       [  22.,   23.,   24.],                       [  25.,   26.,   27.]]</p>
<p>// sequence_length y is used    SequenceLast(x, y=[1,1,1], use_sequence_length=True) =             [[  1.,   2.,   3.],              [  4.,   5.,   6.],              [  7.,   8.,   9.]]</p>
<p>// sequence_length y is used    SequenceLast(x, y=[1,2,3], use_sequence_length=True) =             [[  1.,    2.,   3.],              [  13.,  14.,  15.],              [  25.,  26.,  27.]]</p>
<p>Defined in src/operator/sequence_last.cc:L92</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n&gt;2</li>
<li><code>sequence_length::NDArray-or-SymbolicNode</code>: vector of sequence lengths of the form [batch_size]</li>
<li><code>use_sequence_length::boolean, optional, default=0</code>: If set to true, this layer takes in an extra input parameter <code>sequence_length</code> to specify variable length sequence</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1541' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SequenceMask-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.SequenceMask-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.SequenceMask</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>SequenceMask(data, sequence_length, use_sequence_length, value)
</code></pre>

<p>Sets all elements outside the sequence to a constant value.</p>
<p>This function takes an n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] and returns an array of the same shape.</p>
<p>Parameter <code>sequence_length</code> is used to handle variable-length sequences. <code>sequence_length</code> should be an input array of positive ints of dimension [batch_size]. To use this parameter, set <code>use_sequence_length</code> to <code>True</code>, otherwise each example in the batch is assumed to have the max sequence length and this operator works as the <code>identity</code> operator.</p>
<p>Example::</p>
<p>x = [[[  1.,   2.,   3.],          [  4.,   5.,   6.]],</p>
<pre><code>    [[  7.,   8.,   9.],
     [ 10.,  11.,  12.]],

    [[ 13.,  14.,   15.],
     [ 16.,  17.,   18.]]]
</code></pre>

<p>// Batch 1    B1 = [[  1.,   2.,   3.],          [  7.,   8.,   9.],          [ 13.,  14.,  15.]]</p>
<p>// Batch 2    B2 = [[  4.,   5.,   6.],          [ 10.,  11.,  12.],          [ 16.,  17.,  18.]]</p>
<p>// works as identity operator when sequence_length parameter is not used    SequenceMask(x) = [[[  1.,   2.,   3.],                        [  4.,   5.,   6.]],</p>
<pre><code>                  [[  7.,   8.,   9.],
                   [ 10.,  11.,  12.]],

                  [[ 13.,  14.,   15.],
                   [ 16.,  17.,   18.]]]
</code></pre>

<p>// sequence_length [1,1] means 1 of each batch will be kept    // and other rows are masked with default mask value = 0    SequenceMask(x, y=[1,1], use_sequence_length=True) =                 [[[  1.,   2.,   3.],                   [  4.,   5.,   6.]],</p>
<pre><code>             [[  0.,   0.,   0.],
              [  0.,   0.,   0.]],

             [[  0.,   0.,   0.],
              [  0.,   0.,   0.]]]
</code></pre>

<p>// sequence_length [2,3] means 2 of batch B1 and 3 of batch B2 will be kept    // and other rows are masked with value = 1    SequenceMask(x, y=[2,3], use_sequence_length=True, value=1) =                 [[[  1.,   2.,   3.],                   [  4.,   5.,   6.]],</p>
<pre><code>             [[  7.,   8.,   9.],
              [  10.,  11.,  12.]],

             [[   1.,   1.,   1.],
              [  16.,  17.,  18.]]]
</code></pre>

<p>Defined in src/operator/sequence_mask.cc:L114</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n&gt;2</li>
<li><code>sequence_length::NDArray-or-SymbolicNode</code>: vector of sequence lengths of the form [batch_size]</li>
<li><code>use_sequence_length::boolean, optional, default=0</code>: If set to true, this layer takes in an extra input parameter <code>sequence_length</code> to specify variable length sequence</li>
<li><code>value::float, optional, default=0</code>: The value to be used as a mask.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1565' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SequenceReverse-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.SequenceReverse-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.SequenceReverse</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>SequenceReverse(data, sequence_length, use_sequence_length)
</code></pre>

<p>Reverses the elements of each sequence.</p>
<p>This function takes an n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] and returns an array of the same shape.</p>
<p>Parameter <code>sequence_length</code> is used to handle variable-length sequences. <code>sequence_length</code> should be an input array of positive ints of dimension [batch_size]. To use this parameter, set <code>use_sequence_length</code> to <code>True</code>, otherwise each example in the batch is assumed to have the max sequence length.</p>
<p>Example::</p>
<p>x = [[[  1.,   2.,   3.],          [  4.,   5.,   6.]],</p>
<pre><code>    [[  7.,   8.,   9.],
     [ 10.,  11.,  12.]],

    [[ 13.,  14.,   15.],
     [ 16.,  17.,   18.]]]
</code></pre>

<p>// Batch 1    B1 = [[  1.,   2.,   3.],          [  7.,   8.,   9.],          [ 13.,  14.,  15.]]</p>
<p>// Batch 2    B2 = [[  4.,   5.,   6.],          [ 10.,  11.,  12.],          [ 16.,  17.,  18.]]</p>
<p>// returns reverse sequence when sequence_length parameter is not used    SequenceReverse(x) = [[[ 13.,  14.,   15.],                           [ 16.,  17.,   18.]],</p>
<pre><code>                     [[  7.,   8.,   9.],
                      [ 10.,  11.,  12.]],

                     [[  1.,   2.,   3.],
                      [  4.,   5.,   6.]]]
</code></pre>

<p>// sequence_length [2,2] means 2 rows of    // both batch B1 and B2 will be reversed.    SequenceReverse(x, y=[2,2], use_sequence_length=True) =                      [[[  7.,   8.,   9.],                        [ 10.,  11.,  12.]],</p>
<pre><code>                  [[  1.,   2.,   3.],
                   [  4.,   5.,   6.]],

                  [[ 13.,  14.,   15.],
                   [ 16.,  17.,   18.]]]
</code></pre>

<p>// sequence_length [2,3] means 2 of batch B2 and 3 of batch B3    // will be reversed.    SequenceReverse(x, y=[2,3], use_sequence_length=True) =                     [[[  7.,   8.,   9.],                       [ 16.,  17.,  18.]],</p>
<pre><code>                 [[  1.,   2.,   3.],
                  [ 10.,  11.,  12.]],

                 [[ 13.,  14,   15.],
                  [  4.,   5.,   6.]]]
</code></pre>

<p>Defined in src/operator/sequence_reverse.cc:L113</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: n-dimensional input array of the form [max_sequence_length, batch_size, other dims] where n&gt;2</li>
<li><code>sequence_length::NDArray-or-SymbolicNode</code>: vector of sequence lengths of the form [batch_size]</li>
<li><code>use_sequence_length::boolean, optional, default=0</code>: If set to true, this layer takes in an extra input parameter <code>sequence_length</code> to specify variable length sequence</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1562' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SliceChannel-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.SliceChannel-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.SliceChannel</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>SliceChannel(data, num_outputs, axis, squeeze_axis)
</code></pre>

<p>Splits an array along a particular axis into multiple sub-arrays.</p>
<p>.. note:: $SliceChannel$ is deprecated. Use $split$ instead.</p>
<p><strong>Note</strong> that <code>num_outputs</code> should evenly divide the length of the axis along which to split the array.</p>
<p>Example::</p>
<p>x  = [[[ 1.]           [ 2.]]          [[ 3.]           [ 4.]]          [[ 5.]           [ 6.]]]    x.shape = (3, 2, 1)</p>
<p>y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)    y = [[[ 1.]]         [[ 3.]]         [[ 5.]]]</p>
<pre><code>   [[[ 2.]]
    [[ 4.]]
    [[ 6.]]]
</code></pre>

<p>y[0].shape = (3, 1, 1)</p>
<p>z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)    z = [[[ 1.]          [ 2.]]]</p>
<pre><code>   [[[ 3.]
     [ 4.]]]

   [[[ 5.]
     [ 6.]]]
</code></pre>

<p>z[0].shape = (1, 2, 1)</p>
<p><code>squeeze_axis=1</code> removes the axis with length 1 from the shapes of the output arrays. <strong>Note</strong> that setting <code>squeeze_axis</code> to $1$ removes axis with length 1 only along the <code>axis</code> which it is split. Also <code>squeeze_axis</code> can be set to true only if $input.shape[axis] == num_outputs$.</p>
<p>Example::</p>
<p>z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)    z = [[ 1.]         [ 2.]]</p>
<pre><code>   [[ 3.]
    [ 4.]]

   [[ 5.]
    [ 6.]]
</code></pre>

<p>z[0].shape = (2 ,1 )</p>
<p>Defined in src/operator/slice_channel.cc:L107</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>num_outputs::int, required</code>: Number of splits. Note that this should evenly divide the length of the <code>axis</code>.</li>
<li><code>axis::int, optional, default='1'</code>: Axis along which to split.</li>
<li><code>squeeze_axis::boolean, optional, default=0</code>: If true, Removes the axis with length 1 from the shapes of the output arrays. <strong>Note</strong> that setting <code>squeeze_axis</code> to $true$ removes axis with length 1 only along the <code>axis</code> which it is split. Also <code>squeeze_axis</code> can be set to $true$ only if $input.shape[axis] == num_outputs$.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1557' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SoftmaxActivation-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.SoftmaxActivation-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.SoftmaxActivation</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>SoftmaxActivation(data, mode)
</code></pre>

<p>Applies softmax activation to input. This is intended for internal layers.</p>
<p>.. note::</p>
<p>This operator has been deprecated, please use <code>softmax</code>.</p>
<p>If <code>mode</code> = $instance$, this operator will compute a softmax for each instance in the batch. This is the default mode.</p>
<p>If <code>mode</code> = $channel$, this operator will compute a k-class softmax at each position of each instance, where <code>k</code> = $num_channel$. This mode can only be used when the input array has at least 3 dimensions. This can be used for <code>fully convolutional network</code>, <code>image segmentation</code>, etc.</p>
<p>Example::</p>
<blockquote>
<blockquote>
<blockquote>
<p>input_array = mx.nd.array([[3., 0.5, -0.5, 2., 7.],                            [2., -.4, 7.,   3., 0.2]]) softmax_act = mx.nd.SoftmaxActivation(input_array) print softmax_act.asnumpy()</p>
</blockquote>
</blockquote>
</blockquote>
<p>[[  1.78322066e-02   1.46375655e-03   5.38485940e-04   6.56010211e-03   9.73605454e-01]    [  6.56221947e-03   5.95310994e-04   9.73919690e-01   1.78379621e-02   1.08472735e-03]]</p>
<p>Defined in src/operator/nn/softmax_activation.cc:L67</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array to activation function.</li>
<li><code>mode::{'channel', 'instance'},optional, default='instance'</code>: Specifies how to compute the softmax. If set to $instance$, it computes softmax for each instance. If set to $channel$, It computes cross channel softmax for each position of each instance.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1518' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SoftmaxOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.SoftmaxOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.SoftmaxOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>SoftmaxOutput(data, label, grad_scale, ignore_label, multi_output, use_ignore, preserve_shape, normalization, out_grad, smooth_alpha)
</code></pre>

<p>Computes the gradient of cross entropy loss with respect to softmax output.</p>
<ul>
<li>
<p>This operator computes the gradient in two steps. The cross entropy loss does not actually need to be computed.</p>
<ul>
<li>Applies softmax function on the input array.</li>
<li>Computes and returns the gradient of cross entropy loss w.r.t. the softmax output.</li>
<li>
<p>The softmax function, cross entropy loss and gradient is given by:</p>
</li>
<li>
<p>Softmax Function:</p>
<p>.. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}
      * Cross Entropy Function:</p>
<p>.. math:: \text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)
      * The gradient of cross entropy loss w.r.t softmax output:</p>
<p>.. math:: \text{gradient} = \text{output} - \text{label}
  * During forward propagation, the softmax function is computed for each instance in the input array.</p>
</li>
</ul>
<p>For general <em>N</em>-D input arrays with shape :math:<code>(d_1, d_2, ..., d_n)</code>. The size is :math:<code>s=d_1 \cdot d_2 \cdot \cdot \cdot d_n</code>. We can use the parameters <code>preserve_shape</code> and <code>multi_output</code> to specify the way to compute softmax:</p>
<ul>
<li>By default, <code>preserve_shape</code> is $false$. This operator will reshape the input array into a 2-D array with shape :math:<code>(d_1, \frac{s}{d_1})</code> and then compute the softmax function for each row in the reshaped array, and afterwards reshape it back to the original shape :math:<code>(d_1, d_2, ..., d_n)</code>.</li>
<li>If <code>preserve_shape</code> is $true$, the softmax function will be computed along the last axis (<code>axis</code> = $-1$).</li>
<li>If <code>multi_output</code> is $true$, the softmax function will be computed along the second axis (<code>axis</code> = $1$).</li>
<li>
<p>During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed. The provided label can be a one-hot label array or a probability label array.</p>
</li>
<li>
<p>If the parameter <code>use_ignore</code> is $true$, <code>ignore_label</code> can specify input instances with a particular label to be ignored during backward propagation. <strong>This has no effect when softmax <code>output</code> has same shape as <code>label</code></strong>.</p>
<p>Example::</p>
<p>data = [[1,2,3,4],[2,2,2,2],[3,3,3,3],[4,4,4,4]]   label = [1,0,2,3]   ignore_label = 1   SoftmaxOutput(data=data, label = label,
                multi_output=true, use_ignore=true,
                ignore_label=ignore_label)</p>
<h2 id="forward-softmax-output">forward softmax output</h2>
<p>[[ 0.0320586   0.08714432  0.23688284  0.64391428]    [ 0.25        0.25        0.25        0.25      ]    [ 0.25        0.25        0.25        0.25      ]    [ 0.25        0.25        0.25        0.25      ]]</p>
<h2 id="backward-gradient-output">backward gradient output</h2>
<p>[[ 0.    0.    0.    0.  ]    [-0.75  0.25  0.25  0.25]    [ 0.25  0.25 -0.75  0.25]    [ 0.25  0.25  0.25 -0.75]]</p>
<h2 id="notice-that-the-first-row-is-all-0-because-label0-is-1-which-is-equal-to-ignore_label">notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.</h2>
<pre><code>  * The parameter `grad_scale` can be used to rescale the gradient, which is often used to give each loss function different weights.
  * This operator also supports various ways to normalize the gradient by `normalization`, The `normalization` is applied if softmax output has different shape than the labels. The `normalization` mode can be set to the followings:
</code></pre>
<ul>
<li>$'null'$: do nothing.</li>
<li>$'batch'$: divide the gradient by the batch size.</li>
<li>$'valid'$: divide the gradient by the number of instances which are not ignored.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Defined in src/operator/softmax_output.cc:L123</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Ground truth label.</li>
<li><code>grad_scale::float, optional, default=1</code>: Scales the gradient by a float factor.</li>
<li><code>ignore_label::float, optional, default=-1</code>: The instances whose <code>labels</code> == <code>ignore_label</code> will be ignored during backward, if <code>use_ignore</code> is set to $true$).</li>
<li><code>multi_output::boolean, optional, default=0</code>: If set to $true$, the softmax function will be computed along axis $1$. This is applied when the shape of input array differs from the shape of label array.</li>
<li><code>use_ignore::boolean, optional, default=0</code>: If set to $true$, the <code>ignore_label</code> value will not contribute to the backward gradient.</li>
<li><code>preserve_shape::boolean, optional, default=0</code>: If set to $true$, the softmax function will be computed along the last axis ($-1$).</li>
<li><code>normalization::{'batch', 'null', 'valid'},optional, default='null'</code>: Normalizes the gradient.</li>
<li><code>out_grad::boolean, optional, default=0</code>: Multiplies gradient with output gradient element-wise.</li>
<li><code>smooth_alpha::float, optional, default=0</code>: Constant for computing a label smoothed version of cross-entropyfor the backwards pass.  This constant gets subtracted from theone-hot encoding of the gold label and distributed uniformly toall other labels.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1586' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SpatialTransformer-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.SpatialTransformer-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.SpatialTransformer</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>SpatialTransformer(data, loc, target_shape, transform_type, sampler_type)
</code></pre>

<p>Applies a spatial transformer to input feature map.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the SpatialTransformerOp.</li>
<li><code>loc::NDArray-or-SymbolicNode</code>: localisation net, the output dim should be 6 when transform_type is affine. You shold initialize the weight and bias with identity tranform.</li>
<li><code>target_shape::Shape(tuple), optional, default=[0,0]</code>: output shape(h, w) of spatial transformer: (y, x)</li>
<li><code>transform_type::{'affine'}, required</code>: transformation type</li>
<li><code>sampler_type::{'bilinear'}, required</code>: sampling type</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1499' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SwapAxis-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.SwapAxis-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.SwapAxis</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>SwapAxis(data, dim1, dim2)
</code></pre>

<p>Interchanges two axes of an array.</p>
<p>Examples::</p>
<p>x = [[1, 2, 3]])   swapaxes(x, 0, 1) = [[ 1],                        [ 2],                        [ 3]]</p>
<p>x = [[[ 0, 1],         [ 2, 3]],        [[ 4, 5],         [ 6, 7]]]  // (2,2,2) array</p>
<p>swapaxes(x, 0, 2) = [[[ 0, 4],                        [ 2, 6]],                       [[ 1, 5],                        [ 3, 7]]]</p>
<p>Defined in src/operator/swapaxis.cc:L70</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
<li><code>dim1::int (non-negative), optional, default=0</code>: the first axis to be swapped.</li>
<li><code>dim2::int (non-negative), optional, default=0</code>: the second axis to be swapped.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1515' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.UpSampling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.UpSampling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.UpSampling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>UpSampling(data, scale, num_filter, sample_type, multi_input_mode, num_args, workspace)
</code></pre>

<p><strong>Note</strong>: UpSampling takes variable number of positional inputs. So instead of calling as UpSampling([x, y, z], num_args=3), one should call via UpSampling(x, y, z), and num_args will be determined automatically.</p>
<p>Performs nearest neighbor/bilinear up sampling to inputs.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Array of tensors to upsample</li>
<li><code>scale::int (non-negative), required</code>: Up sampling scale</li>
<li><code>num_filter::int (non-negative), optional, default=0</code>: Input filter. Only used by bilinear sample_type.</li>
<li><code>sample_type::{'bilinear', 'nearest'}, required</code>: upsampling method</li>
<li><code>multi_input_mode::{'concat', 'sum'},optional, default='concat'</code>: How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images together, only available for nearest neighbor upsampling.</li>
<li><code>num_args::int, required</code>: Number of inputs to be upsampled. For nearest neighbor upsampling, this can be 1-N; the size of output will be(scale<em>h_0,scale</em>w_0) and all other inputs will be upsampled to thesame size. For bilinear upsampling this must be 2; 1 input and 1 weight.</li>
<li><code>workspace::long (non-negative), optional, default=512</code>: Tmp workspace for deconvolution (MB)</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1505' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._CachedOp-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._CachedOp-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._CachedOp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_CachedOp()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._CrossDeviceCopy-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._CrossDeviceCopy-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._CrossDeviceCopy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_CrossDeviceCopy()
</code></pre>

<p>Special op to copy data cross device</p>
<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._CustomFunction-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._CustomFunction-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._CustomFunction</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_CustomFunction()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Div-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._Div-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._Div</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_Div(lhs, rhs)
</code></pre>

<p>_Div is an alias of elemwise_div.</p>
<p>Divides arguments element-wise.</p>
<p>The storage type of $elemwise_div$ output is always dense</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1499' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._DivScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._DivScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._DivScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_DivScalar(data, scalar)
</code></pre>

<p>_DivScalar is an alias of _div_scalar.</p>
<p>Divide an array with a scalar.</p>
<p>$_div_scalar$ only operates on data array of input if input is sparse.</p>
<p>For example, if input of shape (100, 100) has only 2 non zero elements, i.e. input.data = [5, 6], scalar = nan, it will result output.data = [nan, nan] instead of 10000 nans.</p>
<p>Defined in src/operator/tensor/elemwise_binary_scalar_op_basic.cc:L164</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1505' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._Equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._Equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_Equal(lhs, rhs)
</code></pre>

<p>_Equal is an alias of _equal.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._EqualScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._EqualScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._EqualScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_EqualScalar(data, scalar)
</code></pre>

<p>_EqualScalar is an alias of _equal_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Greater-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._Greater-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._Greater</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_Greater(lhs, rhs)
</code></pre>

<p>_Greater is an alias of _greater.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._GreaterEqualScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._GreaterEqualScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._GreaterEqualScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_GreaterEqualScalar(data, scalar)
</code></pre>

<p>_GreaterEqualScalar is an alias of _greater_equal_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._GreaterScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._GreaterScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._GreaterScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_GreaterScalar(data, scalar)
</code></pre>

<p>_GreaterScalar is an alias of _greater_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Greater_Equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._Greater_Equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._Greater_Equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_Greater_Equal(lhs, rhs)
</code></pre>

<p>_Greater_Equal is an alias of _greater_equal.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Hypot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._Hypot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._Hypot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_Hypot(lhs, rhs)
</code></pre>

<p>_Hypot is an alias of _hypot.</p>
<p>Given the "legs" of a right triangle, return its hypotenuse.</p>
<p>Defined in src/operator/tensor/elemwise_binary_op_extended.cc:L79</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1499' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._HypotScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._HypotScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._HypotScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_HypotScalar(data, scalar)
</code></pre>

<p>_HypotScalar is an alias of _hypot_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Lesser-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._Lesser-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._Lesser</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_Lesser(lhs, rhs)
</code></pre>

<p>_Lesser is an alias of _lesser.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._LesserEqualScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._LesserEqualScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._LesserEqualScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_LesserEqualScalar(data, scalar)
</code></pre>

<p>_LesserEqualScalar is an alias of _lesser_equal_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._LesserScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._LesserScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._LesserScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_LesserScalar(data, scalar)
</code></pre>

<p>_LesserScalar is an alias of _lesser_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Lesser_Equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._Lesser_Equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._Lesser_Equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_Lesser_Equal(lhs, rhs)
</code></pre>

<p>_Lesser_Equal is an alias of _lesser_equal.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Maximum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._Maximum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._Maximum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_Maximum(lhs, rhs)
</code></pre>

<p>_Maximum is an alias of _maximum.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._MaximumScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._MaximumScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._MaximumScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_MaximumScalar(data, scalar)
</code></pre>

<p>_MaximumScalar is an alias of _maximum_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Minimum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._Minimum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._Minimum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_Minimum(lhs, rhs)
</code></pre>

<p>_Minimum is an alias of _minimum.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._MinimumScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._MinimumScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._MinimumScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_MinimumScalar(data, scalar)
</code></pre>

<p>_MinimumScalar is an alias of _minimum_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._MinusScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._MinusScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._MinusScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_MinusScalar(data, scalar)
</code></pre>

<p>_MinusScalar is an alias of _minus_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._ModScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._ModScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._ModScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_ModScalar(data, scalar)
</code></pre>

<p>_ModScalar is an alias of _mod_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Mul-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._Mul-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._Mul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_Mul(lhs, rhs)
</code></pre>

<p>_Mul is an alias of elemwise_mul.</p>
<p>Multiplies arguments element-wise.</p>
<p>The storage type of $elemwise_mul$ output depends on storage types of inputs</p>
<ul>
<li>elemwise_mul(default, default) = default</li>
<li>elemwise_mul(row_sparse, row_sparse) = row_sparse</li>
<li>elemwise_mul(default, row_sparse) = default</li>
<li>elemwise_mul(row_sparse, default) = default</li>
<li>elemwise_mul(csr, csr) = csr</li>
<li>otherwise, $elemwise_mul$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1506' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._MulScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._MulScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._MulScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_MulScalar(data, scalar)
</code></pre>

<p>_MulScalar is an alias of _mul_scalar.</p>
<p>Multiply an array with a scalar.</p>
<p>$_mul_scalar$ only operates on data array of input if input is sparse.</p>
<p>For example, if input of shape (100, 100) has only 2 non zero elements, i.e. input.data = [5, 6], scalar = nan, it will result output.data = [nan, nan] instead of 10000 nans.</p>
<p>Defined in src/operator/tensor/elemwise_binary_scalar_op_basic.cc:L142</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1505' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._NDArray-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._NDArray-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._NDArray</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_NDArray(data, info)
</code></pre>

<p>Stub for implementing an operator implemented in native frontend language with ndarray.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Input data for the custom operator.</li>
<li><code>info::ptr, required</code>:</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Native-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._Native-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._Native</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_Native(data, info, need_top_grad)
</code></pre>

<p>Stub for implementing an operator implemented in native frontend language.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: Input data for the custom operator.</li>
<li><code>info::ptr, required</code>:</li>
<li><code>need_top_grad::boolean, optional, default=1</code>: Whether this layer needs out grad for backward. Should be false for loss layers.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._NoGradient-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._NoGradient-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._NoGradient</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_NoGradient()
</code></pre>

<p>Place holder for variable who cannot perform gradient</p>
<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._NotEqualScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._NotEqualScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._NotEqualScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_NotEqualScalar(data, scalar)
</code></pre>

<p>_NotEqualScalar is an alias of _not_equal_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Not_Equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._Not_Equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._Not_Equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_Not_Equal(lhs, rhs)
</code></pre>

<p>_Not_Equal is an alias of _not_equal.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._PlusScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._PlusScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._PlusScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_PlusScalar(data, scalar)
</code></pre>

<p>_PlusScalar is an alias of _plus_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._Power-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._Power-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._Power</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_Power(lhs, rhs)
</code></pre>

<p>_Power is an alias of _power.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._PowerScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._PowerScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._PowerScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_PowerScalar(data, scalar)
</code></pre>

<p>_PowerScalar is an alias of _power_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._RDivScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._RDivScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._RDivScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_RDivScalar(data, scalar)
</code></pre>

<p>_RDivScalar is an alias of _rdiv_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._RMinusScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._RMinusScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._RMinusScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_RMinusScalar(data, scalar)
</code></pre>

<p>_RMinusScalar is an alias of _rminus_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._RModScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._RModScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._RModScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_RModScalar(data, scalar)
</code></pre>

<p>_RModScalar is an alias of _rmod_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._RPowerScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._RPowerScalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._RPowerScalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_RPowerScalar(data, scalar)
</code></pre>

<p>_RPowerScalar is an alias of _rpower_scalar.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._add-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._add-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._add</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_add(lhs, rhs)
</code></pre>

<p>_add is an alias of elemwise_add.</p>
<p>Adds arguments element-wise.</p>
<p>The storage type of $elemwise_add$ output depends on storage types of inputs</p>
<ul>
<li>elemwise_add(row_sparse, row_sparse) = row_sparse</li>
<li>elemwise_add(csr, csr) = csr</li>
<li>otherwise, $elemwise_add$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1503' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._arange-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._arange-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._arange</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_arange(start, stop, step, repeat, ctx, dtype)
</code></pre>

<p>Return evenly spaced values within a given interval. Similar to Numpy</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>start::double, required</code>: Start of interval. The interval includes this value. The default start value is 0.</li>
<li><code>stop::double or None, optional, default=None</code>: End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</li>
<li><code>step::double, optional, default=1</code>: Spacing between values.</li>
<li><code>repeat::int, optional, default='1'</code>: The repeating time of all elements. E.g repeat=3, the element a will be repeated three times –&gt; a, a, a.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="../n">cpu|gpu|cpu_pinned</a>.Only used for imperative calls.</li>
<li><code>dtype::{'float16', 'float32', 'float64', 'int32', 'int64', 'uint8'},optional, default='float32'</code>: Target data type.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1501' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Activation-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_Activation-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Activation</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_Activation()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_BatchNorm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_BatchNorm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_BatchNorm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_BatchNorm()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_BatchNorm_v1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_BatchNorm_v1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_BatchNorm_v1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_BatchNorm_v1()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_BilinearSampler-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_BilinearSampler-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_BilinearSampler</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_BilinearSampler()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_CachedOp-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_CachedOp-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_CachedOp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_CachedOp()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Concat-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_Concat-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Concat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_Concat()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Convolution-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_Convolution-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Convolution</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_Convolution()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Convolution_v1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_Convolution_v1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Convolution_v1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_Convolution_v1()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Correlation-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_Correlation-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Correlation</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_Correlation()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Crop-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_Crop-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Crop</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_Crop()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Custom-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_Custom-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Custom</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_Custom()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_CustomFunction-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_CustomFunction-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_CustomFunction</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_CustomFunction()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Deconvolution-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_Deconvolution-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Deconvolution</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_Deconvolution()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Dropout-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_Dropout-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Dropout</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_Dropout()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Embedding-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_Embedding-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Embedding</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_Embedding()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_FullyConnected-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_FullyConnected-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_FullyConnected</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_FullyConnected()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_GridGenerator-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_GridGenerator-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_GridGenerator</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_GridGenerator()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_IdentityAttachKLSparseReg-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_IdentityAttachKLSparseReg-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_IdentityAttachKLSparseReg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_IdentityAttachKLSparseReg()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_InstanceNorm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_InstanceNorm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_InstanceNorm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_InstanceNorm()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_L2Normalization-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_L2Normalization-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_L2Normalization</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_L2Normalization()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_LRN-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_LRN-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_LRN</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_LRN()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_LeakyReLU-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_LeakyReLU-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_LeakyReLU</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_LeakyReLU()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_LinearRegressionOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_LinearRegressionOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_LinearRegressionOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_LinearRegressionOutput()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_LogisticRegressionOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_LogisticRegressionOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_LogisticRegressionOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_LogisticRegressionOutput()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_MAERegressionOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_MAERegressionOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_MAERegressionOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_MAERegressionOutput()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_MakeLoss-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_MakeLoss-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_MakeLoss</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_MakeLoss()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Pad-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_Pad-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Pad</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_Pad()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Pooling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_Pooling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Pooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_Pooling()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Pooling_v1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_Pooling_v1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Pooling_v1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_Pooling_v1()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_RNN-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_RNN-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_RNN</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_RNN()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_ROIPooling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_ROIPooling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_ROIPooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_ROIPooling()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SVMOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_SVMOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SVMOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_SVMOutput()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SequenceLast-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_SequenceLast-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SequenceLast</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_SequenceLast()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SequenceMask-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_SequenceMask-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SequenceMask</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_SequenceMask()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SequenceReverse-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_SequenceReverse-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SequenceReverse</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_SequenceReverse()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SliceChannel-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_SliceChannel-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SliceChannel</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_SliceChannel()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_Softmax-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_Softmax-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_Softmax</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_Softmax()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SoftmaxActivation-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_SoftmaxActivation-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SoftmaxActivation</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_SoftmaxActivation()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SoftmaxOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_SoftmaxOutput-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SoftmaxOutput</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_SoftmaxOutput()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SparseEmbedding-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_SparseEmbedding-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SparseEmbedding</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_SparseEmbedding()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SpatialTransformer-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_SpatialTransformer-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SpatialTransformer</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_SpatialTransformer()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_SwapAxis-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_SwapAxis-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_SwapAxis</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_SwapAxis()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_UpSampling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_UpSampling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_UpSampling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_UpSampling()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__CrossDeviceCopy-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward__CrossDeviceCopy-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__CrossDeviceCopy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward__CrossDeviceCopy()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__NDArray-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward__NDArray-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__NDArray</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward__NDArray()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__Native-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward__Native-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__Native</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward__Native()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_CTCLoss-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward__contrib_CTCLoss-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_CTCLoss</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward__contrib_CTCLoss()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_DeformableConvolution-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward__contrib_DeformableConvolution-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_DeformableConvolution</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward__contrib_DeformableConvolution()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_DeformablePSROIPooling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward__contrib_DeformablePSROIPooling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_DeformablePSROIPooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward__contrib_DeformablePSROIPooling()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_MultiBoxDetection-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward__contrib_MultiBoxDetection-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_MultiBoxDetection</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward__contrib_MultiBoxDetection()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_MultiBoxPrior-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward__contrib_MultiBoxPrior-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_MultiBoxPrior</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward__contrib_MultiBoxPrior()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_MultiBoxTarget-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward__contrib_MultiBoxTarget-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_MultiBoxTarget</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward__contrib_MultiBoxTarget()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_MultiProposal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward__contrib_MultiProposal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_MultiProposal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward__contrib_MultiProposal()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_PSROIPooling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward__contrib_PSROIPooling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_PSROIPooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward__contrib_PSROIPooling()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_Proposal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward__contrib_Proposal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_Proposal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward__contrib_Proposal()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_count_sketch-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward__contrib_count_sketch-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_count_sketch</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward__contrib_count_sketch()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_fft-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward__contrib_fft-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_fft</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward__contrib_fft()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward__contrib_ifft-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward__contrib_ifft-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward__contrib_ifft</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward__contrib_ifft()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_abs-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_abs-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_abs</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_abs(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_add-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_add-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_add</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_add()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_arccos-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_arccos-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_arccos</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_arccos(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_arccosh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_arccosh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_arccosh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_arccosh(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_arcsin-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_arcsin-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_arcsin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_arcsin(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_arcsinh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_arcsinh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_arcsinh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_arcsinh(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_arctan-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_arctan-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_arctan</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_arctan(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_arctanh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_arctanh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_arctanh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_arctanh(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_batch_dot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_batch_dot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_batch_dot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_batch_dot()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_add-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_broadcast_add-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_add</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_broadcast_add()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_div-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_broadcast_div-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_div</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_broadcast_div()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_hypot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_broadcast_hypot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_hypot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_broadcast_hypot()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_maximum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_broadcast_maximum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_maximum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_broadcast_maximum()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_minimum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_broadcast_minimum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_minimum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_broadcast_minimum()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_mod-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_broadcast_mod-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_mod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_broadcast_mod()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_mul-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_broadcast_mul-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_mul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_broadcast_mul()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_power-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_broadcast_power-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_power</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_broadcast_power()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_broadcast_sub-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_broadcast_sub-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_broadcast_sub</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_broadcast_sub()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_cast-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_cast-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_cast</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_cast()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_cbrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_cbrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_cbrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_cbrt(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_clip-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_clip-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_clip</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_clip()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_copy-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_copy-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_copy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_copy()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_cos-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_cos-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_cos</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_cos(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_cosh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_cosh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_cosh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_cosh(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_degrees-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_degrees-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_degrees</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_degrees(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_div-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_div-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_div</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_div()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_div_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_div_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_div_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_div_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_dot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_dot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_dot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_dot(transpose_a, transpose_b)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>transpose_a::boolean, optional, default=0</code>: If true then transpose the first input before dot.</li>
<li><code>transpose_b::boolean, optional, default=0</code>: If true then transpose the second input before dot.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_expm1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_expm1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_expm1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_expm1(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_gamma-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_gamma-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_gamma(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_gammaln-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_gammaln-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_gammaln</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_gammaln(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_hypot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_hypot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_hypot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_hypot()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_hypot_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_hypot_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_hypot_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_hypot_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_gelqf-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_linalg_gelqf-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_gelqf</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_linalg_gelqf()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_gemm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_linalg_gemm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_gemm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_linalg_gemm()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_gemm2-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_linalg_gemm2-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_gemm2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_linalg_gemm2()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_potrf-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_linalg_potrf-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_potrf</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_linalg_potrf()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_potri-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_linalg_potri-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_potri</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_linalg_potri()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_sumlogdiag-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_linalg_sumlogdiag-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_sumlogdiag</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_linalg_sumlogdiag()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_syevd-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_linalg_syevd-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_syevd</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_linalg_syevd()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_syrk-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_linalg_syrk-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_syrk</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_linalg_syrk()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_trmm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_linalg_trmm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_trmm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_linalg_trmm()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_linalg_trsm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_linalg_trsm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_linalg_trsm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_linalg_trsm()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_log-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_log-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_log</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_log(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_log10-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_log10-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_log10</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_log10(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_log1p-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_log1p-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_log1p</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_log1p(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_log2-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_log2-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_log2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_log2(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_log_softmax-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_log_softmax-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_log_softmax</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_log_softmax(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_max-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_max-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_max</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_max()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_maximum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_maximum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_maximum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_maximum()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_maximum_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_maximum_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_maximum_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_maximum_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_mean-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_mean-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_mean</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_mean()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_min-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_min-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_min</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_min()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_minimum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_minimum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_minimum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_minimum()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_minimum_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_minimum_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_minimum_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_minimum_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_mod-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_mod-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_mod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_mod()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_mod_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_mod_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_mod_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_mod_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_mul-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_mul-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_mul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_mul()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_mul_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_mul_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_mul_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_mul_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_nanprod-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_nanprod-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_nanprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_nanprod()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_nansum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_nansum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_nansum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_nansum()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_pick-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_pick-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_pick</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_pick()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_power-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_power-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_power</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_power()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_power_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_power_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_power_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_power_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_prod-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_prod-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_prod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_prod()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_radians-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_radians-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_radians</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_radians(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_rcbrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_rcbrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_rcbrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_rcbrt(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_rdiv_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_rdiv_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_rdiv_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_rdiv_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_reciprocal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_reciprocal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_reciprocal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_reciprocal(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_relu-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_relu-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_relu</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_relu(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_repeat-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_repeat-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_repeat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_repeat()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_reverse-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_reverse-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_reverse</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_reverse()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_rmod_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_rmod_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_rmod_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_rmod_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_rpower_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_rpower_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_rpower_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_rpower_scalar(lhs, rhs, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
<li><code>scalar::float</code>: scalar value</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_rsqrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_rsqrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_rsqrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_rsqrt(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_sample_multinomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_sample_multinomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_sample_multinomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_sample_multinomial()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_sigmoid-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_sigmoid-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_sigmoid</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_sigmoid(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_sign-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_sign-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_sign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_sign(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_sin-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_sin-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_sin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_sin(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_sinh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_sinh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_sinh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_sinh(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_slice-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_slice-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_slice</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_slice()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_slice_axis-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_slice_axis-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_slice_axis</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_slice_axis()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_smooth_l1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_smooth_l1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_smooth_l1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_smooth_l1(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_softmax-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_softmax-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_softmax</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_softmax(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_softmax_cross_entropy-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_softmax_cross_entropy-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_softmax_cross_entropy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_softmax_cross_entropy()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_sparse_retain-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_sparse_retain-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_sparse_retain</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_sparse_retain()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_sqrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_sqrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_sqrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_sqrt(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_square-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_square-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_square</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_square(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_square_sum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_square_sum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_square_sum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_square_sum()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_stack-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_stack-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_stack</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_stack()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_sub-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_sub-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_sub</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_sub()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_sum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_sum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_sum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_sum()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_take-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_take-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_take</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_take()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_tan-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_tan-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_tan</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_tan(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_tanh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_tanh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_tanh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_tanh(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_tile-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_tile-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_tile</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_tile()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_topk-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_topk-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_topk</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_topk()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._backward_where-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._backward_where-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._backward_where</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_backward_where()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._broadcast_backward-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._broadcast_backward-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._broadcast_backward</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_broadcast_backward()
</code></pre>

<p><strong>Arguments</strong></p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1490' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_CTCLoss-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._contrib_CTCLoss-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_CTCLoss</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_contrib_CTCLoss(data, label, data_lengths, label_lengths, use_data_lengths, use_label_lengths, blank_label)
</code></pre>

<p>Connectionist Temporal Classification Loss.</p>
<p>The shapes of the inputs and outputs:</p>
<ul>
<li><strong>data</strong>: <code>(sequence_length, batch_size, alphabet_size)</code></li>
<li><strong>label</strong>: <code>(batch_size, label_sequence_length)</code></li>
<li><strong>out</strong>: <code>(batch_size)</code></li>
</ul>
<p>The <code>data</code> tensor consists of sequences of activation vectors (without applying softmax), with i-th channel in the last dimension corresponding to i-th label for i between 0 and alphabet_size-1 (i.e always 0-indexed). Alphabet size should include one additional value reserved for blank label. When <code>blank_label</code> is $"first"$, the $0$-th channel is be reserved for activation of blank label, or otherwise if it is "last", $(alphabet_size-1)$-th channel should be reserved for blank label.</p>
<p>$label$ is an index matrix of integers. When <code>blank_label</code> is $"first"$, the value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise, when <code>blank_label</code> is $"last"$, the value <code>(alphabet_size-1)</code> is reserved for blank label.</p>
<p>If a sequence of labels is shorter than <em>label_sequence_length</em>, use the special padding value at the end of the sequence to conform it to the correct length. The padding value is <code>0</code> when <code>blank_label</code> is $"first"$, and <code>-1</code> otherwise.</p>
<p>For example, suppose the vocabulary is <code>[a, b, c]</code>, and in one batch we have three sequences 'ba', 'cbb', and 'abac'. When <code>blank_label</code> is $"first"$, we can index the labels as <code>{'a': 1, 'b': 2, 'c': 3}</code>, and we reserve the 0-th channel for blank label in data tensor. The resulting <code>label</code> tensor should be padded to be::</p>
<p>[[2, 1, 0, 0], [3, 2, 2, 0], [1, 2, 1, 3]]</p>
<p>When <code>blank_label</code> is $"last"$, we can index the labels as <code>{'a': 0, 'b': 1, 'c': 2}</code>, and we reserve the channel index 3 for blank label in data tensor. The resulting <code>label</code> tensor should be padded to be::</p>
<p>[[1, 0, -1, -1], [2, 1, 1, -1], [0, 1, 0, 2]]</p>
<p>$out$ is a list of CTC loss values, one per example in the batch.</p>
<p>See <em>Connectionist Temporal Classification: Labelling Unsegmented Sequence Data with Recurrent Neural Networks</em>, A. Graves <em>et al</em>. for more information on the definition and the algorithm.</p>
<p>Defined in src/operator/contrib/ctc_loss.cc:L115</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the ctc_loss op.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Ground-truth labels for the loss.</li>
<li><code>data_lengths::NDArray-or-SymbolicNode</code>: Lengths of data for each of the samples. Only required when use_data_lengths is true.</li>
<li><code>label_lengths::NDArray-or-SymbolicNode</code>: Lengths of labels for each of the samples. Only required when use_label_lengths is true.</li>
<li><code>use_data_lengths::boolean, optional, default=0</code>: Whether the data lenghts are decided by <code>data_lengths</code>. If false, the lengths are equal to the max sequence length.</li>
<li><code>use_label_lengths::boolean, optional, default=0</code>: Whether the label lenghts are decided by <code>label_lengths</code>, or derived from <code>padding_mask</code>. If false, the lengths are derived from the first occurrence of the value of <code>padding_mask</code>. The value of <code>padding_mask</code> is $0$ when first CTC label is reserved for blank, and $-1$ when last label is reserved for blank. See <code>blank_label</code>.</li>
<li><code>blank_label::{'first', 'last'},optional, default='first'</code>: Set the label that is reserved for blank label.If "first", 0-th label is reserved, and label values for tokens in the vocabulary are between $1$ and $alphabet_size-1$, and the padding mask is $-1$. If "last", last label value $alphabet_size-1$ is reserved for blank label instead, and label values for tokens in the vocabulary are between $0$ and $alphabet_size-2$, and the padding mask is $0$.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1548' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_DeformableConvolution-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._contrib_DeformableConvolution-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_DeformableConvolution</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_contrib_DeformableConvolution(data, offset, weight, bias, kernel, stride, dilate, pad, num_filter, num_group, num_deformable_group, workspace, no_bias, layout)
</code></pre>

<p>Compute 2-D deformable convolution on 4-D input.</p>
<p>The deformable convolution operation is described in https://arxiv.org/abs/1703.06211</p>
<p>For 2-D deformable convolution, the shapes are</p>
<ul>
<li><strong>data</strong>: <em>(batch_size, channel, height, width)</em></li>
<li><strong>offset</strong>: <em>(batch_size, num_deformable_group * kernel[0] * kernel[1], height, width)</em></li>
<li><strong>weight</strong>: <em>(num_filter, channel, kernel[0], kernel[1])</em></li>
<li><strong>bias</strong>: <em>(num_filter,)</em></li>
<li><strong>out</strong>: <em>(batch_size, num_filter, out_height, out_width)</em>.</li>
</ul>
<p>Define::</p>
<p>f(x,k,p,s,d) = floor((x+2<em>p-d</em>(k-1)-1)/s)+1</p>
<p>then we have::</p>
<p>out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])</p>
<p>If $no_bias$ is set to be true, then the $bias$ term is ignored.</p>
<p>The default data $layout$ is <em>NCHW</em>, namely <em>(batch_size, channle, height, width)</em>.</p>
<p>If $num_group$ is larger than 1, denoted by <em>g</em>, then split the input $data$ evenly into <em>g</em> parts along the channel axis, and also evenly split $weight$ along the first dimension. Next compute the convolution on the <em>i</em>-th part of the data with the <em>i</em>-th weight part. The output is obtained by concating all the <em>g</em> results.</p>
<p>If $num_deformable_group$ is larger than 1, denoted by <em>dg</em>, then split the input $offset$ evenly into <em>dg</em> parts along the channel axis, and also evenly split $out$ evenly into <em>dg</em> parts along the channel axis. Next compute the deformable convolution, apply the <em>i</em>-th part of the offset part on the <em>i</em>-th out.</p>
<p>Both $weight$ and $bias$ are learnable parameters.</p>
<p>Defined in src/operator/contrib/deformable_convolution.cc:L100</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the DeformableConvolutionOp.</li>
<li><code>offset::NDArray-or-SymbolicNode</code>: Input offset to the DeformableConvolutionOp.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight matrix.</li>
<li><code>bias::NDArray-or-SymbolicNode</code>: Bias parameter.</li>
<li><code>kernel::Shape(tuple), required</code>: Convolution kernel size: (h, w) or (d, h, w)</li>
<li><code>stride::Shape(tuple), optional, default=[]</code>: Convolution stride: (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>dilate::Shape(tuple), optional, default=[]</code>: Convolution dilate: (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><code>pad::Shape(tuple), optional, default=[]</code>: Zero pad for convolution: (h, w) or (d, h, w). Defaults to no padding.</li>
<li><code>num_filter::int (non-negative), required</code>: Convolution filter(channel) number</li>
<li><code>num_group::int (non-negative), optional, default=1</code>: Number of group partitions.</li>
<li><code>num_deformable_group::int (non-negative), optional, default=1</code>: Number of deformable group partitions.</li>
<li><code>workspace::long (non-negative), optional, default=1024</code>: Maximum temperal workspace allowed for convolution (MB).</li>
<li><code>no_bias::boolean, optional, default=0</code>: Whether to disable bias parameter.</li>
<li><code>layout::{None, 'NCDHW', 'NCHW', 'NCW'},optional, default='None'</code>: Set layout for input, output and weight. Empty for   default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1562' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_DeformablePSROIPooling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._contrib_DeformablePSROIPooling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_DeformablePSROIPooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_contrib_DeformablePSROIPooling(data, rois, trans, spatial_scale, output_dim, group_size, pooled_size, part_size, sample_per_part, trans_std, no_trans)
</code></pre>

<p>Performs deformable position-sensitive region-of-interest pooling on inputs. The DeformablePSROIPooling operation is described in https://arxiv.org/abs/1703.06211 .batch_size will change to the number of region bounding boxes after DeformablePSROIPooling</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::SymbolicNode</code>: Input data to the pooling operator, a 4D Feature maps</li>
<li><code>rois::SymbolicNode</code>: Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]]. (x1, y1) and (x2, y2) are top left and down right corners of designated region of interest. batch_index indicates the index of corresponding image in the input data</li>
<li><code>trans::SymbolicNode</code>: transition parameter</li>
<li><code>spatial_scale::float, required</code>: Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</li>
<li><code>output_dim::int, required</code>: fix output dim</li>
<li><code>group_size::int, required</code>: fix group size</li>
<li><code>pooled_size::int, required</code>: fix pooled size</li>
<li><code>part_size::int, optional, default='0'</code>: fix part size</li>
<li><code>sample_per_part::int, optional, default='1'</code>: fix samples per part</li>
<li><code>trans_std::float, optional, default=0</code>: fix transition std</li>
<li><code>no_trans::boolean, optional, default=0</code>: Whether to disable trans parameter.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1512' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_MultiBoxDetection-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._contrib_MultiBoxDetection-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_MultiBoxDetection</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_contrib_MultiBoxDetection(cls_prob, loc_pred, anchor, clip, threshold, background_id, nms_threshold, force_suppress, variances, nms_topk)
</code></pre>

<p>Convert multibox detection predictions.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>cls_prob::NDArray-or-SymbolicNode</code>: Class probabilities.</li>
<li><code>loc_pred::NDArray-or-SymbolicNode</code>: Location regression predictions.</li>
<li><code>anchor::NDArray-or-SymbolicNode</code>: Multibox prior anchor boxes</li>
<li><code>clip::boolean, optional, default=1</code>: Clip out-of-boundary boxes.</li>
<li><code>threshold::float, optional, default=0.01</code>: Threshold to be a positive prediction.</li>
<li><code>background_id::int, optional, default='0'</code>: Background id.</li>
<li><code>nms_threshold::float, optional, default=0.5</code>: Non-maximum suppression threshold.</li>
<li><code>force_suppress::boolean, optional, default=0</code>: Suppress all detections regardless of class_id.</li>
<li><code>variances::tuple of &lt;float&gt;, optional, default=[0.1,0.1,0.2,0.2]</code>: Variances to be decoded from box regression output.</li>
<li><code>nms_topk::int, optional, default='-1'</code>: Keep maximum top k detections before nms, -1 for no limit.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1509' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_MultiBoxPrior-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._contrib_MultiBoxPrior-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_MultiBoxPrior</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_contrib_MultiBoxPrior(data, sizes, ratios, clip, steps, offsets)
</code></pre>

<p>Generate prior(anchor) boxes from data, sizes and ratios.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data.</li>
<li><code>sizes::tuple of &lt;float&gt;, optional, default=[1]</code>: List of sizes of generated MultiBoxPriores.</li>
<li><code>ratios::tuple of &lt;float&gt;, optional, default=[1]</code>: List of aspect ratios of generated MultiBoxPriores.</li>
<li><code>clip::boolean, optional, default=0</code>: Whether to clip out-of-boundary boxes.</li>
<li><code>steps::tuple of &lt;float&gt;, optional, default=[-1,-1]</code>: Priorbox step across y and x, -1 for auto calculation.</li>
<li><code>offsets::tuple of &lt;float&gt;, optional, default=[0.5,0.5]</code>: Priorbox center offsets, y and x respectively</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1501' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_MultiBoxTarget-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._contrib_MultiBoxTarget-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_MultiBoxTarget</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_contrib_MultiBoxTarget(anchor, label, cls_pred, overlap_threshold, ignore_label, negative_mining_ratio, negative_mining_thresh, minimum_negative_samples, variances)
</code></pre>

<p>Compute Multibox training targets</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>anchor::NDArray-or-SymbolicNode</code>: Generated anchor boxes.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Object detection labels.</li>
<li><code>cls_pred::NDArray-or-SymbolicNode</code>: Class predictions.</li>
<li><code>overlap_threshold::float, optional, default=0.5</code>: Anchor-GT overlap threshold to be regarded as a positive match.</li>
<li><code>ignore_label::float, optional, default=-1</code>: Label for ignored anchors.</li>
<li><code>negative_mining_ratio::float, optional, default=-1</code>: Max negative to positive samples ratio, use -1 to disable mining</li>
<li><code>negative_mining_thresh::float, optional, default=0.5</code>: Threshold used for negative mining.</li>
<li><code>minimum_negative_samples::int, optional, default='0'</code>: Minimum number of negative samples.</li>
<li><code>variances::tuple of &lt;float&gt;, optional, default=[0.1,0.1,0.2,0.2]</code>: Variances to be encoded in box regression target.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1507' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_MultiProposal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._contrib_MultiProposal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_MultiProposal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_contrib_MultiProposal(cls_score, bbox_pred, im_info, rpn_pre_nms_top_n, rpn_post_nms_top_n, threshold, rpn_min_size, scales, ratios, feature_stride, output_score, iou_loss)
</code></pre>

<p>Generate region proposals via RPN</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>cls_score::NDArray-or-SymbolicNode</code>: Score of how likely proposal is object.</li>
<li><code>bbox_pred::NDArray-or-SymbolicNode</code>: BBox Predicted deltas from anchors for proposals</li>
<li><code>im_info::NDArray-or-SymbolicNode</code>: Image size and scale.</li>
<li><code>rpn_pre_nms_top_n::int, optional, default='6000'</code>: Number of top scoring boxes to keep after applying NMS to RPN proposals</li>
<li><code>rpn_post_nms_top_n::int, optional, default='300'</code>: Overlap threshold used for non-maximumsuppresion(suppress boxes with IoU &gt;= this threshold</li>
<li><code>threshold::float, optional, default=0.7</code>: NMS value, below which to suppress.</li>
<li><code>rpn_min_size::int, optional, default='16'</code>: Minimum height or width in proposal</li>
<li><code>scales::tuple of &lt;float&gt;, optional, default=[4,8,16,32]</code>: Used to generate anchor windows by enumerating scales</li>
<li><code>ratios::tuple of &lt;float&gt;, optional, default=[0.5,1,2]</code>: Used to generate anchor windows by enumerating ratios</li>
<li><code>feature_stride::int, optional, default='16'</code>: The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride's prior to this layer.</li>
<li><code>output_score::boolean, optional, default=0</code>: Add score to outputs</li>
<li><code>iou_loss::boolean, optional, default=0</code>: Usage of IoU Loss</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1513' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_PSROIPooling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._contrib_PSROIPooling-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_PSROIPooling</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_contrib_PSROIPooling(data, rois, spatial_scale, output_dim, pooled_size, group_size)
</code></pre>

<p>Performs region-of-interest pooling on inputs. Resize bounding box coordinates by spatial_scale and crop input feature maps accordingly. The cropped feature maps are pooled by max pooling to a fixed size output indicated by pooled_size. batch_size will change to the number of region bounding boxes after PSROIPooling</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::SymbolicNode</code>: Input data to the pooling operator, a 4D Feature maps</li>
<li><code>rois::SymbolicNode</code>: Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]]. (x1, y1) and (x2, y2) are top left and down right corners of designated region of interest. batch_index indicates the index of corresponding image in the input data</li>
<li><code>spatial_scale::float, required</code>: Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</li>
<li><code>output_dim::int, required</code>: fix output dim</li>
<li><code>pooled_size::int, required</code>: fix pooled size</li>
<li><code>group_size::int, optional, default='0'</code>: fix group size</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1501' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_Proposal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._contrib_Proposal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_Proposal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_contrib_Proposal(cls_score, bbox_pred, im_info, rpn_pre_nms_top_n, rpn_post_nms_top_n, threshold, rpn_min_size, scales, ratios, feature_stride, output_score, iou_loss)
</code></pre>

<p>Generate region proposals via RPN</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>cls_score::NDArray-or-SymbolicNode</code>: Score of how likely proposal is object.</li>
<li><code>bbox_pred::NDArray-or-SymbolicNode</code>: BBox Predicted deltas from anchors for proposals</li>
<li><code>im_info::NDArray-or-SymbolicNode</code>: Image size and scale.</li>
<li><code>rpn_pre_nms_top_n::int, optional, default='6000'</code>: Number of top scoring boxes to keep after applying NMS to RPN proposals</li>
<li><code>rpn_post_nms_top_n::int, optional, default='300'</code>: Overlap threshold used for non-maximumsuppresion(suppress boxes with IoU &gt;= this threshold</li>
<li><code>threshold::float, optional, default=0.7</code>: NMS value, below which to suppress.</li>
<li><code>rpn_min_size::int, optional, default='16'</code>: Minimum height or width in proposal</li>
<li><code>scales::tuple of &lt;float&gt;, optional, default=[4,8,16,32]</code>: Used to generate anchor windows by enumerating scales</li>
<li><code>ratios::tuple of &lt;float&gt;, optional, default=[0.5,1,2]</code>: Used to generate anchor windows by enumerating ratios</li>
<li><code>feature_stride::int, optional, default='16'</code>: The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride's prior to this layer.</li>
<li><code>output_score::boolean, optional, default=0</code>: Add score to outputs</li>
<li><code>iou_loss::boolean, optional, default=0</code>: Usage of IoU Loss</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1513' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_SparseEmbedding-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._contrib_SparseEmbedding-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_SparseEmbedding</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_contrib_SparseEmbedding(data, weight, input_dim, output_dim, dtype)
</code></pre>

<p>Maps integer indices to vector representations (embeddings).</p>
<p>This operator maps words to real-valued vectors in a high-dimensional space, called word embeddings. These embeddings can capture semantic and syntactic properties of the words. For example, it has been noted that in the learned embedding spaces, similar words tend to be close to each other and dissimilar words far apart.</p>
<p>For an input array of shape (d1, ..., dK), the shape of an output array is (d1, ..., dK, output_dim). All the input values should be integers in the range [0, input_dim).</p>
<p>If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be (ip0, op0).</p>
<p>The storage type of weight must be <code>row_sparse</code>, and the gradient of the weight will be of <code>row_sparse</code> storage type, too.</p>
<p>.. Note::</p>
<pre><code>`SparseEmbedding` is designed for the use case where `input_dim` is very large (e.g. 100k).
The operator is available on both CPU and GPU.
</code></pre>

<p>Examples::</p>
<p>input_dim = 4   output_dim = 5</p>
<p>// Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)   y = [[  0.,   1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.,   9.],        [ 10.,  11.,  12.,  13.,  14.],        [ 15.,  16.,  17.,  18.,  19.]]</p>
<p>// Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]   x = [[ 1.,  3.],        [ 0.,  2.]]</p>
<p>// Mapped input x to its vector representation y.   SparseEmbedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],                                  [ 15.,  16.,  17.,  18.,  19.]],</p>
<pre><code>                            [[  0.,   1.,   2.,   3.,   4.],
                             [ 10.,  11.,  12.,  13.,  14.]]]
</code></pre>

<p>Defined in src/operator/tensor/indexing_op.cc:L254</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array to the embedding operator.</li>
<li><code>weight::NDArray-or-SymbolicNode</code>: The embedding weight matrix.</li>
<li><code>input_dim::int, required</code>: Vocabulary size of the input indices.</li>
<li><code>output_dim::int, required</code>: Dimension of the embedding vectors.</li>
<li><code>dtype::{'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='float32'</code>: Data type of weight.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1545' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_count_sketch-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._contrib_count_sketch-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_count_sketch</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_contrib_count_sketch(data, h, s, out_dim, processing_batch_size)
</code></pre>

<p>Apply CountSketch to input: map a d-dimension data to k-dimension data"</p>
<p>.. note:: <code>count_sketch</code> is only available on GPU.</p>
<p>Assume input data has shape (N, d), sign hash table s has shape (N, d), index hash table h has shape (N, d) and mapping dimension out_dim = k, each element in s is either +1 or -1, each element in h is random integer from 0 to k-1. Then the operator computs:</p>
<p>.. math::    out[h[i]] += data[i] * s[i]</p>
<p>Example::</p>
<p>out_dim = 5    x = [[1.2, 2.5, 3.4],[3.2, 5.7, 6.6]]    h = [[0, 3, 4]]    s = [[1, -1, 1]]    mx.contrib.ndarray.count_sketch(data=x, h=h, s=s, out_dim = 5) = [[1.2, 0, 0, -2.5, 3.4],                                                                      [3.2, 0, 0, -5.7, 6.6]]</p>
<p>Defined in src/operator/contrib/count_sketch.cc:L67</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the CountSketchOp.</li>
<li><code>h::NDArray-or-SymbolicNode</code>: The index vector</li>
<li><code>s::NDArray-or-SymbolicNode</code>: The sign vector</li>
<li><code>out_dim::int, required</code>: The output dimension.</li>
<li><code>processing_batch_size::int, optional, default='32'</code>: How many sketch vectors to process at one time.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1522' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_ctc_loss-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._contrib_ctc_loss-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_ctc_loss</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_contrib_ctc_loss(data, label, data_lengths, label_lengths, use_data_lengths, use_label_lengths, blank_label)
</code></pre>

<p>_contrib_ctc_loss is an alias of _contrib_CTCLoss.</p>
<p>Connectionist Temporal Classification Loss.</p>
<p>The shapes of the inputs and outputs:</p>
<ul>
<li><strong>data</strong>: <code>(sequence_length, batch_size, alphabet_size)</code></li>
<li><strong>label</strong>: <code>(batch_size, label_sequence_length)</code></li>
<li><strong>out</strong>: <code>(batch_size)</code></li>
</ul>
<p>The <code>data</code> tensor consists of sequences of activation vectors (without applying softmax), with i-th channel in the last dimension corresponding to i-th label for i between 0 and alphabet_size-1 (i.e always 0-indexed). Alphabet size should include one additional value reserved for blank label. When <code>blank_label</code> is $"first"$, the $0$-th channel is be reserved for activation of blank label, or otherwise if it is "last", $(alphabet_size-1)$-th channel should be reserved for blank label.</p>
<p>$label$ is an index matrix of integers. When <code>blank_label</code> is $"first"$, the value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise, when <code>blank_label</code> is $"last"$, the value <code>(alphabet_size-1)</code> is reserved for blank label.</p>
<p>If a sequence of labels is shorter than <em>label_sequence_length</em>, use the special padding value at the end of the sequence to conform it to the correct length. The padding value is <code>0</code> when <code>blank_label</code> is $"first"$, and <code>-1</code> otherwise.</p>
<p>For example, suppose the vocabulary is <code>[a, b, c]</code>, and in one batch we have three sequences 'ba', 'cbb', and 'abac'. When <code>blank_label</code> is $"first"$, we can index the labels as <code>{'a': 1, 'b': 2, 'c': 3}</code>, and we reserve the 0-th channel for blank label in data tensor. The resulting <code>label</code> tensor should be padded to be::</p>
<p>[[2, 1, 0, 0], [3, 2, 2, 0], [1, 2, 1, 3]]</p>
<p>When <code>blank_label</code> is $"last"$, we can index the labels as <code>{'a': 0, 'b': 1, 'c': 2}</code>, and we reserve the channel index 3 for blank label in data tensor. The resulting <code>label</code> tensor should be padded to be::</p>
<p>[[1, 0, -1, -1], [2, 1, 1, -1], [0, 1, 0, 2]]</p>
<p>$out$ is a list of CTC loss values, one per example in the batch.</p>
<p>See <em>Connectionist Temporal Classification: Labelling Unsegmented Sequence Data with Recurrent Neural Networks</em>, A. Graves <em>et al</em>. for more information on the definition and the algorithm.</p>
<p>Defined in src/operator/contrib/ctc_loss.cc:L115</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the ctc_loss op.</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Ground-truth labels for the loss.</li>
<li><code>data_lengths::NDArray-or-SymbolicNode</code>: Lengths of data for each of the samples. Only required when use_data_lengths is true.</li>
<li><code>label_lengths::NDArray-or-SymbolicNode</code>: Lengths of labels for each of the samples. Only required when use_label_lengths is true.</li>
<li><code>use_data_lengths::boolean, optional, default=0</code>: Whether the data lenghts are decided by <code>data_lengths</code>. If false, the lengths are equal to the max sequence length.</li>
<li><code>use_label_lengths::boolean, optional, default=0</code>: Whether the label lenghts are decided by <code>label_lengths</code>, or derived from <code>padding_mask</code>. If false, the lengths are derived from the first occurrence of the value of <code>padding_mask</code>. The value of <code>padding_mask</code> is $0$ when first CTC label is reserved for blank, and $-1$ when last label is reserved for blank. See <code>blank_label</code>.</li>
<li><code>blank_label::{'first', 'last'},optional, default='first'</code>: Set the label that is reserved for blank label.If "first", 0-th label is reserved, and label values for tokens in the vocabulary are between $1$ and $alphabet_size-1$, and the padding mask is $-1$. If "last", last label value $alphabet_size-1$ is reserved for blank label instead, and label values for tokens in the vocabulary are between $0$ and $alphabet_size-2$, and the padding mask is $0$.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1550' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_dequantize-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._contrib_dequantize-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_dequantize</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_contrib_dequantize(input, min_range, max_range, out_type)
</code></pre>

<p>Dequantize the input tensor into a float tensor. [min_range, max_range] are scalar floats that spcify the range for the output data.</p>
<p>Each value of the tensor will undergo the following:</p>
<p><code>out[i] = min_range + (in[i] * (max_range - min_range) / range(INPUT_TYPE))</code></p>
<p>here <code>range(T) = numeric_limits&lt;T&gt;::max() - numeric_limits&lt;T&gt;::min()</code></p>
<p>Defined in src/operator/contrib/dequantize.cc:L41</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>input::NDArray-or-SymbolicNode</code>: A ndarray/symbol of type <code>uint8</code></li>
<li><code>min_range::NDArray-or-SymbolicNode</code>: The minimum scalar value possibly produced for the input</li>
<li><code>max_range::NDArray-or-SymbolicNode</code>: The maximum scalar value possibly produced for the input</li>
<li><code>out_type::{'float32'}, required</code>: Output data type.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_fft-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._contrib_fft-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_fft</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_contrib_fft(data, compute_size)
</code></pre>

<p>Apply 1D FFT to input"</p>
<p>.. note:: <code>fft</code> is only available on GPU.</p>
<p>Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d), data can only be real numbers. The output data has shape: (N, 2<em>d) or (N1, N2, N3, 2</em>d). The format is: [real0, imag0, real1, imag1, ...].</p>
<p>Example::</p>
<p>data = np.random.normal(0,1,(3,4))    out = mx.contrib.ndarray.fft(data = mx.nd.array(data,ctx = mx.gpu(0)))</p>
<p>Defined in src/operator/contrib/fft.cc:L56</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the FFTOp.</li>
<li><code>compute_size::int, optional, default='128'</code>: Maximum size of sub-batch to be forwarded at one time</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1507' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_ifft-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._contrib_ifft-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_ifft</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_contrib_ifft(data, compute_size)
</code></pre>

<p>Apply 1D ifft to input"</p>
<p>.. note:: <code>ifft</code> is only available on GPU.</p>
<p>Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d). Data is in format: [real0, imag0, real1, imag1, ...]. Last dimension must be an even number. The output data has shape: (N, d/2) or (N1, N2, N3, d/2). It is only the real part of the result.</p>
<p>Example::</p>
<p>data = np.random.normal(0,1,(3,4))    out = mx.contrib.ndarray.ifft(data = mx.nd.array(data,ctx = mx.gpu(0)))</p>
<p>Defined in src/operator/contrib/ifft.cc:L58</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data to the IFFTOp.</li>
<li><code>compute_size::int, optional, default='128'</code>: Maximum size of sub-batch to be forwarded at one time</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._contrib_quantize-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._contrib_quantize-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._contrib_quantize</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_contrib_quantize(input, min_range, max_range, out_type)
</code></pre>

<p>Quantize a input tensor from float to <code>out_type</code>, with user-specified <code>min_range</code> and <code>max_range</code>.</p>
<p>[min_range, max_range] are scalar floats that spcify the range for the input data. Each value of the tensor will undergo the following:</p>
<p><code>out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range)</code></p>
<p>here <code>range(T) = numeric_limits&lt;T&gt;::max() - numeric_limits&lt;T&gt;::min()</code></p>
<p>Defined in src/operator/contrib/quantize.cc:L41</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>input::NDArray-or-SymbolicNode</code>: A ndarray/symbol of type <code>float32</code></li>
<li><code>min_range::NDArray-or-SymbolicNode</code>: The minimum scalar value possibly produced for the input</li>
<li><code>max_range::NDArray-or-SymbolicNode</code>: The maximum scalar value possibly produced for the input</li>
<li><code>out_type::{'uint8'},optional, default='uint8'</code>: Output data type.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._copy-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._copy-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._copy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_copy(data)
</code></pre>

<p>Returns a copy of the input.</p>
<p>From:src/operator/tensor/elemwise_unary_op_basic.cc:112</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._copyto-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._copyto-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._copyto</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_copyto(data)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray</code>: input data</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1491' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._crop_assign-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._crop_assign-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._crop_assign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_crop_assign(lhs, rhs, begin, end, step)
</code></pre>

<p>_crop_assign is an alias of _slice_assign.</p>
<p>Assign the rhs to a cropped subset of lhs.</p>
<p><strong>Requirements</strong></p>
<ul>
<li>output should be explicitly given and be the same as lhs.</li>
<li>lhs and rhs are of the same data type, and on the same device.</li>
</ul>
<p>From:src/operator/tensor/matrix_op.cc:381</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: value to assign</li>
<li><code>begin::Shape(tuple), required</code>: starting indices for the slice operation, supports negative indices.</li>
<li><code>end::Shape(tuple), required</code>: ending indices for the slice operation, supports negative indices.</li>
<li><code>step::Shape(tuple), optional, default=[]</code>: step for the slice operation, supports negative values.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1509' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._crop_assign_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._crop_assign_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._crop_assign_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_crop_assign_scalar(data, scalar, begin, end, step)
</code></pre>

<p>_crop_assign_scalar is an alias of _slice_assign_scalar.</p>
<p>(Assign the scalar to a cropped subset of the input.</p>
<p><strong>Requirements</strong></p>
<ul>
<li>output should be explicitly given and be the same as input</li>
</ul>
<p>)</p>
<p>From:src/operator/tensor/matrix_op.cc:406</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>scalar::float, optional, default=0</code>: The scalar value for assignment.</li>
<li><code>begin::Shape(tuple), required</code>: starting indices for the slice operation, supports negative indices.</li>
<li><code>end::Shape(tuple), required</code>: ending indices for the slice operation, supports negative indices.</li>
<li><code>step::Shape(tuple), optional, default=[]</code>: step for the slice operation, supports negative values.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._cvcopyMakeBorder-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._cvcopyMakeBorder-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._cvcopyMakeBorder</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_cvcopyMakeBorder(src, top, bot, left, right, type, value, values)
</code></pre>

<p>Pad image border with OpenCV. </p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>src::NDArray</code>: source image</li>
<li><code>top::int, required</code>: Top margin.</li>
<li><code>bot::int, required</code>: Bottom margin.</li>
<li><code>left::int, required</code>: Left margin.</li>
<li><code>right::int, required</code>: Right margin.</li>
<li><code>type::int, optional, default='0'</code>: Filling type (default=cv2.BORDER_CONSTANT).</li>
<li><code>value::double, optional, default=0</code>: (Deprecated! Use $values$ instead.) Fill with single value.</li>
<li><code>values::tuple of &lt;double&gt;, optional, default=[]</code>: Fill with value(RGB[A] or gray), up to 4 channels.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1506' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._cvimdecode-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._cvimdecode-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._cvimdecode</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_cvimdecode(buf, flag, to_rgb)
</code></pre>

<p>Decode image with OpenCV.  Note: return image in RGB by default, instead of OpenCV's default BGR.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>buf::NDArray</code>: Buffer containing binary encoded image</li>
<li><code>flag::int, optional, default='1'</code>: Convert decoded image to grayscale (0) or color (1).</li>
<li><code>to_rgb::boolean, optional, default=1</code>: Whether to convert decoded image to mxnet's default RGB format (instead of opencv's default BGR).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1496' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._cvimread-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._cvimread-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._cvimread</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_cvimread(filename, flag, to_rgb)
</code></pre>

<p>Read and decode image with OpenCV.  Note: return image in RGB by default, instead of OpenCV's default BGR.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>filename::string, required</code>: Name of the image file to be loaded.</li>
<li><code>flag::int, optional, default='1'</code>: Convert decoded image to grayscale (0) or color (1).</li>
<li><code>to_rgb::boolean, optional, default=1</code>: Whether to convert decoded image to mxnet's default RGB format (instead of opencv's default BGR).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1496' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._cvimresize-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._cvimresize-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._cvimresize</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_cvimresize(src, w, h, interp)
</code></pre>

<p>Resize image with OpenCV. </p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>src::NDArray</code>: source image</li>
<li><code>w::int, required</code>: Width of resized image.</li>
<li><code>h::int, required</code>: Height of resized image.</li>
<li><code>interp::int, optional, default='1'</code>: Interpolation method (default=cv2.INTER_LINEAR).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1498' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._div_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._div_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._div_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_div_scalar(data, scalar)
</code></pre>

<p>Divide an array with a scalar.</p>
<p>$_div_scalar$ only operates on data array of input if input is sparse.</p>
<p>For example, if input of shape (100, 100) has only 2 non zero elements, i.e. input.data = [5, 6], scalar = nan, it will result output.data = [nan, nan] instead of 10000 nans.</p>
<p>Defined in src/operator/tensor/elemwise_binary_scalar_op_basic.cc:L164</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1503' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._docsig-Tuple{Symbol,Expr}' href='#MXNet.mx._docsig-Tuple{Symbol,Expr}'>#</a>
<strong><code>MXNet.mx._docsig</code></strong> &mdash; <em>Method</em>.</p>
<p>Generate docstring from function signature</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1074-L1076' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_equal(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._equal_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._equal_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._equal_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_equal_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._get_ndarray_function_def-Tuple{String}' href='#MXNet.mx._get_ndarray_function_def-Tuple{String}'>#</a>
<strong><code>MXNet.mx._get_ndarray_function_def</code></strong> &mdash; <em>Method</em>.</p>
<p>The libxmnet APIs are automatically imported from <code>libmxnet.so</code>. The functions listed here operate on <code>NDArray</code> objects. The arguments to the functions are typically ordered as</p>
<pre><code class="julia">  func_name(arg_in1, arg_in2, ..., scalar1, scalar2, ..., arg_out1, arg_out2, ...)
</code></pre>

<p>unless <code>NDARRAY_ARG_BEFORE_SCALAR</code> is not set. In this case, the scalars are put before the input arguments:</p>
<pre><code class="julia">  func_name(scalar1, scalar2, ..., arg_in1, arg_in2, ..., arg_out1, arg_out2, ...)
</code></pre>

<p>If <code>ACCEPT_EMPTY_MUTATE_TARGET</code> is set. An overloaded function without the output arguments will also be defined:</p>
<pre><code class="julia">  func_name(arg_in1, arg_in2, ..., scalar1, scalar2, ...)
</code></pre>

<p>Upon calling, the output arguments will be automatically initialized with empty NDArrays.</p>
<p>Those functions always return the output arguments. If there is only one output (the typical situation), that object (<code>NDArray</code>) is returned. Otherwise, a tuple containing all the outputs will be returned.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1325-L1350' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._grad_add-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._grad_add-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._grad_add</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_grad_add(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._greater-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._greater-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._greater</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_greater(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._greater_equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._greater_equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._greater_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_greater_equal(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._greater_equal_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._greater_equal_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._greater_equal_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_greater_equal_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._greater_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._greater_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._greater_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_greater_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._hypot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._hypot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._hypot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_hypot(lhs, rhs)
</code></pre>

<p>Given the "legs" of a right triangle, return its hypotenuse.</p>
<p>Defined in src/operator/tensor/elemwise_binary_op_extended.cc:L79</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1497' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._hypot_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._hypot_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._hypot_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_hypot_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._identity_with_attr_like_rhs-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._identity_with_attr_like_rhs-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._identity_with_attr_like_rhs</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_identity_with_attr_like_rhs(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input.</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._imdecode-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._imdecode-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._imdecode</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_imdecode(mean, index, x0, y0, x1, y1, c, size)
</code></pre>

<p>Decode an image, clip to (x0, y0, x1, y1), subtract mean, and write to buffer</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>mean::NDArray-or-SymbolicNode</code>: image mean</li>
<li><code>index::int</code>: buffer position for output</li>
<li><code>x0::int</code>: x0</li>
<li><code>y0::int</code>: y0</li>
<li><code>x1::int</code>: x1</li>
<li><code>y1::int</code>: y1</li>
<li><code>c::int</code>: channel</li>
<li><code>size::int</code>: length of str_img</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1505' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._lesser-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._lesser-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._lesser</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_lesser(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._lesser_equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._lesser_equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._lesser_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_lesser_equal(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._lesser_equal_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._lesser_equal_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._lesser_equal_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_lesser_equal_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._lesser_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._lesser_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._lesser_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_lesser_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_gelqf-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._linalg_gelqf-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_gelqf</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_linalg_gelqf(A)
</code></pre>

<p>LQ factorization for general matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, we compute the LQ factorization (LAPACK <em>gelqf</em>, followed by <em>orglq</em>). <em>A</em> must have shape <em>(x, y)</em> with <em>x &lt;= y</em>, and must have full rank <em>=x</em>. The LQ factorization consists of <em>L</em> with shape <em>(x, x)</em> and <em>Q</em> with shape <em>(x, y)</em>, so that:</p>
<p><em>A</em> = <em>L</em> * <em>Q</em></p>
<p>Here, <em>L</em> is lower triangular (upper triangle equal to zero) with nonzero diagonal, and <em>Q</em> is row-orthonormal, meaning that</p>
<p><em>Q</em> * <em>Q</em>\ :sup:<code>T</code></p>
<p>is equal to the identity matrix of shape <em>(x, x)</em>.</p>
<p>If <em>n&gt;2</em>, <em>gelqf</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>// Single LQ factorization    A = [[1., 2., 3.], [4., 5., 6.]]    Q, L = gelqf(A)    Q = [[-0.26726124, -0.53452248, -0.80178373],         [0.87287156, 0.21821789, -0.43643578]]    L = [[-3.74165739, 0.],         [-8.55235974, 1.96396101]]</p>
<p>// Batch LQ factorization    A = [[[1., 2., 3.], [4., 5., 6.]],         [[7., 8., 9.], [10., 11., 12.]]]    Q, L = gelqf(A)    Q = [[[-0.26726124, -0.53452248, -0.80178373],          [0.87287156, 0.21821789, -0.43643578]],         [[-0.50257071, -0.57436653, -0.64616234],          [0.7620735, 0.05862104, -0.64483142]]]    L = [[[-3.74165739, 0.],          [-8.55235974, 1.96396101]],         [[-13.92838828, 0.],          [-19.09768702, 0.52758934]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L529</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices to be factorized</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1537' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_gemm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._linalg_gemm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_gemm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_linalg_gemm(A, B, C, transpose_a, transpose_b, alpha, beta)
</code></pre>

<p>Performs general matrix multiplication and accumulation. Input are tensors <em>A</em>, <em>B</em>, <em>C</em>, each of dimension <em>n &gt;= 2</em> and having the same shape on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, the BLAS3 function <em>gemm</em> is performed:</p>
<p><em>out</em> = <em>alpha</em> * <em>op</em>\ (<em>A</em>) * <em>op</em>\ (<em>B</em>) + <em>beta</em> * <em>C</em></p>
<p>Here, <em>alpha</em> and <em>beta</em> are scalar parameters, and <em>op()</em> is either the identity or matrix transposition (depending on <em>transpose_a</em>, <em>transpose_b</em>).</p>
<p>If <em>n&gt;2</em>, <em>gemm</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>// Single matrix multiply-add    A = [[1.0, 1.0], [1.0, 1.0]]    B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]    C = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]    gemm(A, B, C, transpose_b=True, alpha=2.0, beta=10.0)            = [[14.0, 14.0, 14.0], [14.0, 14.0, 14.0]]</p>
<p>// Batch matrix multiply-add    A = [[[1.0, 1.0]], [[0.1, 0.1]]]    B = [[[1.0, 1.0]], [[0.1, 0.1]]]    C = [[[10.0]], [[0.01]]]    gemm(A, B, C, transpose_b=True, alpha=2.0 , beta=10.0)            = [[[104.0]], [[0.14]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L69</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>B::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>C::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>transpose_a::boolean, optional, default=0</code>: Multiply with transposed of first input (A).</li>
<li><code>transpose_b::boolean, optional, default=0</code>: Multiply with transposed of second input (B).</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor multiplied with A*B.</li>
<li><code>beta::double, optional, default=1</code>: Scalar factor multiplied with C.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1536' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_gemm2-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._linalg_gemm2-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_gemm2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_linalg_gemm2(A, B, transpose_a, transpose_b, alpha)
</code></pre>

<p>Performs general matrix multiplication. Input are tensors <em>A</em>, <em>B</em>, each of dimension <em>n &gt;= 2</em> and having the same shape on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, the BLAS3 function <em>gemm</em> is performed:</p>
<p><em>out</em> = <em>alpha</em> * <em>op</em>\ (<em>A</em>) * <em>op</em>\ (<em>B</em>)</p>
<p>Here <em>alpha</em> is a scalar parameter and <em>op()</em> is either the identity or the matrix transposition (depending on <em>transpose_a</em>, <em>transpose_b</em>).</p>
<p>If <em>n&gt;2</em>, <em>gemm</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>// Single matrix multiply    A = [[1.0, 1.0], [1.0, 1.0]]    B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]    gemm2(A, B, transpose_b=True, alpha=2.0)             = [[4.0, 4.0, 4.0], [4.0, 4.0, 4.0]]</p>
<p>// Batch matrix multiply    A = [[[1.0, 1.0]], [[0.1, 0.1]]]    B = [[[1.0, 1.0]], [[0.1, 0.1]]]    gemm2(A, B, transpose_b=True, alpha=2.0)            = [[[4.0]], [[0.04 ]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L128</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>B::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>transpose_a::boolean, optional, default=0</code>: Multiply with transposed of first input (A).</li>
<li><code>transpose_b::boolean, optional, default=0</code>: Multiply with transposed of second input (B).</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor multiplied with A*B.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1530' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_potrf-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._linalg_potrf-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_potrf</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_linalg_potrf(A)
</code></pre>

<p>Performs Cholesky factorization of a symmetric positive-definite matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, the Cholesky factor <em>L</em> of the symmetric, positive definite matrix <em>A</em> is computed. <em>L</em> is lower triangular (entries of upper triangle are all zero), has positive diagonal entries, and:</p>
<p><em>A</em> = <em>L</em> * <em>L</em>\ :sup:<code>T</code></p>
<p>If <em>n&gt;2</em>, <em>potrf</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>// Single matrix factorization    A = [[4.0, 1.0], [1.0, 4.25]]    potrf(A) = [[2.0, 0], [0.5, 2.0]]</p>
<p>// Batch matrix factorization    A = [[[4.0, 1.0], [1.0, 4.25]], [[16.0, 4.0], [4.0, 17.0]]]    potrf(A) = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L178</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices to be decomposed</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1516' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_potri-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._linalg_potri-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_potri</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_linalg_potri(A)
</code></pre>

<p>Performs matrix inversion from a Cholesky factorization. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> is a lower triangular matrix (entries of upper triangle are all zero) with positive diagonal. We compute:</p>
<p><em>out</em> = <em>A</em>\ :sup:<code>-T</code> * <em>A</em>\ :sup:<code>-1</code></p>
<p>In other words, if <em>A</em> is the Cholesky factor of a symmetric positive definite matrix <em>B</em> (obtained by <em>potrf</em>), then</p>
<p><em>out</em> = <em>B</em>\ :sup:<code>-1</code></p>
<p>If <em>n&gt;2</em>, <em>potri</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>.. note:: Use this operator only if you are certain you need the inverse of <em>B</em>, and           cannot use the Cholesky factor <em>A</em> (<em>potrf</em>), together with backsubstitution           (<em>trsm</em>). The latter is numerically much safer, and also cheaper.</p>
<p>Examples::</p>
<p>// Single matrix inverse    A = [[2.0, 0], [0.5, 2.0]]    potri(A) = [[0.26563, -0.0625], [-0.0625, 0.25]]</p>
<p>// Batch matrix inverse    A = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]    potri(A) = [[[0.26563, -0.0625], [-0.0625, 0.25]],                [[0.06641, -0.01562], [-0.01562, 0,0625]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L236</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of lower triangular matrices</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1525' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_sumlogdiag-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._linalg_sumlogdiag-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_sumlogdiag</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_linalg_sumlogdiag(A)
</code></pre>

<p>Computes the sum of the logarithms of the diagonal elements of a square matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> must be square with positive diagonal entries. We sum the natural logarithms of the diagonal elements, the result has shape (1,).</p>
<p>If <em>n&gt;2</em>, <em>sumlogdiag</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>// Single matrix reduction    A = [[1.0, 1.0], [1.0, 7.0]]    sumlogdiag(A) = [1.9459]</p>
<p>// Batch matrix reduction    A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]    sumlogdiag(A) = [1.9459, 3.9318]</p>
<p>Defined in src/operator/tensor/la_op.cc:L405</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrices</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1513' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_syevd-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._linalg_syevd-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_syevd</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_linalg_syevd(A)
</code></pre>

<p>Eigendecomposition for symmetric matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> must be symmetric, of shape <em>(x, x)</em>. We compute the eigendecomposition, resulting in the orthonormal matrix <em>U</em> of eigenvectors, shape <em>(x, x)</em>, and the vector <em>L</em> of eigenvalues, shape <em>(x,)</em>, so that:</p>
<p><em>U</em> * <em>A</em> = <em>diag(L)</em> * <em>U</em></p>
<p>Here:</p>
<p><em>U</em> * <em>U</em>\ :sup:<code>T</code> = <em>U</em>\ :sup:<code>T</code> * <em>U</em> = <em>I</em></p>
<p>where <em>I</em> is the identity matrix. Also, <em>L(0) &lt;= L(1) &lt;= L(2) &lt;= ...</em> (ascending order).</p>
<p>If <em>n&gt;2</em>, <em>syevd</em> is performed separately on the trailing two dimensions of <em>A</em> (batch mode). In this case, <em>U</em> has <em>n</em> dimensions like <em>A</em>, and <em>L</em> has <em>n-1</em> dimensions.</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>.. note:: Derivatives for this operator are defined only if <em>A</em> is such that all its           eigenvalues are distinct, and the eigengaps are not too small. If you need           gradients, do not apply this operator to matrices with multiple eigenvalues.</p>
<p>Examples::</p>
<p>// Single symmetric eigendecomposition    A = [[1., 2.], [2., 4.]]    U, L = syevd(A)    U = [[0.89442719, -0.4472136],         [0.4472136, 0.89442719]]    L = [0., 5.]</p>
<p>// Batch symmetric eigendecomposition    A = [[[1., 2.], [2., 4.]],         [[1., 2.], [2., 5.]]]    U, L = syevd(A)    U = [[[0.89442719, -0.4472136],          [0.4472136, 0.89442719]],         [[0.92387953, -0.38268343],          [0.38268343, 0.92387953]]]    L = [[0., 5.],         [0.17157288, 5.82842712]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L598</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices to be factorized</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1536' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_syrk-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._linalg_syrk-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_syrk</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_linalg_syrk(A, transpose, alpha)
</code></pre>

<p>Multiplication of matrix with its transpose. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, the operator performs the BLAS3 function <em>syrk</em>:</p>
<p><em>out</em> = <em>alpha</em> * <em>A</em> * <em>A</em>\ :sup:<code>T</code></p>
<p>if <em>transpose=False</em>, or</p>
<p><em>out</em> = <em>alpha</em> * <em>A</em>\ :sup:<code>T</code> \ * <em>A</em></p>
<p>if <em>transpose=True</em>.</p>
<p>If <em>n&gt;2</em>, <em>syrk</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>// Single matrix multiply    A = [[1., 2., 3.], [4., 5., 6.]]    syrk(A, alpha=1., transpose=False)             = [[14., 32.],                [32., 77.]]    syrk(A, alpha=1., transpose=True)             = [[17., 22., 27.],                [22., 29., 36.],                [27., 36., 45.]]</p>
<p>// Batch matrix multiply    A = [[[1., 1.]], [[0.1, 0.1]]]    syrk(A, alpha=2., transpose=False) = [[[4.]], [[0.04]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L461</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>transpose::boolean, optional, default=0</code>: Use transpose of input matrix.</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor to be applied to the result.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1530' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_trmm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._linalg_trmm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_trmm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_linalg_trmm(A, B, transpose, rightside, alpha)
</code></pre>

<p>Performs multiplication with a lower triangular matrix. Input are tensors <em>A</em>, <em>B</em>, each of dimension <em>n &gt;= 2</em> and having the same shape on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, <em>A</em> must be lower triangular. The operator performs the BLAS3 function <em>trmm</em>:</p>
<p><em>out</em> = <em>alpha</em> * <em>op</em>\ (<em>A</em>) * <em>B</em></p>
<p>if <em>rightside=False</em>, or</p>
<p><em>out</em> = <em>alpha</em> * <em>B</em> * <em>op</em>\ (<em>A</em>)</p>
<p>if <em>rightside=True</em>. Here, <em>alpha</em> is a scalar parameter, and <em>op()</em> is either the identity or the matrix transposition (depending on <em>transpose</em>).</p>
<p>If <em>n&gt;2</em>, <em>trmm</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>// Single triangular matrix multiply    A = [[1.0, 0], [1.0, 1.0]]    B = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]    trmm(A, B, alpha=2.0) = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]</p>
<p>// Batch triangular matrix multiply    A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]    B = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]], [[0.5, 0.5, 0.5], [0.5, 0.5, 0.5]]]    trmm(A, B, alpha=2.0) = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],                             [[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L293</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of lower triangular matrices</li>
<li><code>B::NDArray-or-SymbolicNode</code>: Tensor of matrices</li>
<li><code>transpose::boolean, optional, default=0</code>: Use transposed of the triangular matrix</li>
<li><code>rightside::boolean, optional, default=0</code>: Multiply triangular matrix from the right to non-triangular one.</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor to be applied to the result.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1535' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._linalg_trsm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._linalg_trsm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._linalg_trsm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_linalg_trsm(A, B, transpose, rightside, alpha)
</code></pre>

<p>Solves matrix equation involving a lower triangular matrix. Input are tensors <em>A</em>, <em>B</em>, each of dimension <em>n &gt;= 2</em> and having the same shape on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, <em>A</em> must be lower triangular. The operator performs the BLAS3 function <em>trsm</em>, solving for <em>out</em> in:</p>
<p><em>op</em>\ (<em>A</em>) * <em>out</em> = <em>alpha</em> * <em>B</em></p>
<p>if <em>rightside=False</em>, or</p>
<p><em>out</em> * <em>op</em>\ (<em>A</em>) = <em>alpha</em> * <em>B</em></p>
<p>if <em>rightside=True</em>. Here, <em>alpha</em> is a scalar parameter, and <em>op()</em> is either the identity or the matrix transposition (depending on <em>transpose</em>).</p>
<p>If <em>n&gt;2</em>, <em>trsm</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>// Single matrix solve    A = [[1.0, 0], [1.0, 1.0]]    B = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]    trsm(A, B, alpha=0.5) = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]</p>
<p>// Batch matrix solve    A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]    B = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],         [[4.0, 4.0, 4.0], [8.0, 8.0, 8.0]]]    trsm(A, B, alpha=0.5) = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]],                             [[2.0, 2.0, 2.0], [2.0, 2.0, 2.0]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L356</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of lower triangular matrices</li>
<li><code>B::NDArray-or-SymbolicNode</code>: Tensor of matrices</li>
<li><code>transpose::boolean, optional, default=0</code>: Use transposed of the triangular matrix</li>
<li><code>rightside::boolean, optional, default=0</code>: Multiply triangular matrix from the right to non-triangular one.</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor to be applied to the result.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1535' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._maximum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._maximum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._maximum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_maximum(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._maximum_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._maximum_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._maximum_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_maximum_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._minimum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._minimum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._minimum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_minimum(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._minimum_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._minimum_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._minimum_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_minimum_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._minus!-Tuple{MXNet.mx.NDArray,MXNet.mx.NDArray}' href='#MXNet.mx._minus!-Tuple{MXNet.mx.NDArray,MXNet.mx.NDArray}'>#</a>
<strong><code>MXNet.mx._minus!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_minus!(x::NDArray, y::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1300' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._minus-Tuple{MXNet.mx.NDArray,MXNet.mx.NDArray}' href='#MXNet.mx._minus-Tuple{MXNet.mx.NDArray,MXNet.mx.NDArray}'>#</a>
<strong><code>MXNet.mx._minus</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_minus(x::NDArray, y::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1299' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._minus_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._minus_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._minus_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_minus_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._mod!-Tuple{MXNet.mx.NDArray,MXNet.mx.NDArray}' href='#MXNet.mx._mod!-Tuple{MXNet.mx.NDArray,MXNet.mx.NDArray}'>#</a>
<strong><code>MXNet.mx._mod!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_mod!(x::NDArray, y::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1303' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._mod-Tuple{MXNet.mx.NDArray,MXNet.mx.NDArray}' href='#MXNet.mx._mod-Tuple{MXNet.mx.NDArray,MXNet.mx.NDArray}'>#</a>
<strong><code>MXNet.mx._mod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_mod(x::NDArray, y::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1302' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._mod_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._mod_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._mod_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_mod_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._mul-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._mul-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._mul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_mul(lhs, rhs)
</code></pre>

<p>_mul is an alias of elemwise_mul.</p>
<p>Multiplies arguments element-wise.</p>
<p>The storage type of $elemwise_mul$ output depends on storage types of inputs</p>
<ul>
<li>elemwise_mul(default, default) = default</li>
<li>elemwise_mul(row_sparse, row_sparse) = row_sparse</li>
<li>elemwise_mul(default, row_sparse) = default</li>
<li>elemwise_mul(row_sparse, default) = default</li>
<li>elemwise_mul(csr, csr) = csr</li>
<li>otherwise, $elemwise_mul$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1506' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._mul_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._mul_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._mul_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_mul_scalar(data, scalar)
</code></pre>

<p>Multiply an array with a scalar.</p>
<p>$_mul_scalar$ only operates on data array of input if input is sparse.</p>
<p>For example, if input of shape (100, 100) has only 2 non zero elements, i.e. input.data = [5, 6], scalar = nan, it will result output.data = [nan, nan] instead of 10000 nans.</p>
<p>Defined in src/operator/tensor/elemwise_binary_scalar_op_basic.cc:L142</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1503' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._not_equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._not_equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._not_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_not_equal(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._not_equal_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._not_equal_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._not_equal_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_not_equal_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._onehot_encode-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._onehot_encode-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._onehot_encode</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_onehot_encode(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray</code>: Left operand to the function.</li>
<li><code>rhs::NDArray</code>: Right operand to the function.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._plus!-Tuple{MXNet.mx.NDArray,MXNet.mx.NDArray}' href='#MXNet.mx._plus!-Tuple{MXNet.mx.NDArray,MXNet.mx.NDArray}'>#</a>
<strong><code>MXNet.mx._plus!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_plus!(x::NDArray, y::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1297' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._plus-Tuple{MXNet.mx.NDArray,MXNet.mx.NDArray}' href='#MXNet.mx._plus-Tuple{MXNet.mx.NDArray,MXNet.mx.NDArray}'>#</a>
<strong><code>MXNet.mx._plus</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_plus(x::NDArray, y::NDArray)
</code></pre>

<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1296' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._plus_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._plus_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._plus_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_plus_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._power-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._power-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._power</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_power(lhs, rhs)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._power_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._power_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._power_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_power_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_exponential-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._random_exponential-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._random_exponential</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_random_exponential(lam, shape, ctx, dtype)
</code></pre>

<p>Draw random samples from an exponential distribution.</p>
<p>Samples are distributed according to an exponential distribution parametrized by <em>lambda</em> (rate).</p>
<p>Example::</p>
<p>exponential(lam=4, shape=(2,2)) = [[ 0.0097189 ,  0.08999364],                                       [ 0.04146638,  0.31715935]]</p>
<p>Defined in src/operator/random/sample_op.cc:L115</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lam::float, optional, default=1</code>: Lambda parameter (rate) of the exponential distribution.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="../n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1507' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_gamma-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._random_gamma-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._random_gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_random_gamma(alpha, beta, shape, ctx, dtype)
</code></pre>

<p>Draw random samples from a gamma distribution.</p>
<p>Samples are distributed according to a gamma distribution parametrized by <em>alpha</em> (shape) and <em>beta</em> (scale).</p>
<p>Example::</p>
<p>gamma(alpha=9, beta=0.5, shape=(2,2)) = [[ 7.10486984,  3.37695289],                                             [ 3.91697288,  3.65933681]]</p>
<p>Defined in src/operator/random/sample_op.cc:L100</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>alpha::float, optional, default=1</code>: Alpha parameter (shape) of the gamma distribution.</li>
<li><code>beta::float, optional, default=1</code>: Beta parameter (scale) of the gamma distribution.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="../n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1509' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_generalized_negative_binomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._random_generalized_negative_binomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._random_generalized_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_random_generalized_negative_binomial(mu, alpha, shape, ctx, dtype)
</code></pre>

<p>Draw random samples from a generalized negative binomial distribution.</p>
<p>Samples are distributed according to a generalized negative binomial distribution parametrized by <em>mu</em> (mean) and <em>alpha</em> (dispersion). <em>alpha</em> is defined as <em>1/k</em> where <em>k</em> is the failure limit of the number of unsuccessful experiments (generalized to real numbers). Samples will always be returned as a floating point data type.</p>
<p>Example::</p>
<p>generalized_negative_binomial(mu=2.0, alpha=0.3, shape=(2,2)) = [[ 2.,  1.],                                                                     [ 6.,  4.]]</p>
<p>Defined in src/operator/random/sample_op.cc:L168</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>mu::float, optional, default=1</code>: Mean of the negative binomial distribution.</li>
<li><code>alpha::float, optional, default=1</code>: Alpha (dispersion) parameter of the negative binomial distribution.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="../n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1512' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_negative_binomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._random_negative_binomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._random_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_random_negative_binomial(k, p, shape, ctx, dtype)
</code></pre>

<p>Draw random samples from a negative binomial distribution.</p>
<p>Samples are distributed according to a negative binomial distribution parametrized by <em>k</em> (limit of unsuccessful experiments) and <em>p</em> (failure probability in each experiment). Samples will always be returned as a floating point data type.</p>
<p>Example::</p>
<p>negative_binomial(k=3, p=0.4, shape=(2,2)) = [[ 4.,  7.],                                                  [ 2.,  5.]]</p>
<p>Defined in src/operator/random/sample_op.cc:L149</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>k::int, optional, default='1'</code>: Limit of unsuccessful experiments.</li>
<li><code>p::float, optional, default=1</code>: Failure probability in each experiment.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="../n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1511' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_normal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._random_normal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._random_normal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_random_normal(loc, scale, shape, ctx, dtype)
</code></pre>

<p>Draw random samples from a normal (Gaussian) distribution.</p>
<p>.. note:: The existing alias $normal$ is deprecated.</p>
<p>Samples are distributed according to a normal distribution parametrized by <em>loc</em> (mean) and <em>scale</em> (standard deviation).</p>
<p>Example::</p>
<p>normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],                                           [-1.23474145,  1.55807114]]</p>
<p>Defined in src/operator/random/sample_op.cc:L85</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>loc::float, optional, default=0</code>: Mean of the distribution.</li>
<li><code>scale::float, optional, default=1</code>: Standard deviation of the distribution.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="../n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1511' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_poisson-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._random_poisson-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._random_poisson</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_random_poisson(lam, shape, ctx, dtype)
</code></pre>

<p>Draw random samples from a Poisson distribution.</p>
<p>Samples are distributed according to a Poisson distribution parametrized by <em>lambda</em> (rate). Samples will always be returned as a floating point data type.</p>
<p>Example::</p>
<p>poisson(lam=4, shape=(2,2)) = [[ 5.,  2.],                                   [ 4.,  6.]]</p>
<p>Defined in src/operator/random/sample_op.cc:L132</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lam::float, optional, default=1</code>: Lambda parameter (rate) of the Poisson distribution.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="../n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._random_uniform-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._random_uniform-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._random_uniform</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_random_uniform(low, high, shape, ctx, dtype)
</code></pre>

<p>Draw random samples from a uniform distribution.</p>
<p>.. note:: The existing alias $uniform$ is deprecated.</p>
<p>Samples are uniformly distributed over the half-open interval <em>[low, high)</em> (includes <em>low</em>, but excludes <em>high</em>).</p>
<p>Example::</p>
<p>uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],                                           [ 0.54488319,  0.84725171]]</p>
<p>Defined in src/operator/random/sample_op.cc:L66</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>low::float, optional, default=0</code>: Lower bound of the distribution.</li>
<li><code>high::float, optional, default=1</code>: Upper bound of the distribution.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="../n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1513' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._rdiv_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._rdiv_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._rdiv_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_rdiv_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._rminus_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._rminus_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._rminus_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_rminus_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._rmod_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._rmod_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._rmod_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_rmod_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._rpower_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._rpower_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._rpower_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_rpower_scalar(data, scalar)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sample_exponential-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sample_exponential-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sample_exponential</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sample_exponential(lam, shape, dtype)
</code></pre>

<p>Concurrent sampling from multiple exponential distributions with parameters lambda (rate).</p>
<p>The parameters of the distributions are provided as an input array. Let <em>[s]</em> be the shape of the input array, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input array, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input value at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input array.</p>
<p>Examples::</p>
<p>lam = [ 1.0, 8.5 ]</p>
<p>// Draw a single sample for each distribution    sample_exponential(lam) = [ 0.51837951,  0.09994757]</p>
<p>// Draw a vector containing two samples for each distribution    sample_exponential(lam, shape=(2)) = [[ 0.51837951,  0.19866663],                                          [ 0.09994757,  0.50447971]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L284</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lam::NDArray-or-SymbolicNode</code>: Lambda (rate) parameters of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1521' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sample_gamma-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sample_gamma-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sample_gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sample_gamma(alpha, shape, dtype, beta)
</code></pre>

<p>Concurrent sampling from multiple gamma distributions with parameters <em>alpha</em> (shape) and <em>beta</em> (scale).</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Examples::</p>
<p>alpha = [ 0.0, 2.5 ]    beta = [ 1.0, 0.7 ]</p>
<p>// Draw a single sample for each distribution    sample_gamma(alpha, beta) = [ 0.        ,  2.25797319]</p>
<p>// Draw a vector containing two samples for each distribution    sample_gamma(alpha, beta, shape=(2)) = [[ 0.        ,  0.        ],                                            [ 2.25797319,  1.70734084]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L282</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>alpha::NDArray-or-SymbolicNode</code>: Alpha (shape) parameters of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: Beta (scale) parameters of the distributions.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1524' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sample_generalized_negative_binomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sample_generalized_negative_binomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sample_generalized_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sample_generalized_negative_binomial(mu, shape, dtype, alpha)
</code></pre>

<p>Concurrent sampling from multiple generalized negative binomial distributions with parameters <em>mu</em> (mean) and <em>alpha</em> (dispersion).</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Samples will always be returned as a floating point data type.</p>
<p>Examples::</p>
<p>mu = [ 2.0, 2.5 ]    alpha = [ 1.0, 0.1 ]</p>
<p>// Draw a single sample for each distribution    sample_generalized_negative_binomial(mu, alpha) = [ 0.,  3.]</p>
<p>// Draw a vector containing two samples for each distribution    sample_generalized_negative_binomial(mu, alpha, shape=(2)) = [[ 0.,  3.],                                                                  [ 3.,  1.]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L293</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>mu::NDArray-or-SymbolicNode</code>: Means of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>alpha::NDArray-or-SymbolicNode</code>: Alpha (dispersion) parameters of the distributions.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1526' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sample_multinomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sample_multinomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sample_multinomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sample_multinomial(data, shape, get_prob, dtype)
</code></pre>

<p>Concurrent sampling from multiple multinomial distributions.</p>
<p><em>data</em> is an <em>n</em> dimensional array whose last dimension has length <em>k</em>, where <em>k</em> is the number of possible outcomes of each multinomial distribution. This operator will draw <em>shape</em> samples from each distribution. If shape is empty one sample will be drawn from each distribution.</p>
<p>If <em>get_prob</em> is true, a second array containing log likelihood of the drawn samples will also be returned. This is usually used for reinforcement learning where you can provide reward as head gradient for this array to estimate gradient.</p>
<p>Note that the input distribution must be normalized, i.e. <em>data</em> must sum to 1 along its last axis.</p>
<p>Examples::</p>
<p>probs = [[0, 0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1, 0]]</p>
<p>// Draw a single sample for each distribution    sample_multinomial(probs) = [3, 0]</p>
<p>// Draw a vector containing two samples for each distribution    sample_multinomial(probs, shape=(2)) = [[4, 2],                                            [0, 0]]</p>
<p>// requests log likelihood    sample_multinomial(probs, get_prob=True) = [2, 1], [0.2, 0.3]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Distribution probabilities. Must sum to one on the last axis.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>get_prob::boolean, optional, default=0</code>: Whether to also return the log probability of sampled result. This is usually used for differentiating through stochastic variables, e.g. in reinforcement learning.</li>
<li><code>dtype::{'int32'},optional, default='int32'</code>: DType of the output in case this can't be inferred. Only support int32 for now.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1525' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sample_negative_binomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sample_negative_binomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sample_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sample_negative_binomial(k, shape, dtype, p)
</code></pre>

<p>Concurrent sampling from multiple negative binomial distributions with parameters <em>k</em> (failure limit) and <em>p</em> (failure probability).</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Samples will always be returned as a floating point data type.</p>
<p>Examples::</p>
<p>k = [ 20, 49 ]    p = [ 0.4 , 0.77 ]</p>
<p>// Draw a single sample for each distribution    sample_negative_binomial(k, p) = [ 15.,  16.]</p>
<p>// Draw a vector containing two samples for each distribution    sample_negative_binomial(k, p, shape=(2)) = [[ 15.,  50.],                                                 [ 16.,  12.]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L289</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>k::NDArray-or-SymbolicNode</code>: Limits of unsuccessful experiments.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>p::NDArray-or-SymbolicNode</code>: Failure probabilities in each experiment.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1526' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sample_normal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sample_normal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sample_normal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sample_normal(mu, shape, dtype, sigma)
</code></pre>

<p>Concurrent sampling from multiple normal distributions with parameters <em>mu</em> (mean) and <em>sigma</em> (standard deviation).</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Examples::</p>
<p>mu = [ 0.0, 2.5 ]    sigma = [ 1.0, 3.7 ]</p>
<p>// Draw a single sample for each distribution    sample_normal(mu, sigma) = [-0.56410581,  0.95934606]</p>
<p>// Draw a vector containing two samples for each distribution    sample_normal(mu, sigma, shape=(2)) = [[-0.56410581,  0.2928229 ],                                           [ 0.95934606,  4.48287058]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L279</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>mu::NDArray-or-SymbolicNode</code>: Means of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>sigma::NDArray-or-SymbolicNode</code>: Standard deviations of the distributions.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1524' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sample_poisson-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sample_poisson-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sample_poisson</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sample_poisson(lam, shape, dtype)
</code></pre>

<p>Concurrent sampling from multiple Poisson distributions with parameters lambda (rate).</p>
<p>The parameters of the distributions are provided as an input array. Let <em>[s]</em> be the shape of the input array, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input array, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input value at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input array.</p>
<p>Samples will always be returned as a floating point data type.</p>
<p>Examples::</p>
<p>lam = [ 1.0, 8.5 ]</p>
<p>// Draw a single sample for each distribution    sample_poisson(lam) = [  0.,  13.]</p>
<p>// Draw a vector containing two samples for each distribution    sample_poisson(lam, shape=(2)) = [[  0.,   4.],                                      [ 13.,   8.]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L286</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lam::NDArray-or-SymbolicNode</code>: Lambda (rate) parameters of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1523' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sample_uniform-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sample_uniform-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sample_uniform</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sample_uniform(low, shape, dtype, high)
</code></pre>

<p>Concurrent sampling from multiple uniform distributions on the intervals given by <em>[low,high)</em>.</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Examples::</p>
<p>low = [ 0.0, 2.5 ]    high = [ 1.0, 3.7 ]</p>
<p>// Draw a single sample for each distribution    sample_uniform(low, high) = [ 0.40451524,  3.18687344]</p>
<p>// Draw a vector containing two samples for each distribution    sample_uniform(low, high, shape=(2)) = [[ 0.40451524,  0.18017688],                                            [ 3.18687344,  3.68352246]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L277</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>low::NDArray-or-SymbolicNode</code>: Lower bounds of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>high::NDArray-or-SymbolicNode</code>: Upper bounds of the distributions.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1524' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._scatter_elemwise_div-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._scatter_elemwise_div-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._scatter_elemwise_div</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_scatter_elemwise_div(lhs, rhs)
</code></pre>

<p>Divides arguments element-wise.  If the left-hand-side input is 'row_sparse', then only the values which exist in the left-hand sparse array are computed.  The 'missing' values are ignored.</p>
<p>The storage type of $_scatter_elemwise_div$ output depends on storage types of inputs</p>
<ul>
<li>_scatter_elemwise_div(row_sparse, row_sparse) = row_sparse</li>
<li>_scatter_elemwise_div(row_sparse, dense) = row_sparse</li>
<li>_scatter_elemwise_div(row_sparse, csr) = row_sparse</li>
<li>otherwise, $_scatter_elemwise_div$ behaves exactly like elemwise_div and generates output</li>
</ul>
<p>with default storage</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1505' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._scatter_minus_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._scatter_minus_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._scatter_minus_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_scatter_minus_scalar(data, scalar)
</code></pre>

<p>Subtracts a scalar to a tensor element-wise.  If the left-hand-side input is 'row_sparse' or 'csr', then only the values which exist in the left-hand sparse array are computed. The 'missing' values are ignored.</p>
<p>The storage type of $_scatter_minus_scalar$ output depends on storage types of inputs</p>
<ul>
<li>_scatter_minus_scalar(row_sparse, scalar) = row_sparse</li>
<li>_scatter_minus_scalar(csr, scalar) = csr</li>
<li>otherwise, $_scatter_minus_scalar$ behaves exactly like _minus_scalar and generates output</li>
</ul>
<p>with default storage</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1504' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._scatter_plus_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._scatter_plus_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._scatter_plus_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_scatter_plus_scalar(data, scalar)
</code></pre>

<p>Adds a scalar to a tensor element-wise.  If the left-hand-side input is 'row_sparse' or 'csr', then only the values which exist in the left-hand sparse array are computed. The 'missing' values are ignored.</p>
<p>The storage type of $_scatter_plus_scalar$ output depends on storage types of inputs</p>
<ul>
<li>_scatter_plus_scalar(row_sparse, scalar) = row_sparse</li>
<li>_scatter_plus_scalar(csr, scalar) = csr</li>
<li>otherwise, $_scatter_plus_scalar$ behaves exactly like _plus_scalar and generates output</li>
</ul>
<p>with default storage</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1504' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._scatter_set_nd-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._scatter_set_nd-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._scatter_set_nd</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_scatter_set_nd(data, indices, shape)
</code></pre>

<p>This operator has the same functionality as scatter_nd except that it does not reset the elements not indexed by the input index <code>NDArray</code> in the input data <code>NDArray</code>.</p>
<p>.. note:: This operator is for internal use only.</p>
<p>Examples::</p>
<p>data = [2, 3, 0]   indices = [[1, 1, 0], [0, 1, 0]]   out = [[1, 1], [1, 1]]   scatter_nd(data=data, indices=indices, out=out)   out = [[0, 1], [2, 3]]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: data</li>
<li><code>indices::NDArray-or-SymbolicNode</code>: indices</li>
<li><code>shape::Shape(tuple), required</code>: Shape of output.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1509' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._set_value-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._set_value-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._set_value</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_set_value(src)
</code></pre>

<p><strong>Arguments</strong></p>
<ul>
<li><code>src::real_t</code>: Source input to the function.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1491' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._slice_assign-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._slice_assign-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._slice_assign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_slice_assign(lhs, rhs, begin, end, step)
</code></pre>

<p>Assign the rhs to a cropped subset of lhs.</p>
<p><strong>Requirements</strong></p>
<ul>
<li>output should be explicitly given and be the same as lhs.</li>
<li>lhs and rhs are of the same data type, and on the same device.</li>
</ul>
<p>From:src/operator/tensor/matrix_op.cc:381</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: value to assign</li>
<li><code>begin::Shape(tuple), required</code>: starting indices for the slice operation, supports negative indices.</li>
<li><code>end::Shape(tuple), required</code>: ending indices for the slice operation, supports negative indices.</li>
<li><code>step::Shape(tuple), optional, default=[]</code>: step for the slice operation, supports negative values.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1507' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._slice_assign_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._slice_assign_scalar-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._slice_assign_scalar</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_slice_assign_scalar(data, scalar, begin, end, step)
</code></pre>

<p>(Assign the scalar to a cropped subset of the input.</p>
<p><strong>Requirements</strong></p>
<ul>
<li>output should be explicitly given and be the same as input</li>
</ul>
<p>)</p>
<p>From:src/operator/tensor/matrix_op.cc:406</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>scalar::float, optional, default=0</code>: The scalar value for assignment.</li>
<li><code>begin::Shape(tuple), required</code>: starting indices for the slice operation, supports negative indices.</li>
<li><code>end::Shape(tuple), required</code>: ending indices for the slice operation, supports negative indices.</li>
<li><code>step::Shape(tuple), optional, default=[]</code>: step for the slice operation, supports negative values.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1506' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_ElementWiseSum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_ElementWiseSum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_ElementWiseSum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_ElementWiseSum(args)
</code></pre>

<p>_sparse_ElementWiseSum is an alias of add_n.</p>
<p><strong>Note</strong>: _sparse_ElementWiseSum takes variable number of positional inputs. So instead of calling as _sparse_ElementWiseSum([x, y, z], num_args=3), one should call via _sparse_ElementWiseSum(x, y, z), and num_args will be determined automatically.</p>
<p>Adds all input arguments element-wise.</p>
<p>.. math::    add_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n</p>
<p>$add_n$ is potentially more efficient than calling $add$ by <code>n</code> times.</p>
<p>The storage type of $add_n$ output depends on storage types of inputs</p>
<ul>
<li>add_n(row_sparse, row_sparse, ..) = row_sparse</li>
<li>otherwise, $add_n$ generates output with default storage</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_sum.cc:L123</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>args::NDArray-or-SymbolicNode[]</code>: Positional input arguments</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1509' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_abs-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_abs-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_abs</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_abs(data)
</code></pre>

<p>_sparse_abs is an alias of abs.</p>
<p>Returns element-wise absolute value of the input.</p>
<p>Example::</p>
<p>abs([-2, 0, 3]) = [2, 0, 3]</p>
<p>The storage type of $abs$ output depends upon the input storage type:</p>
<ul>
<li>abs(default) = default</li>
<li>abs(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L386</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1506' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_adam_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_adam_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_adam_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_adam_update(weight, grad, mean, var, lr, beta1, beta2, epsilon, wd, rescale_grad, clip_gradient)
</code></pre>

<p>_sparse_adam_update is an alias of adam_update.</p>
<p>Update function for Adam optimizer. Adam is seen as a generalization of AdaGrad.</p>
<p>Adam update consists of the following steps, where g represents gradient and m, v are 1st and 2nd order moment estimates (mean and variance).</p>
<p>.. math::</p>
<p>g_t = \nabla J(W_{t-1})\
 m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\
 v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\
 W_t = W_{t-1} - \alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon }</p>
<p>It updates the weights using::</p>
<p>m = beta1<em>m + (1-beta1)</em>grad  v = beta2<em>v + (1-beta2)</em>(grad**2)  w += - learning_rate * m / (sqrt(v) + epsilon)</p>
<p>If w, m and v are all of $row_sparse$ storage type, only the row slices whose indices appear in grad.indices are updated (for w, m and v)::</p>
<p>for row in grad.indices:      m[row] = beta1<em>m[row] + (1-beta1)</em>grad[row]      v[row] = beta2<em>v[row] + (1-beta2)</em>(grad[row]**2)      w[row] += - learning_rate * m[row] / (sqrt(v[row]) + epsilon)</p>
<p>Defined in src/operator/optimizer_op.cc:L175</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>mean::NDArray-or-SymbolicNode</code>: Moving mean</li>
<li><code>var::NDArray-or-SymbolicNode</code>: Moving variance</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>beta1::float, optional, default=0.9</code>: The decay rate for the 1st moment estimates.</li>
<li><code>beta2::float, optional, default=0.999</code>: The decay rate for the 2nd moment estimates.</li>
<li><code>epsilon::float, optional, default=1e-08</code>: A small constant for numerical stability.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1542' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_add_n-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_add_n-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_add_n</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_add_n(args)
</code></pre>

<p>_sparse_add_n is an alias of add_n.</p>
<p><strong>Note</strong>: _sparse_add_n takes variable number of positional inputs. So instead of calling as _sparse_add_n([x, y, z], num_args=3), one should call via _sparse_add_n(x, y, z), and num_args will be determined automatically.</p>
<p>Adds all input arguments element-wise.</p>
<p>.. math::    add_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n</p>
<p>$add_n$ is potentially more efficient than calling $add$ by <code>n</code> times.</p>
<p>The storage type of $add_n$ output depends on storage types of inputs</p>
<ul>
<li>add_n(row_sparse, row_sparse, ..) = row_sparse</li>
<li>otherwise, $add_n$ generates output with default storage</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_sum.cc:L123</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>args::NDArray-or-SymbolicNode[]</code>: Positional input arguments</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1509' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_arccos-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_arccos-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_arccos</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_arccos(data)
</code></pre>

<p>_sparse_arccos is an alias of arccos.</p>
<p>Returns element-wise inverse cosine of the input array.</p>
<p>The input should be in range <code>[-1, 1]</code>. The output is in the closed interval :math:<code>[0, \pi]</code></p>
<p>.. math::    arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]</p>
<p>The storage type of $arccos$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L123</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1505' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_arccosh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_arccosh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_arccosh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_arccosh(data)
</code></pre>

<p>_sparse_arccosh is an alias of arccosh.</p>
<p>Returns the element-wise inverse hyperbolic cosine of the input array, 
computed element-wise.</p>
<p>The storage type of $arccosh$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L264</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1500' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_arcsin-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_arcsin-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_arcsin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_arcsin(data)
</code></pre>

<p>_sparse_arcsin is an alias of arcsin.</p>
<p>Returns element-wise inverse sine of the input array.</p>
<p>The input should be in the range <code>[-1, 1]</code>. The output is in the closed interval of [:math:<code>-\pi/2</code>, :math:<code>\pi/2</code>].</p>
<p>.. math::    arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]</p>
<p>The storage type of $arcsin$ output depends upon the input storage type:</p>
<ul>
<li>arcsin(default) = default</li>
<li>arcsin(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L104</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_arcsinh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_arcsinh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_arcsinh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_arcsinh(data)
</code></pre>

<p>_sparse_arcsinh is an alias of arcsinh.</p>
<p>Returns the element-wise inverse hyperbolic sine of the input array, 
computed element-wise.</p>
<p>The storage type of $arcsinh$ output depends upon the input storage type:</p>
<ul>
<li>arcsinh(default) = default</li>
<li>arcsinh(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L250</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1503' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_arctan-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_arctan-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_arctan</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_arctan(data)
</code></pre>

<p>_sparse_arctan is an alias of arctan.</p>
<p>Returns element-wise inverse tangent of the input array.</p>
<p>The output is in the closed interval :math:<code>[-\pi/2, \pi/2]</code></p>
<p>.. math::    arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]</p>
<p>The storage type of $arctan$ output depends upon the input storage type:</p>
<ul>
<li>arctan(default) = default</li>
<li>arctan(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L144</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1507' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_arctanh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_arctanh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_arctanh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_arctanh(data)
</code></pre>

<p>_sparse_arctanh is an alias of arctanh.</p>
<p>Returns the element-wise inverse hyperbolic tangent of the input array, 
computed element-wise.</p>
<p>The storage type of $arctanh$ output depends upon the input storage type:</p>
<ul>
<li>arctanh(default) = default</li>
<li>arctanh(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L281</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1503' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_cast_storage-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_cast_storage-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_cast_storage</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_cast_storage(data, stype)
</code></pre>

<p>_sparse_cast_storage is an alias of cast_storage.</p>
<p>Casts tensor storage type to the new type.</p>
<p>When an NDArray with default storage type is cast to csr or row_sparse storage, the result is compact, which means:</p>
<ul>
<li>for csr, zero values will not be retained</li>
<li>for row_sparse, row slices of all zeros will not be retained</li>
</ul>
<p>The storage type of $cast_storage$ output depends on stype parameter:</p>
<ul>
<li>cast_storage(csr, 'default') = default</li>
<li>cast_storage(row_sparse, 'default') = default</li>
<li>cast_storage(default, 'csr') = csr</li>
<li>cast_storage(default, 'row_sparse') = row_sparse</li>
</ul>
<p>Example::</p>
<pre><code>dense = [[ 0.,  1.,  0.],
         [ 2.,  0.,  3.],
         [ 0.,  0.,  0.],
         [ 0.,  0.,  0.]]

# cast to row_sparse storage type
rsp = cast_storage(dense, 'row_sparse')
rsp.indices = [0, 1]
rsp.values = [[ 0.,  1.,  0.],
              [ 2.,  0.,  3.]]

# cast to csr storage type
csr = cast_storage(dense, 'csr')
csr.indices = [1, 0, 2]
csr.values = [ 1.,  2.,  3.]
csr.indptr = [0, 1, 3, 3, 3]
</code></pre>

<p>Defined in src/operator/tensor/cast_storage.cc:L69</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>stype::{'csr', 'default', 'row_sparse'}, required</code>: Output storage type.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1531' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_ceil-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_ceil-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_ceil</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_ceil(data)
</code></pre>

<p>_sparse_ceil is an alias of ceil.</p>
<p>Returns element-wise ceiling of the input.</p>
<p>The ceil of the scalar x is the smallest integer i, such that i &gt;= x.</p>
<p>Example::</p>
<p>ceil([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  2.,  2.,  3.]</p>
<p>The storage type of $ceil$ output depends upon the input storage type:</p>
<ul>
<li>ceil(default) = default</li>
<li>ceil(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L464</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_clip-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_clip-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_clip</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_clip(data, a_min, a_max)
</code></pre>

<p>_sparse_clip is an alias of clip.</p>
<p>Clips (limits) the values in an array.</p>
<p>Given an interval, values outside the interval are clipped to the interval edges. Clipping $x$ between <code>a_min</code> and <code>a_x</code> would be::</p>
<p>clip(x, a_min, a_max) = max(min(x, a_max), a_min))</p>
<p>Example::</p>
<pre><code>x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

clip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]
</code></pre>

<p>The storage type of $clip$ output depends on storage types of inputs and the a_min, a_max 
parameter values:</p>
<ul>
<li>clip(default) = default</li>
<li>clip(row_sparse, a_min &lt;= 0, a_max &gt;= 0) = row_sparse</li>
<li>clip(csr, a_min &lt;= 0, a_max &gt;= 0) = csr</li>
<li>clip(row_sparse, a_min &lt; 0, a_max &lt; 0) = default</li>
<li>clip(row_sparse, a_min &gt; 0, a_max &gt; 0) = default</li>
<li>clip(csr, a_min &lt; 0, a_max &lt; 0) = csr</li>
<li>clip(csr, a_min &gt; 0, a_max &gt; 0) = csr</li>
</ul>
<p>Defined in src/operator/tensor/matrix_op.cc:L486</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
<li><code>a_min::float, required</code>: Minimum value</li>
<li><code>a_max::float, required</code>: Maximum value</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1523' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_cos-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_cos-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_cos</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_cos(data)
</code></pre>

<p>_sparse_cos is an alias of cos.</p>
<p>Computes the element-wise cosine of the input array.</p>
<p>The input should be in radians (:math:<code>2\pi</code> rad equals 360 degrees).</p>
<p>.. math::    cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]</p>
<p>The storage type of $cos$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L63</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1504' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_cosh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_cosh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_cosh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_cosh(data)
</code></pre>

<p>_sparse_cosh is an alias of cosh.</p>
<p>Returns the hyperbolic cosine  of the input array, computed element-wise.</p>
<p>.. math::    cosh(x) = 0.5\times(exp(x) + exp(-x))</p>
<p>The storage type of $cosh$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L216</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1502' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_degrees-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_degrees-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_degrees</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_degrees(data)
</code></pre>

<p>_sparse_degrees is an alias of degrees.</p>
<p>Converts each element of the input array from radians to degrees.</p>
<p>.. math::    degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]</p>
<p>The storage type of $degrees$ output depends upon the input storage type:</p>
<ul>
<li>degrees(default) = default</li>
<li>degrees(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L163</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1505' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_dot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_dot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_dot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_dot(lhs, rhs, transpose_a, transpose_b)
</code></pre>

<p>_sparse_dot is an alias of dot.</p>
<p>Dot product of two arrays.</p>
<p>$dot$'s behavior depends on the input array dimensions:</p>
<ul>
<li>1-D arrays: inner product of vectors</li>
<li>2-D arrays: matrix multiplication</li>
<li>
<p>N-D arrays: a sum product over the last axis of the first input and the first axis of the second input</p>
<p>For example, given 3-D $x$ with shape <code>(n,m,k)</code> and $y$ with shape <code>(k,r,s)</code>, the result array will have shape <code>(n,m,r,s)</code>. It is computed by::</p>
<p>dot(x,y)[i,j,a,b] = sum(x[i,j,:]*y[:,a,b])</p>
<p>Example::</p>
<p>x = reshape([0,1,2,3,4,5,6,7], shape=(2,2,2))   y = reshape([7,6,5,4,3,2,1,0], shape=(2,2,2))   dot(x,y)[0,0,1,1] = 0   sum(x[0,0,:]*y[:,1,1]) = 0</p>
</li>
</ul>
<p>The storage type of $dot$ output depends on storage types of inputs and transpose options:</p>
<ul>
<li>dot(csr, default) = default</li>
<li>dot(csr.T, default) = row_sparse</li>
<li>dot(csr, row_sparse) = default</li>
<li>otherwise, $dot$ generates output with default storage</li>
</ul>
<p>Defined in src/operator/tensor/dot.cc:L61</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: The first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: The second input</li>
<li><code>transpose_a::boolean, optional, default=0</code>: If true then transpose the first input before dot.</li>
<li><code>transpose_b::boolean, optional, default=0</code>: If true then transpose the second input before dot.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1529' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_elemwise_add-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_elemwise_add-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_elemwise_add</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_elemwise_add(lhs, rhs)
</code></pre>

<p>_sparse_elemwise_add is an alias of elemwise_add.</p>
<p>Adds arguments element-wise.</p>
<p>The storage type of $elemwise_add$ output depends on storage types of inputs</p>
<ul>
<li>elemwise_add(row_sparse, row_sparse) = row_sparse</li>
<li>elemwise_add(csr, csr) = csr</li>
<li>otherwise, $elemwise_add$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1503' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_elemwise_div-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_elemwise_div-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_elemwise_div</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_elemwise_div(lhs, rhs)
</code></pre>

<p>_sparse_elemwise_div is an alias of elemwise_div.</p>
<p>Divides arguments element-wise.</p>
<p>The storage type of $elemwise_div$ output is always dense</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1499' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_elemwise_mul-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_elemwise_mul-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_elemwise_mul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_elemwise_mul(lhs, rhs)
</code></pre>

<p>_sparse_elemwise_mul is an alias of elemwise_mul.</p>
<p>Multiplies arguments element-wise.</p>
<p>The storage type of $elemwise_mul$ output depends on storage types of inputs</p>
<ul>
<li>elemwise_mul(default, default) = default</li>
<li>elemwise_mul(row_sparse, row_sparse) = row_sparse</li>
<li>elemwise_mul(default, row_sparse) = default</li>
<li>elemwise_mul(row_sparse, default) = default</li>
<li>elemwise_mul(csr, csr) = csr</li>
<li>otherwise, $elemwise_mul$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1506' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_elemwise_sub-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_elemwise_sub-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_elemwise_sub</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_elemwise_sub(lhs, rhs)
</code></pre>

<p>_sparse_elemwise_sub is an alias of elemwise_sub.</p>
<p>Subtracts arguments element-wise.</p>
<p>The storage type of $elemwise_sub$ output depends on storage types of inputs</p>
<ul>
<li>elemwise_sub(row_sparse, row_sparse) = row_sparse</li>
<li>elemwise_sub(csr, csr) = csr</li>
<li>otherwise, $elemwise_sub$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1503' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_exp-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_exp-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_exp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_exp(data)
</code></pre>

<p>_sparse_exp is an alias of exp.</p>
<p>Returns element-wise exponential value of the input.</p>
<p>.. math::    exp(x) = e^x \approx 2.718^x</p>
<p>Example::</p>
<p>exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]</p>
<p>The storage type of $exp$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L642</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1506' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_expm1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_expm1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_expm1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_expm1(data)
</code></pre>

<p>_sparse_expm1 is an alias of expm1.</p>
<p>Returns $exp(x) - 1$ computed element-wise on the input.</p>
<p>This function provides greater precision than $exp(x) - 1$ for small values of $x$.</p>
<p>The storage type of $expm1$ output depends upon the input storage type:</p>
<ul>
<li>expm1(default) = default</li>
<li>expm1(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L721</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1504' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_fix-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_fix-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_fix</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_fix(data)
</code></pre>

<p>_sparse_fix is an alias of fix.</p>
<p>Returns element-wise rounded value to the nearest 
integer towards zero of the input.</p>
<p>Example::</p>
<p>fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1.,  1., 2.]</p>
<p>The storage type of $fix$ output depends upon the input storage type:</p>
<ul>
<li>fix(default) = default</li>
<li>fix(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L521</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1507' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_floor-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_floor-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_floor</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_floor(data)
</code></pre>

<p>_sparse_floor is an alias of floor.</p>
<p>Returns element-wise floor of the input.</p>
<p>The floor of the scalar x is the largest integer i, such that i &lt;= x.</p>
<p>Example::</p>
<p>floor([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-3., -2.,  1.,  1.,  2.]</p>
<p>The storage type of $floor$ output depends upon the input storage type:</p>
<ul>
<li>floor(default) = default</li>
<li>floor(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L483</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_ftrl_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_ftrl_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_ftrl_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_ftrl_update(weight, grad, z, n, lr, lamda1, beta, wd, rescale_grad, clip_gradient)
</code></pre>

<p>_sparse_ftrl_update is an alias of ftrl_update.</p>
<p>Update function for Ftrl optimizer. Referenced from <em>Ad Click Prediction: a View from the Trenches</em>, available at http://dl.acm.org/citation.cfm?id=2488200.</p>
<p>It updates the weights using::</p>
<p>rescaled_grad = clip(grad * rescale_grad, clip_gradient)  z += rescaled_grad - (sqrt(n + rescaled_grad<strong>2) - sqrt(n)) * weight / learning_rate  n += rescaled_grad</strong>2  w = (sign(z) * lamda1 - z) / ((beta + sqrt(n)) / learning_rate + wd) * (abs(z) &gt; lamda1)</p>
<p>If w, z and n are all of $row_sparse$ storage type, only the row slices whose indices appear in grad.indices are updated (for w, z and n)::</p>
<p>for row in grad.indices:      rescaled_grad[row] = clip(grad[row] * rescale_grad, clip_gradient)      z[row] += rescaled_grad[row] - (sqrt(n[row] + rescaled_grad[row]<strong>2) - sqrt(n[row])) * weight[row] / learning_rate      n[row] += rescaled_grad[row]</strong>2      w[row] = (sign(z[row]) * lamda1 - z[row]) / ((beta + sqrt(n[row])) / learning_rate + wd) * (abs(z[row]) &gt; lamda1)</p>
<p>Defined in src/operator/optimizer_op.cc:L308</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>z::NDArray-or-SymbolicNode</code>: z</li>
<li><code>n::NDArray-or-SymbolicNode</code>: Square of grad</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>lamda1::float, optional, default=0.01</code>: The L1 regularization coefficient.</li>
<li><code>beta::float, optional, default=1</code>: Per-Coordinate Learning Rate beta.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1533' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_gamma-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_gamma-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_gamma(data)
</code></pre>

<p>_sparse_gamma is an alias of gamma.</p>
<p>Returns the gamma function (extension of the factorial function 
to the reals), computed element-wise on the input array.</p>
<p>The storage type of $gamma$ output is always dense</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1498' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_gammaln-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_gammaln-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_gammaln</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_gammaln(data)
</code></pre>

<p>_sparse_gammaln is an alias of gammaln.</p>
<p>Returns element-wise log of the absolute value of the gamma function 
of the input.</p>
<p>The storage type of $gammaln$ output is always dense</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1498' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_log-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_log-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_log</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_log(data)
</code></pre>

<p>_sparse_log is an alias of log.</p>
<p>Returns element-wise Natural logarithmic value of the input.</p>
<p>The natural logarithm is logarithm in base <em>e</em>, so that $log(exp(x)) = x$</p>
<p>The storage type of $log$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L654</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1501' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_log10-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_log10-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_log10</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_log10(data)
</code></pre>

<p>_sparse_log10 is an alias of log10.</p>
<p>Returns element-wise Base-10 logarithmic value of the input.</p>
<p>$10**log10(x) = x$</p>
<p>The storage type of $log10$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L666</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1501' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_log1p-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_log1p-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_log1p</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_log1p(data)
</code></pre>

<p>_sparse_log1p is an alias of log1p.</p>
<p>Returns element-wise $log(1 + x)$ value of the input.</p>
<p>This function is more accurate than $log(1 + x)$  for small $x$ so that :math:<code>1+x\approx 1</code></p>
<p>The storage type of $log1p$ output depends upon the input storage type:</p>
<ul>
<li>log1p(default) = default</li>
<li>log1p(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L703</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1505' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_log2-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_log2-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_log2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_log2(data)
</code></pre>

<p>_sparse_log2 is an alias of log2.</p>
<p>Returns element-wise Base-2 logarithmic value of the input.</p>
<p>$2**log2(x) = x$</p>
<p>The storage type of $log2$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L678</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1501' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_make_loss-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_make_loss-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_make_loss</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_make_loss(data)
</code></pre>

<p>_sparse_make_loss is an alias of make_loss.</p>
<p>Make your own loss function in network construction.</p>
<p>This operator accepts a customized loss function symbol as a terminal loss and the symbol should be an operator with no backward dependency. The output of this function is the gradient of loss with respect to the input data.</p>
<p>For example, if you are a making a cross entropy loss function. Assume $out$ is the predicted output and $label$ is the true label, then the cross entropy can be defined as::</p>
<p>cross_entropy = label * log(out) + (1 - label) * log(1 - out)   loss = make_loss(cross_entropy)</p>
<p>We will need to use $make_loss$ when we are creating our own loss function or we want to combine multiple loss functions. Also we may want to stop some variables' gradients from backpropagation. See more detail in $BlockGrad$ or $stop_gradient$.</p>
<p>The storage type of $make_loss$ output depends upon the input storage type:</p>
<ul>
<li>make_loss(default) = default</li>
<li>make_loss(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L200</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1516' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_mean-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_mean-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_mean</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_mean(data, axis, keepdims, exclude)
</code></pre>

<p>_sparse_mean is an alias of mean.</p>
<p>Computes the mean of array elements over given axes.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L101</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape(tuple), optional, default=[]</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0`: Whether to perform reduction on axis that are NOT in axis instead.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1514' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_negative-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_negative-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_negative</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_negative(data)
</code></pre>

<p>_sparse_negative is an alias of negative.</p>
<p>Numerical negative of the argument, element-wise.</p>
<p>The storage type of $negative$ output depends upon the input storage type:</p>
<ul>
<li>negative(default) = default</li>
<li>negative(row_sparse) = row_sparse</li>
<li>negative(csr) = csr</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1501' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_radians-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_radians-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_radians</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_radians(data)
</code></pre>

<p>_sparse_radians is an alias of radians.</p>
<p>Converts each element of the input array from degrees to radians.</p>
<p>.. math::    radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]</p>
<p>The storage type of $radians$ output depends upon the input storage type:</p>
<ul>
<li>radians(default) = default</li>
<li>radians(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L182</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1505' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_relu-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_relu-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_relu</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_relu(data)
</code></pre>

<p>_sparse_relu is an alias of relu.</p>
<p>Computes rectified linear.</p>
<p>.. math::    max(features, 0)</p>
<p>The storage type of $relu$ output depends upon the input storage type:</p>
<ul>
<li>relu(default) = default</li>
<li>relu(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L84</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1505' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_retain-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_retain-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_retain</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_retain(data, indices)
</code></pre>

<p>pick rows specified by user input index array from a row sparse matrix and save them in the output sparse matrix.</p>
<p>Example::</p>
<p>data = [[1, 2], [3, 4], [5, 6]]   indices = [0, 1, 3]   shape = (4, 2)   rsp_in = row_sparse(data, indices)   to_retain = [0, 3]   rsp_out = retain(rsp_in, to_retain)   rsp_out.values = [[1, 2], [5, 6]]   rsp_out.indices = [0, 3]</p>
<p>The storage type of $retain$ output depends on storage types of inputs</p>
<ul>
<li>retain(row_sparse, default) = row_sparse</li>
<li>otherwise, $retain$ is not supported</li>
</ul>
<p>Defined in src/operator/tensor/sparse_retain.cc:L53</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array for sparse_retain operator.</li>
<li><code>indices::NDArray-or-SymbolicNode</code>: The index array of rows ids that will be retained.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1514' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_rint-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_rint-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_rint</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_rint(data)
</code></pre>

<p>_sparse_rint is an alias of rint.</p>
<p>Returns element-wise rounded value to the nearest integer of the input.</p>
<p>.. note::</p>
<ul>
<li>For input $n.5$ $rint$ returns $n$ while $round$ returns $n+1$.</li>
<li>For input $-n.5$ both $rint$ and $round$ returns $-n-1$.</li>
</ul>
<p>Example::</p>
<p>rint([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  1., -2.,  2.,  2.]</p>
<p>The storage type of $rint$ output depends upon the input storage type:</p>
<ul>
<li>rint(default) = default</li>
<li>rint(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L445</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1510' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_round-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_round-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_round</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_round(data)
</code></pre>

<p>_sparse_round is an alias of round.</p>
<p>Returns element-wise rounded value to the nearest integer of the input.</p>
<p>Example::</p>
<p>round([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  2., -2.,  2.,  2.]</p>
<p>The storage type of $round$ output depends upon the input storage type:</p>
<ul>
<li>round(default) = default</li>
<li>round(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L424</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1506' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_rsqrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_rsqrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_rsqrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_rsqrt(data)
</code></pre>

<p>_sparse_rsqrt is an alias of rsqrt.</p>
<p>Returns element-wise inverse square-root value of the input.</p>
<p>.. math::    rsqrt(x) = 1/\sqrt{x}</p>
<p>Example::</p>
<p>rsqrt([4,9,16]) = [0.5, 0.33333334, 0.25]</p>
<p>The storage type of $rsqrt$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L585</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1506' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_sgd_mom_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_sgd_mom_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_sgd_mom_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_sgd_mom_update(weight, grad, mom, lr, momentum, wd, rescale_grad, clip_gradient)
</code></pre>

<p>_sparse_sgd_mom_update is an alias of sgd_mom_update.</p>
<p>Momentum update function for Stochastic Gradient Descent (SDG) optimizer.</p>
<p>Momentum update has better convergence rates on neural networks. Mathematically it looks like below:</p>
<p>.. math::</p>
<p>v_1 = \alpha * \nabla J(W_0)\
  v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\
  W_t = W_{t-1} + v_t</p>
<p>It updates the weights using::</p>
<p>v = momentum * v - learning_rate * gradient   weight += v</p>
<p>Where the parameter $momentum$ is the decay rate of momentum estimates at each epoch.</p>
<p>If weight and momentum are both of $row_sparse$ storage type, only the row slices whose indices appear in grad.indices are updated (for both weight and momentum)::</p>
<p>for row in gradient.indices:       v[row] = momentum[row] * v[row] - learning_rate * gradient[row]       weight[row] += v[row]</p>
<p>Defined in src/operator/optimizer_op.cc:L93</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>mom::NDArray-or-SymbolicNode</code>: Momentum</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>momentum::float, optional, default=0</code>: The decay rate of momentum estimates at each epoch.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1534' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_sgd_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_sgd_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_sgd_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_sgd_update(weight, grad, lr, wd, rescale_grad, clip_gradient)
</code></pre>

<p>_sparse_sgd_update is an alias of sgd_update.</p>
<p>Update function for Stochastic Gradient Descent (SDG) optimizer.</p>
<p>It updates the weights using::</p>
<p>weight = weight - learning_rate * gradient</p>
<p>If weight is of $row_sparse$ storage type, only the row slices whose indices appear in grad.indices are updated::</p>
<p>for row in gradient.indices:      weight[row] = weight[row] - learning_rate * gradient[row]</p>
<p>Defined in src/operator/optimizer_op.cc:L53</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1517' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_sigmoid-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_sigmoid-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_sigmoid</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_sigmoid(data)
</code></pre>

<p>_sparse_sigmoid is an alias of sigmoid.</p>
<p>Computes sigmoid of x element-wise.</p>
<p>.. math::    y = 1 / (1 + exp(-x))</p>
<p>The storage type of $sigmoid$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L103</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1502' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_sign-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_sign-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_sign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_sign(data)
</code></pre>

<p>_sparse_sign is an alias of sign.</p>
<p>Returns element-wise sign of the input.</p>
<p>Example::</p>
<p>sign([-2, 0, 3]) = [-1, 0, 1]</p>
<p>The storage type of $sign$ output depends upon the input storage type:</p>
<ul>
<li>sign(default) = default</li>
<li>sign(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L405</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1506' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_sin-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_sin-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_sin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_sin(data)
</code></pre>

<p>_sparse_sin is an alias of sin.</p>
<p>Computes the element-wise sine of the input array.</p>
<p>The input should be in radians (:math:<code>2\pi</code> rad equals 360 degrees).</p>
<p>.. math::    sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]</p>
<p>The storage type of $sin$ output depends upon the input storage type:</p>
<ul>
<li>sin(default) = default</li>
<li>sin(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L46</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1507' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_sinh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_sinh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_sinh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_sinh(data)
</code></pre>

<p>_sparse_sinh is an alias of sinh.</p>
<p>Returns the hyperbolic sine of the input array, computed element-wise.</p>
<p>.. math::    sinh(x) = 0.5\times(exp(x) - exp(-x))</p>
<p>The storage type of $sinh$ output depends upon the input storage type:</p>
<ul>
<li>sinh(default) = default</li>
<li>sinh(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L201</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1505' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_slice-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_slice-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_slice</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_slice(data, begin, end, step)
</code></pre>

<p>_sparse_slice is an alias of slice.</p>
<p>Slices a region of the array.</p>
<p>.. note:: $crop$ is deprecated. Use $slice$ instead.</p>
<p>This function returns a sliced array between the indices given by <code>begin</code> and <code>end</code> with the corresponding <code>step</code>.</p>
<p>For an input array of $shape=(d_0, d_1, ..., d_n-1)$, slice operation with $begin=(b_0, b_1...b_m-1)$, $end=(e_0, e_1, ..., e_m-1)$, and $step=(s_0, s_1, ..., s_m-1)$, where m &lt;= n, results in an array with the shape $(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)$.</p>
<p>The resulting array's <em>k</em>-th dimension contains elements from the <em>k</em>-th dimension of the input array starting from index $b_k$ (inclusive) with step $s_k$ until reaching $e_k$ (exclusive).</p>
<p>If the <em>k</em>-th elements are <code>None</code> in the sequence of <code>begin</code>, <code>end</code>, and <code>step</code>, the following rule will be used to set default values. If <code>s_k</code> is <code>None</code>, set <code>s_k=1</code>. If <code>s_k &gt; 0</code>, set <code>b_k=0</code>, <code>e_k=d_k</code>; else, set <code>b_k=d_k-1</code>, <code>e_k=-1</code>.</p>
<p>The storage type of $slice$ output depends on storage types of inputs</p>
<ul>
<li>slice(csr) = csr</li>
<li>otherwise, $slice$ generates output with default storage</li>
</ul>
<p>.. note:: When input data storage type is csr, it only supports step=(), or step=(None,), or step=(1,) to generate a csr output. For other step parameter values, it falls back to slicing a dense tensor.</p>
<p>Example::</p>
<p>x = [[  1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.],        [  9.,  10.,  11.,  12.]]</p>
<p>slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],                                      [ 6.,  7.,  8.]]   slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],                                                             [5.,  7.],                                                             [1.,  3.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L355</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>begin::Shape(tuple), required</code>: starting indices for the slice operation, supports negative indices.</li>
<li><code>end::Shape(tuple), required</code>: ending indices for the slice operation, supports negative indices.</li>
<li><code>step::Shape(tuple), optional, default=[]</code>: step for the slice operation, supports negative values.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1545' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_sqrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_sqrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_sqrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_sqrt(data)
</code></pre>

<p>_sparse_sqrt is an alias of sqrt.</p>
<p>Returns element-wise square-root value of the input.</p>
<p>.. math::    \textrm{sqrt}(x) = \sqrt{x}</p>
<p>Example::</p>
<p>sqrt([4, 9, 16]) = [2, 3, 4]</p>
<p>The storage type of $sqrt$ output depends upon the input storage type:</p>
<ul>
<li>sqrt(default) = default</li>
<li>sqrt(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L565</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1509' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_square-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_square-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_square</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_square(data)
</code></pre>

<p>_sparse_square is an alias of square.</p>
<p>Returns element-wise squared value of the input.</p>
<p>.. math::    square(x) = x^2</p>
<p>Example::</p>
<p>square([2, 3, 4]) = [4, 9, 16]</p>
<p>The storage type of $square$ output depends upon the input storage type:</p>
<ul>
<li>square(default) = default</li>
<li>square(row_sparse) = row_sparse</li>
<li>square(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L542</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1510' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_stop_gradient-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_stop_gradient-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_stop_gradient</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_stop_gradient(data)
</code></pre>

<p>_sparse_stop_gradient is an alias of BlockGrad.</p>
<p>Stops gradient computation.</p>
<p>Stops the accumulated gradient of the inputs from flowing through this operator in the backward direction. In other words, this operator prevents the contribution of its inputs to be taken into account for computing gradients.</p>
<p>Example::</p>
<p>v1 = [1, 2]   v2 = [0, 1]   a = Variable('a')   b = Variable('b')   b_stop_grad = stop_gradient(3 * b)   loss = MakeLoss(b_stop_grad + a)</p>
<p>executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))   executor.forward(is_train=True, a=v1, b=v2)   executor.outputs   [ 1.  5.]</p>
<p>executor.backward()   executor.grad_arrays   [ 0.  0.]   [ 1.  1.]</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L167</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1520' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_sum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_sum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_sum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_sum(data, axis, keepdims, exclude)
</code></pre>

<p>_sparse_sum is an alias of sum.</p>
<p>Computes the sum of array elements over given axes.</p>
<p>.. Note::</p>
<p><code>sum</code> and <code>sum_axis</code> are equivalent.   For ndarray of csr storage type summation along axis 0 and axis 1 is supported.   Setting keepdims or exclude to True will cause a fallback to dense operator.</p>
<p>Example::</p>
<p>data = [[[1,2],[2,3],[1,3]],           [[1,4],[4,3],[5,2]],           [[7,1],[7,2],[7,3]]]</p>
<p>sum(data, axis=1)   [[  4.   8.]    [ 10.   9.]    [ 21.   6.]]</p>
<p>sum(data, axis=[1,2])   [ 12.  19.  27.]</p>
<p>data = [[1,2,0],           [3,0,1],           [4,1,0]]</p>
<p>csr = cast_storage(data, 'csr')</p>
<p>sum(csr, axis=0)   [ 8.  2.  2.]</p>
<p>sum(csr, axis=1)   [ 3.  4.  5.]</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L85</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape(tuple), optional, default=[]</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0`: Whether to perform reduction on axis that are NOT in axis instead.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1548' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_tan-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_tan-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_tan</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_tan(data)
</code></pre>

<p>_sparse_tan is an alias of tan.</p>
<p>Computes the element-wise tangent of the input array.</p>
<p>The input should be in radians (:math:<code>2\pi</code> rad equals 360 degrees).</p>
<p>.. math::    tan([0, \pi/4, \pi/2]) = [0, 1, -inf]</p>
<p>The storage type of $tan$ output depends upon the input storage type:</p>
<ul>
<li>tan(default) = default</li>
<li>tan(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L83</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1507' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_tanh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_tanh-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_tanh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_tanh(data)
</code></pre>

<p>_sparse_tanh is an alias of tanh.</p>
<p>Returns the hyperbolic tangent of the input array, computed element-wise.</p>
<p>.. math::    tanh(x) = sinh(x) / cosh(x)</p>
<p>The storage type of $tanh$ output depends upon the input storage type:</p>
<ul>
<li>tanh(default) = default</li>
<li>tanh(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L234</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1505' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_trunc-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_trunc-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_trunc</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_trunc(data)
</code></pre>

<p>_sparse_trunc is an alias of trunc.</p>
<p>Return the element-wise truncated value of the input.</p>
<p>The truncated value of the scalar x is the nearest integer i which is closer to zero than x is. In short, the fractional part of the signed number x is discarded.</p>
<p>Example::</p>
<p>trunc([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  1.,  1.,  2.]</p>
<p>The storage type of $trunc$ output depends upon the input storage type:</p>
<ul>
<li>trunc(default) = default</li>
<li>trunc(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L503</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1509' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._sparse_zeros_like-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._sparse_zeros_like-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._sparse_zeros_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_sparse_zeros_like(data)
</code></pre>

<p>_sparse_zeros_like is an alias of zeros_like.</p>
<p>Return an array of zeros with the same shape and type as the input array.</p>
<p>The storage type of $zeros_like$ output depends on the storage type of the input</p>
<ul>
<li>zeros_like(row_sparse) = row_sparse</li>
<li>zeros_like(csr) = csr</li>
<li>zeros_like(default) = default</li>
</ul>
<p>Examples::</p>
<p>x = [[ 1.,  1.,  1.],        [ 1.,  1.,  1.]]</p>
<p>zeros_like(x) = [[ 0.,  0.,  0.],                    [ 0.,  0.,  0.]]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1510' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx._square_sum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx._square_sum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx._square_sum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>_square_sum(data, axis, keepdims, exclude)
</code></pre>

<p>Computes the square sum of array elements over a given axis for row-sparse matrix. This is a temporary solution for fusing ops square and sum together for row-sparse matrix to save memory for storing gradients. It will become deprecated once the functionality of fusing operators is finished in the future.</p>
<p>Example::</p>
<p>dns = mx.nd.array([[0, 0], [1, 2], [0, 0], [3, 4], [0, 0]])   rsp = dns.tostype('row_sparse')   sum = mx.nd._internal._square_sum(rsp, axis=1)   sum = [0, 5, 0, 25, 0]</p>
<p>Defined in src/operator/tensor/square_sum.cc:L63</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape(tuple), optional, default=[]</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0`: Whether to perform reduction on axis that are NOT in axis instead.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1524' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.adam_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.adam_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.adam_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>adam_update(weight, grad, mean, var, lr, beta1, beta2, epsilon, wd, rescale_grad, clip_gradient)
</code></pre>

<p>Update function for Adam optimizer. Adam is seen as a generalization of AdaGrad.</p>
<p>Adam update consists of the following steps, where g represents gradient and m, v are 1st and 2nd order moment estimates (mean and variance).</p>
<p>.. math::</p>
<p>g_t = \nabla J(W_{t-1})\
 m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\
 v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\
 W_t = W_{t-1} - \alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon }</p>
<p>It updates the weights using::</p>
<p>m = beta1<em>m + (1-beta1)</em>grad  v = beta2<em>v + (1-beta2)</em>(grad**2)  w += - learning_rate * m / (sqrt(v) + epsilon)</p>
<p>If w, m and v are all of $row_sparse$ storage type, only the row slices whose indices appear in grad.indices are updated (for w, m and v)::</p>
<p>for row in grad.indices:      m[row] = beta1<em>m[row] + (1-beta1)</em>grad[row]      v[row] = beta2<em>v[row] + (1-beta2)</em>(grad[row]**2)      w[row] += - learning_rate * m[row] / (sqrt(v[row]) + epsilon)</p>
<p>Defined in src/operator/optimizer_op.cc:L175</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>mean::NDArray-or-SymbolicNode</code>: Moving mean</li>
<li><code>var::NDArray-or-SymbolicNode</code>: Moving variance</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>beta1::float, optional, default=0.9</code>: The decay rate for the 1st moment estimates.</li>
<li><code>beta2::float, optional, default=0.999</code>: The decay rate for the 2nd moment estimates.</li>
<li><code>epsilon::float, optional, default=1e-08</code>: A small constant for numerical stability.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1540' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.add_n-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.add_n-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.add_n</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>add_n(args)
</code></pre>

<p><strong>Note</strong>: add_n takes variable number of positional inputs. So instead of calling as add_n([x, y, z], num_args=3), one should call via add_n(x, y, z), and num_args will be determined automatically.</p>
<p>Adds all input arguments element-wise.</p>
<p>.. math::    add_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n</p>
<p>$add_n$ is potentially more efficient than calling $add$ by <code>n</code> times.</p>
<p>The storage type of $add_n$ output depends on storage types of inputs</p>
<ul>
<li>add_n(row_sparse, row_sparse, ..) = row_sparse</li>
<li>otherwise, $add_n$ generates output with default storage</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_sum.cc:L123</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>args::NDArray-or-SymbolicNode[]</code>: Positional input arguments</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1507' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.add_to!-Tuple{MXNet.mx.NDArray,Vararg{Union{MXNet.mx.NDArray, Real},N} where N}' href='#MXNet.mx.add_to!-Tuple{MXNet.mx.NDArray,Vararg{Union{MXNet.mx.NDArray, Real},N} where N}'>#</a>
<strong><code>MXNet.mx.add_to!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>add_to!(dst::NDArray, args::NDArrayOrReal...)
</code></pre>

<p>Add a bunch of arguments into <code>dst</code>. Inplace updating.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L588-L592' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.argmax-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.argmax-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.argmax</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>argmax(data, axis, keepdims)
</code></pre>

<p>Returns indices of the maximum values along an axis.</p>
<p>In the case of multiple occurrences of maximum values, the indices corresponding to the first occurrence are returned.</p>
<p>Examples::</p>
<p>x = [[ 0.,  1.,  2.],        [ 3.,  4.,  5.]]</p>
<p>// argmax along axis 0   argmax(x, axis=0) = [ 1.,  1.,  1.]</p>
<p>// argmax along axis 1   argmax(x, axis=1) = [ 2.,  2.]</p>
<p>// argmax along axis 1 keeping same dims as an input array   argmax(x, axis=1, keepdims=True) = [[ 2.],                                       [ 2.]]</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L52</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>axis::int or None, optional, default='None'</code>: The axis along which to perform the reduction. Negative values means indexing from right to left. $Requires axis to be set as int, because global reduction is not supported yet.$</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axis is left in the result as dimension with size one.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1517' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.argmax_channel-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.argmax_channel-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.argmax_channel</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>argmax_channel(data)
</code></pre>

<p>Returns argmax indices of each channel from the input array.</p>
<p>The result will be an NDArray of shape (num_channel,).</p>
<p>In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence are returned.</p>
<p>Examples::</p>
<p>x = [[ 0.,  1.,  2.],        [ 3.,  4.,  5.]]</p>
<p>argmax_channel(x) = [ 2.,  2.]</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L97</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1507' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.argmin-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.argmin-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.argmin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>argmin(data, axis, keepdims)
</code></pre>

<p>Returns indices of the minimum values along an axis.</p>
<p>In the case of multiple occurrences of minimum values, the indices corresponding to the first occurrence are returned.</p>
<p>Examples::</p>
<p>x = [[ 0.,  1.,  2.],        [ 3.,  4.,  5.]]</p>
<p>// argmin along axis 0   argmin(x, axis=0) = [ 0.,  0.,  0.]</p>
<p>// argmin along axis 1   argmin(x, axis=1) = [ 0.,  0.]</p>
<p>// argmin along axis 1 keeping same dims as an input array   argmin(x, axis=1, keepdims=True) = [[ 0.],                                       [ 0.]]</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L77</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>axis::int or None, optional, default='None'</code>: The axis along which to perform the reduction. Negative values means indexing from right to left. $Requires axis to be set as int, because global reduction is not supported yet.$</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axis is left in the result as dimension with size one.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1517' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.argsort-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.argsort-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.argsort</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>argsort(data, axis, is_ascend)
</code></pre>

<p>Returns the indices that would sort an input array along the given axis.</p>
<p>This function performs sorting along the given axis and returns an array of indices having same shape as an input array that index data in sorted order.</p>
<p>Examples::</p>
<p>x = [[ 0.3,  0.2,  0.4],        [ 0.1,  0.3,  0.2]]</p>
<p>// sort along axis -1   argsort(x) = [[ 1.,  0.,  2.],                 [ 0.,  2.,  1.]]</p>
<p>// sort along axis 0   argsort(x, axis=0) = [[ 1.,  0.,  1.]                         [ 0.,  1.,  0.]]</p>
<p>// flatten and then sort   argsort(x) = [ 3.,  1.,  5.,  0.,  4.,  2.]</p>
<p>Defined in src/operator/tensor/ordering_op.cc:L176</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>axis::int or None, optional, default='-1'</code>: Axis along which to sort the input tensor. If not given, the flattened array is used. Default is -1.</li>
<li><code>is_ascend::boolean, optional, default=1</code>: Whether to sort in ascending or descending order.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1517' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.batch_dot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.batch_dot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.batch_dot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>batch_dot(lhs, rhs, transpose_a, transpose_b)
</code></pre>

<p>Batchwise dot product.</p>
<p>$batch_dot$ is used to compute dot product of $x$ and $y$ when $x$ and $y$ are data in batch, namely 3D arrays in shape of <code>(batch_size, :, :)</code>.</p>
<p>For example, given $x$ with shape <code>(batch_size, n, m)</code> and $y$ with shape <code>(batch_size, m, k)</code>, the result array will have shape <code>(batch_size, n, k)</code>, which is computed by::</p>
<p>batch_dot(x,y)[i,:,:] = dot(x[i,:,:], y[i,:,:])</p>
<p>Defined in src/operator/tensor/dot.cc:L109</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: The first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: The second input</li>
<li><code>transpose_a::boolean, optional, default=0</code>: If true then transpose the first input before dot.</li>
<li><code>transpose_b::boolean, optional, default=0</code>: If true then transpose the second input before dot.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1510' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.batch_take-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.batch_take-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.batch_take</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>batch_take(a, indices)
</code></pre>

<p>Takes elements from a data batch.</p>
<p>.. note::   <code>batch_take</code> is deprecated. Use <code>pick</code> instead.</p>
<p>Given an input array of shape $(d0, d1)$ and indices of shape $(i0,)$, the result will be an output array of shape $(i0,)$ with::</p>
<p>output[i] = input[i, indices[i]]</p>
<p>Examples::</p>
<p>x = [[ 1.,  2.],        [ 3.,  4.],        [ 5.,  6.]]</p>
<p>// takes elements with specified indices   batch_take(x, [0,1,0]) = [ 1.  4.  5.]</p>
<p>Defined in src/operator/tensor/indexing_op.cc:L382</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>indices::NDArray-or-SymbolicNode</code>: The index array</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1514' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_add-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_add-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_add</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_add(lhs, rhs)
</code></pre>

<p>Returns element-wise sum of the input arrays with broadcasting.</p>
<p><code>broadcast_plus</code> is an alias to the function <code>broadcast_add</code>.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_add(x, y) = [[ 1.,  1.,  1.],                           [ 2.,  2.,  2.]]</p>
<p>broadcast_plus(x, y) = [[ 1.,  1.,  1.],                            [ 2.,  2.,  2.]]</p>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L51</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1513' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_axes-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_axes-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_axes</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_axes(data, axis, size)
</code></pre>

<p>broadcast_axes is an alias of broadcast_axis.</p>
<p>Broadcasts the input array over particular axes.</p>
<p>Broadcasting is allowed on axes with size 1, such as from <code>(2,1,3,1)</code> to <code>(2,8,3,9)</code>. Elements will be duplicated on the broadcasted axes.</p>
<p>Example::</p>
<p>// given x of shape (1,2,1)    x = [[[ 1.],          [ 2.]]]</p>
<p>// broadcast x on on axis 2    broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],                                          [ 2.,  2.,  2.]]]    // broadcast x on on axes 0 and 2    broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],                                                  [ 2.,  2.,  2.]],                                                 [[ 1.,  1.,  1.],                                                  [ 2.,  2.,  2.]]]</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L207</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>axis::Shape(tuple), optional, default=[]</code>: The axes to perform the broadcasting.</li>
<li><code>size::Shape(tuple), optional, default=[]</code>: Target sizes of the broadcasting axes.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1518' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_axis-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_axis-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_axis</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_axis(data, axis, size)
</code></pre>

<p>Broadcasts the input array over particular axes.</p>
<p>Broadcasting is allowed on axes with size 1, such as from <code>(2,1,3,1)</code> to <code>(2,8,3,9)</code>. Elements will be duplicated on the broadcasted axes.</p>
<p>Example::</p>
<p>// given x of shape (1,2,1)    x = [[[ 1.],          [ 2.]]]</p>
<p>// broadcast x on on axis 2    broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],                                          [ 2.,  2.,  2.]]]    // broadcast x on on axes 0 and 2    broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],                                                  [ 2.,  2.,  2.]],                                                 [[ 1.,  1.,  1.],                                                  [ 2.,  2.,  2.]]]</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L207</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>axis::Shape(tuple), optional, default=[]</code>: The axes to perform the broadcasting.</li>
<li><code>size::Shape(tuple), optional, default=[]</code>: Target sizes of the broadcasting axes.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1516' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_div-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_div-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_div</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_div(lhs, rhs)
</code></pre>

<p>Returns element-wise division of the input arrays with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 6.,  6.,  6.],         [ 6.,  6.,  6.]]</p>
<p>y = [[ 2.],         [ 3.]]</p>
<p>broadcast_div(x, y) = [[ 3.,  3.,  3.],                           [ 2.,  2.,  2.]]</p>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L157</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_equal(lhs, rhs)
</code></pre>

<p>Returns the result of element-wise <strong>equal to</strong> (==) comparison operation with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_equal(x, y) = [[ 0.,  0.,  0.],                             [ 1.,  1.,  1.]]</p>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L46</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_greater-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_greater-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_greater</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_greater(lhs, rhs)
</code></pre>

<p>Returns the result of element-wise <strong>greater than</strong> (&gt;) comparison operation with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_greater(x, y) = [[ 1.,  1.,  1.],                               [ 0.,  0.,  0.]]</p>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L82</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_greater_equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_greater_equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_greater_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_greater_equal(lhs, rhs)
</code></pre>

<p>Returns the result of element-wise <strong>greater than or equal to</strong> (&gt;=) comparison operation with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_greater_equal(x, y) = [[ 1.,  1.,  1.],                                     [ 1.,  1.,  1.]]</p>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L100</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_hypot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_hypot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_hypot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_hypot(lhs, rhs)
</code></pre>

<p>Returns the hypotenuse of a right angled triangle, given its "legs" with broadcasting.</p>
<p>It is equivalent to doing :math:<code>sqrt(x_1^2 + x_2^2)</code>.</p>
<p>Example::</p>
<p>x = [[ 3.,  3.,  3.]]</p>
<p>y = [[ 4.],         [ 4.]]</p>
<p>broadcast_hypot(x, y) = [[ 5.,  5.,  5.],                             [ 5.,  5.,  5.]]</p>
<p>z = [[ 0.],         [ 4.]]</p>
<p>broadcast_hypot(x, z) = [[ 3.,  3.,  3.],                             [ 5.,  5.,  5.]]</p>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L156</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1516' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_lesser-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_lesser-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_lesser</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_lesser(lhs, rhs)
</code></pre>

<p>Returns the result of element-wise <strong>lesser than</strong> (&lt;) comparison operation with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_lesser(x, y) = [[ 0.,  0.,  0.],                              [ 0.,  0.,  0.]]</p>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L118</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_lesser_equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_lesser_equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_lesser_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_lesser_equal(lhs, rhs)
</code></pre>

<p>Returns the result of element-wise <strong>lesser than or equal to</strong> (&lt;=) comparison operation with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_lesser_equal(x, y) = [[ 0.,  0.,  0.],                                    [ 1.,  1.,  1.]]</p>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L136</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_maximum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_maximum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_maximum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_maximum(lhs, rhs)
</code></pre>

<p>Returns element-wise maximum of the input arrays with broadcasting.</p>
<p>This function compares two input arrays and returns a new array having the element-wise maxima.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_maximum(x, y) = [[ 1.,  1.,  1.],                               [ 1.,  1.,  1.]]</p>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L80</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1510' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_minimum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_minimum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_minimum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_minimum(lhs, rhs)
</code></pre>

<p>Returns element-wise minimum of the input arrays with broadcasting.</p>
<p>This function compares two input arrays and returns a new array having the element-wise minima.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_maximum(x, y) = [[ 0.,  0.,  0.],                               [ 1.,  1.,  1.]]</p>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L115</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1510' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_minus-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_minus-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_minus</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_minus(lhs, rhs)
</code></pre>

<p>broadcast_minus is an alias of broadcast_sub.</p>
<p>Returns element-wise difference of the input arrays with broadcasting.</p>
<p><code>broadcast_minus</code> is an alias to the function <code>broadcast_sub</code>.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_sub(x, y) = [[ 1.,  1.,  1.],                           [ 0.,  0.,  0.]]</p>
<p>broadcast_minus(x, y) = [[ 1.,  1.,  1.],                             [ 0.,  0.,  0.]]</p>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L90</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1515' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_mod-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_mod-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_mod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_mod(lhs, rhs)
</code></pre>

<p>Returns element-wise modulo of the input arrays with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 8.,  8.,  8.],         [ 8.,  8.,  8.]]</p>
<p>y = [[ 2.],         [ 3.]]</p>
<p>broadcast_mod(x, y) = [[ 0.,  0.,  0.],                           [ 2.,  2.,  2.]]</p>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L190</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_mul-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_mul-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_mul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_mul(lhs, rhs)
</code></pre>

<p>Returns element-wise product of the input arrays with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_mul(x, y) = [[ 0.,  0.,  0.],                           [ 1.,  1.,  1.]]</p>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L123</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_not_equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_not_equal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_not_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_not_equal(lhs, rhs)
</code></pre>

<p>Returns the result of element-wise <strong>not equal to</strong> (!=) comparison operation with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_not_equal(x, y) = [[ 1.,  1.,  1.],                                 [ 0.,  0.,  0.]]</p>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L64</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_plus-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_plus-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_plus</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_plus(lhs, rhs)
</code></pre>

<p>broadcast_plus is an alias of broadcast_add.</p>
<p>Returns element-wise sum of the input arrays with broadcasting.</p>
<p><code>broadcast_plus</code> is an alias to the function <code>broadcast_add</code>.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_add(x, y) = [[ 1.,  1.,  1.],                           [ 2.,  2.,  2.]]</p>
<p>broadcast_plus(x, y) = [[ 1.,  1.,  1.],                            [ 2.,  2.,  2.]]</p>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L51</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1515' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_power-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_power-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_power</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_power(lhs, rhs)
</code></pre>

<p>Returns result of first array elements raised to powers from second array, element-wise with broadcasting.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_power(x, y) = [[ 2.,  2.,  2.],                             [ 4.,  4.,  4.]]</p>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L45</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_sub-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_sub-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_sub</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_sub(lhs, rhs)
</code></pre>

<p>Returns element-wise difference of the input arrays with broadcasting.</p>
<p><code>broadcast_minus</code> is an alias to the function <code>broadcast_sub</code>.</p>
<p>Example::</p>
<p>x = [[ 1.,  1.,  1.],         [ 1.,  1.,  1.]]</p>
<p>y = [[ 0.],         [ 1.]]</p>
<p>broadcast_sub(x, y) = [[ 1.,  1.,  1.],                           [ 0.,  0.,  0.]]</p>
<p>broadcast_minus(x, y) = [[ 1.,  1.,  1.],                             [ 0.,  0.,  0.]]</p>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L90</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input to the function</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input to the function</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1513' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.broadcast_to-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.broadcast_to-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.broadcast_to</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>broadcast_to(data, shape)
</code></pre>

<p>Broadcasts the input array to a new shape.</p>
<p>Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations with arrays of different shapes efficiently without creating multiple copies of arrays. Also see, <code>Broadcasting &lt;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&gt;</code>_ for more explanation.</p>
<p>Broadcasting is allowed on axes with size 1, such as from <code>(2,1,3,1)</code> to <code>(2,8,3,9)</code>. Elements will be duplicated on the broadcasted axes.</p>
<p>For example::</p>
<p>broadcast_to([[1,2,3]], shape=(2,3)) = [[ 1.,  2.,  3.],                                            [ 1.,  2.,  3.]])</p>
<p>The dimension which you do not want to change can also be kept as <code>0</code> which means copy the original value. So with <code>shape=(2,0)</code>, we will obtain the same result as in the above example.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L231</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: The shape of the desired array. We can set the dim to zero if it's same as the original. E.g <code>A = broadcast_to(B, shape=(10, 0, 0))</code> has the same meaning as <code>A = broadcast_axis(B, axis=0, size=10)</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1512' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.cast-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.cast-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.cast</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cast(data, dtype)
</code></pre>

<p>cast is an alias of Cast.</p>
<p>Casts all elements of the input to a new type.</p>
<p>.. note:: $Cast$ is deprecated. Use $cast$ instead.</p>
<p>Example::</p>
<p>cast([0.9, 1.3], dtype='int32') = [0, 1]    cast([1e20, 11.1], dtype='float16') = [inf, 11.09375]    cast([300, 11.1, 10.9, -1, -3], dtype='uint8') = [44, 11, 10, 255, 253]</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L311</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>dtype::{'float16', 'float32', 'float64', 'int32', 'uint8'}, required</code>: Output data type.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1507' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.cast_storage-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.cast_storage-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.cast_storage</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cast_storage(data, stype)
</code></pre>

<p>Casts tensor storage type to the new type.</p>
<p>When an NDArray with default storage type is cast to csr or row_sparse storage, the result is compact, which means:</p>
<ul>
<li>for csr, zero values will not be retained</li>
<li>for row_sparse, row slices of all zeros will not be retained</li>
</ul>
<p>The storage type of $cast_storage$ output depends on stype parameter:</p>
<ul>
<li>cast_storage(csr, 'default') = default</li>
<li>cast_storage(row_sparse, 'default') = default</li>
<li>cast_storage(default, 'csr') = csr</li>
<li>cast_storage(default, 'row_sparse') = row_sparse</li>
</ul>
<p>Example::</p>
<pre><code>dense = [[ 0.,  1.,  0.],
         [ 2.,  0.,  3.],
         [ 0.,  0.,  0.],
         [ 0.,  0.,  0.]]

# cast to row_sparse storage type
rsp = cast_storage(dense, 'row_sparse')
rsp.indices = [0, 1]
rsp.values = [[ 0.,  1.,  0.],
              [ 2.,  0.,  3.]]

# cast to csr storage type
csr = cast_storage(dense, 'csr')
csr.indices = [1, 0, 2]
csr.values = [ 1.,  2.,  3.]
csr.indptr = [0, 1, 3, 3, 3]
</code></pre>

<p>Defined in src/operator/tensor/cast_storage.cc:L69</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input.</li>
<li><code>stype::{'csr', 'default', 'row_sparse'}, required</code>: Output storage type.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1529' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.choose_element_0index-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.choose_element_0index-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.choose_element_0index</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>choose_element_0index(lhs, rhs)
</code></pre>

<p>Choose one element from each line(row for python, column for R/Julia) in lhs according to index indicated by rhs. This function assume rhs uses 0-based index.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray</code>: Left operand to the function.</li>
<li><code>rhs::NDArray</code>: Right operand to the function.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.clip-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.clip-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.clip</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>clip(data, a_min, a_max)
</code></pre>

<p>Clips (limits) the values in an array.</p>
<p>Given an interval, values outside the interval are clipped to the interval edges. Clipping $x$ between <code>a_min</code> and <code>a_x</code> would be::</p>
<p>clip(x, a_min, a_max) = max(min(x, a_max), a_min))</p>
<p>Example::</p>
<pre><code>x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

clip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]
</code></pre>

<p>The storage type of $clip$ output depends on storage types of inputs and the a_min, a_max 
parameter values:</p>
<ul>
<li>clip(default) = default</li>
<li>clip(row_sparse, a_min &lt;= 0, a_max &gt;= 0) = row_sparse</li>
<li>clip(csr, a_min &lt;= 0, a_max &gt;= 0) = csr</li>
<li>clip(row_sparse, a_min &lt; 0, a_max &lt; 0) = default</li>
<li>clip(row_sparse, a_min &gt; 0, a_max &gt; 0) = default</li>
<li>clip(csr, a_min &lt; 0, a_max &lt; 0) = csr</li>
<li>clip(csr, a_min &gt; 0, a_max &gt; 0) = csr</li>
</ul>
<p>Defined in src/operator/tensor/matrix_op.cc:L486</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
<li><code>a_min::float, required</code>: Minimum value</li>
<li><code>a_max::float, required</code>: Maximum value</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1521' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.concat-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.concat-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.concat</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>concat(data, num_args, dim)
</code></pre>

<p>concat is an alias of Concat.</p>
<p><strong>Note</strong>: concat takes variable number of positional inputs. So instead of calling as concat([x, y, z], num_args=3), one should call via concat(x, y, z), and num_args will be determined automatically.</p>
<p>Joins input arrays along a given axis.</p>
<p>.. note:: <code>Concat</code> is deprecated. Use <code>concat</code> instead.</p>
<p>The dimensions of the input arrays should be the same except the axis along which they will be concatenated. The dimension of the output array along the concatenated axis will be equal to the sum of the corresponding dimensions of the input arrays.</p>
<p>Example::</p>
<p>x = [[1,1],[2,2]]    y = [[3,3],[4,4],[5,5]]    z = [[6,6], [7,7],[8,8]]</p>
<p>concat(x,y,z,dim=0) = [[ 1.,  1.],                           [ 2.,  2.],                           [ 3.,  3.],                           [ 4.,  4.],                           [ 5.,  5.],                           [ 6.,  6.],                           [ 7.,  7.],                           [ 8.,  8.]]</p>
<p>Note that you cannot concat x,y,z along dimension 1 since dimension    0 is not the same for all the input arrays.</p>
<p>concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],                          [ 4.,  4.,  7.,  7.],                          [ 5.,  5.,  8.,  8.]]</p>
<p>Defined in src/operator/concat.cc:L104</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: List of arrays to concatenate</li>
<li><code>num_args::int, required</code>: Number of inputs to be concated.</li>
<li><code>dim::int, optional, default='1'</code>: the dimension to be concated.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1532' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.crop-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.crop-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.crop</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>crop(data, begin, end, step)
</code></pre>

<p>crop is an alias of slice.</p>
<p>Slices a region of the array.</p>
<p>.. note:: $crop$ is deprecated. Use $slice$ instead.</p>
<p>This function returns a sliced array between the indices given by <code>begin</code> and <code>end</code> with the corresponding <code>step</code>.</p>
<p>For an input array of $shape=(d_0, d_1, ..., d_n-1)$, slice operation with $begin=(b_0, b_1...b_m-1)$, $end=(e_0, e_1, ..., e_m-1)$, and $step=(s_0, s_1, ..., s_m-1)$, where m &lt;= n, results in an array with the shape $(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)$.</p>
<p>The resulting array's <em>k</em>-th dimension contains elements from the <em>k</em>-th dimension of the input array starting from index $b_k$ (inclusive) with step $s_k$ until reaching $e_k$ (exclusive).</p>
<p>If the <em>k</em>-th elements are <code>None</code> in the sequence of <code>begin</code>, <code>end</code>, and <code>step</code>, the following rule will be used to set default values. If <code>s_k</code> is <code>None</code>, set <code>s_k=1</code>. If <code>s_k &gt; 0</code>, set <code>b_k=0</code>, <code>e_k=d_k</code>; else, set <code>b_k=d_k-1</code>, <code>e_k=-1</code>.</p>
<p>The storage type of $slice$ output depends on storage types of inputs</p>
<ul>
<li>slice(csr) = csr</li>
<li>otherwise, $slice$ generates output with default storage</li>
</ul>
<p>.. note:: When input data storage type is csr, it only supports step=(), or step=(None,), or step=(1,) to generate a csr output. For other step parameter values, it falls back to slicing a dense tensor.</p>
<p>Example::</p>
<p>x = [[  1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.],        [  9.,  10.,  11.,  12.]]</p>
<p>slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],                                      [ 6.,  7.,  8.]]   slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],                                                             [5.,  7.],                                                             [1.,  3.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L355</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>begin::Shape(tuple), required</code>: starting indices for the slice operation, supports negative indices.</li>
<li><code>end::Shape(tuple), required</code>: ending indices for the slice operation, supports negative indices.</li>
<li><code>step::Shape(tuple), optional, default=[]</code>: step for the slice operation, supports negative values.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1545' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.degrees-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.degrees-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.degrees</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>degrees(data)
</code></pre>

<p>Converts each element of the input array from radians to degrees.</p>
<p>.. math::    degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]</p>
<p>The storage type of $degrees$ output depends upon the input storage type:</p>
<ul>
<li>degrees(default) = default</li>
<li>degrees(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L163</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1503' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.div_from!-Tuple{MXNet.mx.NDArray,Union{MXNet.mx.NDArray, Real}}' href='#MXNet.mx.div_from!-Tuple{MXNet.mx.NDArray,Union{MXNet.mx.NDArray, Real}}'>#</a>
<strong><code>MXNet.mx.div_from!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>div_from!(dst::NDArray, arg::NDArrayOrReal)
</code></pre>

<p>Elementwise divide a scalar or an <code>NDArray</code> of the same shape from <code>dst</code>. Inplace updating.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L693-L697' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.elemwise_add-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.elemwise_add-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.elemwise_add</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>elemwise_add(lhs, rhs)
</code></pre>

<p>Adds arguments element-wise.</p>
<p>The storage type of $elemwise_add$ output depends on storage types of inputs</p>
<ul>
<li>elemwise_add(row_sparse, row_sparse) = row_sparse</li>
<li>elemwise_add(csr, csr) = csr</li>
<li>otherwise, $elemwise_add$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1501' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.elemwise_div-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.elemwise_div-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.elemwise_div</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>elemwise_div(lhs, rhs)
</code></pre>

<p>Divides arguments element-wise.</p>
<p>The storage type of $elemwise_div$ output is always dense</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1497' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.elemwise_mul-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.elemwise_mul-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.elemwise_mul</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>elemwise_mul(lhs, rhs)
</code></pre>

<p>Multiplies arguments element-wise.</p>
<p>The storage type of $elemwise_mul$ output depends on storage types of inputs</p>
<ul>
<li>elemwise_mul(default, default) = default</li>
<li>elemwise_mul(row_sparse, row_sparse) = row_sparse</li>
<li>elemwise_mul(default, row_sparse) = default</li>
<li>elemwise_mul(row_sparse, default) = default</li>
<li>elemwise_mul(csr, csr) = csr</li>
<li>otherwise, $elemwise_mul$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1504' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.elemwise_sub-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.elemwise_sub-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.elemwise_sub</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>elemwise_sub(lhs, rhs)
</code></pre>

<p>Subtracts arguments element-wise.</p>
<p>The storage type of $elemwise_sub$ output depends on storage types of inputs</p>
<ul>
<li>elemwise_sub(row_sparse, row_sparse) = row_sparse</li>
<li>elemwise_sub(csr, csr) = csr</li>
<li>otherwise, $elemwise_sub$ generates output with default storage</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: first input</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: second input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1501' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.fill-Union{Tuple{Any,Tuple{Vararg{Integer,N}},MXNet.mx.Context}, Tuple{Any,Tuple{Vararg{Integer,N}}}, Tuple{N}} where N' href='#MXNet.mx.fill-Union{Tuple{Any,Tuple{Vararg{Integer,N}},MXNet.mx.Context}, Tuple{Any,Tuple{Vararg{Integer,N}}}, Tuple{N}} where N'>#</a>
<strong><code>MXNet.mx.fill</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>fill(x, dims, ctx=cpu())
fill(x, dims...)
</code></pre>

<p>Create an <code>NDArray</code> filled with the value <code>x</code>, like <code>Base.fill</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L788-L793' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.fill_element_0index-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.fill_element_0index-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.fill_element_0index</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>fill_element_0index(lhs, mhs, rhs)
</code></pre>

<p>Fill one element of each line(row for python, column for R/Julia) in lhs according to index indicated by rhs and values indicated by mhs. This function assume rhs uses 0-based index.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray</code>: Left operand to the function.</li>
<li><code>mhs::NDArray</code>: Middle operand to the function.</li>
<li><code>rhs::NDArray</code>: Right operand to the function.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1495' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.fix-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.fix-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.fix</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>fix(data)
</code></pre>

<p>Returns element-wise rounded value to the nearest 
integer towards zero of the input.</p>
<p>Example::</p>
<p>fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1.,  1., 2.]</p>
<p>The storage type of $fix$ output depends upon the input storage type:</p>
<ul>
<li>fix(default) = default</li>
<li>fix(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L521</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1505' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.flatten-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.flatten-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.flatten</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>flatten(data)
</code></pre>

<p>flatten is an alias of Flatten.</p>
<p>Flattens the input array into a 2-D array by collapsing the higher dimensions.</p>
<p>.. note:: <code>Flatten</code> is deprecated. Use <code>flatten</code> instead.</p>
<p>For an input array with shape $(d1, d2, ..., dk)$, <code>flatten</code> operation reshapes the input array into an output array of shape $(d1, d2<em>...</em>dk)$.</p>
<p>Example::</p>
<pre><code>x = [[
    [1,2,3],
    [4,5,6],
    [7,8,9]
],
[    [1,2,3],
    [4,5,6],
    [7,8,9]
]],

flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],
   [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]
</code></pre>

<p>Defined in src/operator/tensor/matrix_op.cc:L208</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1517' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.flip-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.flip-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.flip</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>flip(data, axis)
</code></pre>

<p>flip is an alias of reverse.</p>
<p>Reverses the order of elements along given axis while preserving array shape.</p>
<p>Note: reverse and flip are equivalent. We use reverse in the following examples.</p>
<p>Examples::</p>
<p>x = [[ 0.,  1.,  2.,  3.,  4.],        [ 5.,  6.,  7.,  8.,  9.]]</p>
<p>reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],                         [ 0.,  1.,  2.,  3.,  4.]]</p>
<p>reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],                         [ 9.,  8.,  7.,  6.,  5.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L662</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data array</li>
<li><code>axis::Shape(tuple), required</code>: The axis which to reverse elements.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1511' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ftrl_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.ftrl_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.ftrl_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ftrl_update(weight, grad, z, n, lr, lamda1, beta, wd, rescale_grad, clip_gradient)
</code></pre>

<p>Update function for Ftrl optimizer. Referenced from <em>Ad Click Prediction: a View from the Trenches</em>, available at http://dl.acm.org/citation.cfm?id=2488200.</p>
<p>It updates the weights using::</p>
<p>rescaled_grad = clip(grad * rescale_grad, clip_gradient)  z += rescaled_grad - (sqrt(n + rescaled_grad<strong>2) - sqrt(n)) * weight / learning_rate  n += rescaled_grad</strong>2  w = (sign(z) * lamda1 - z) / ((beta + sqrt(n)) / learning_rate + wd) * (abs(z) &gt; lamda1)</p>
<p>If w, z and n are all of $row_sparse$ storage type, only the row slices whose indices appear in grad.indices are updated (for w, z and n)::</p>
<p>for row in grad.indices:      rescaled_grad[row] = clip(grad[row] * rescale_grad, clip_gradient)      z[row] += rescaled_grad[row] - (sqrt(n[row] + rescaled_grad[row]<strong>2) - sqrt(n[row])) * weight[row] / learning_rate      n[row] += rescaled_grad[row]</strong>2      w[row] = (sign(z[row]) * lamda1 - z[row]) / ((beta + sqrt(n[row])) / learning_rate + wd) * (abs(z[row]) &gt; lamda1)</p>
<p>Defined in src/operator/optimizer_op.cc:L308</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>z::NDArray-or-SymbolicNode</code>: z</li>
<li><code>n::NDArray-or-SymbolicNode</code>: Square of grad</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>lamda1::float, optional, default=0.01</code>: The L1 regularization coefficient.</li>
<li><code>beta::float, optional, default=1</code>: Per-Coordinate Learning Rate beta.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1531' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.gammaln-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.gammaln-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.gammaln</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>gammaln(data)
</code></pre>

<p>Returns element-wise log of the absolute value of the gamma function 
of the input.</p>
<p>The storage type of $gammaln$ output is always dense</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1496' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.gather_nd-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.gather_nd-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.gather_nd</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>gather_nd(data, indices)
</code></pre>

<p>Gather elements or slices from <code>data</code> and store to a tensor whose shape is defined by <code>indices</code>. <code>gather_nd</code> and <code>scatter_nd</code> are inverse functions to each other.</p>
<p>Given <code>data</code> with shape <code>(X_0, X_1, ..., X_{N-1})</code> and indices with shape <code>(M, Y_0, ..., Y_{K-1})</code>, the output will have shape <code>(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})</code>, where <code>M &lt;= N</code>. If <code>M == N</code>, output shape will simply be <code>(Y_0, ..., Y_{K-1})</code>.</p>
<p>The elements in output is defined as follows::</p>
<p>output[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}] = data[indices[0, y_0, ..., y_{K-1}],                                                       ...,                                                       indices[M-1, y_0, ..., y_{K-1}],                                                       x_M, ..., x_{N-1}]</p>
<p>Examples::</p>
<p>data = [[0, 1], [2, 3]]   indices = [[1, 1, 0], [0, 1, 0]]   gather_nd(data, indices) = [2, 3, 0]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: data</li>
<li><code>indices::NDArray-or-SymbolicNode</code>: indices</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1514' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.is_shared-Tuple{Array,MXNet.mx.NDArray}' href='#MXNet.mx.is_shared-Tuple{Array,MXNet.mx.NDArray}'>#</a>
<strong><code>MXNet.mx.is_shared</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>is_shared(j_arr, arr)
</code></pre>

<p>Test whether <code>j_arr</code> is sharing data with <code>arr</code>.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>j_arr::Array</code>: the Julia Array.</li>
<li><code>arr::NDArray</code>: the <code>NDArray</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L963-L972' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.khatri_rao-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.khatri_rao-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.khatri_rao</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>khatri_rao(args)
</code></pre>

<p><strong>Note</strong>: khatri_rao takes variable number of positional inputs. So instead of calling as khatri_rao([x, y, z], num_args=3), one should call via khatri_rao(x, y, z), and num_args will be determined automatically.</p>
<p>Computes the Khatri-Rao product of the input matrices.</p>
<p>Given a collection of :math:<code>n</code> input matrices,</p>
<p>.. math::    A_1 \in \mathbb{R}^{M_1 \times M}, \ldots, A_n \in \mathbb{R}^{M_n \times N},</p>
<p>the (column-wise) Khatri-Rao product is defined as the matrix,</p>
<p>.. math::    X = A_1 \otimes \cdots \otimes A_n \in \mathbb{R}^{(M_1 \cdots M_n) \times N},</p>
<p>where the :math:<code>k</code>th column is equal to the column-wise outer product :math:<code>{A_1}_k \otimes \cdots \otimes {A_n}_k</code> where :math:<code>{A_i}_k</code> is the kth column of the ith matrix.</p>
<p>Example::</p>
<blockquote>
<blockquote>
<blockquote>
<p>A = mx.nd.array([[1, -1],                  [2, -3]]) B = mx.nd.array([[1, 4],                  [2, 5],                  [3, 6]]) C = mx.nd.khatri_rao(A, B) print(C.asnumpy())</p>
</blockquote>
</blockquote>
</blockquote>
<p>[[  1.  -4.]    [  2.  -5.]    [  3.  -6.]    [  2. -12.]    [  4. -15.]    [  6. -18.]]</p>
<p>Defined in src/operator/contrib/krprod.cc:L108</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>args::NDArray-or-SymbolicNode[]</code>: Positional input matrices</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1527' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_gelqf-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.linalg_gelqf-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_gelqf</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>linalg_gelqf(A)
</code></pre>

<p>linalg_gelqf is an alias of _linalg_gelqf.</p>
<p>LQ factorization for general matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, we compute the LQ factorization (LAPACK <em>gelqf</em>, followed by <em>orglq</em>). <em>A</em> must have shape <em>(x, y)</em> with <em>x &lt;= y</em>, and must have full rank <em>=x</em>. The LQ factorization consists of <em>L</em> with shape <em>(x, x)</em> and <em>Q</em> with shape <em>(x, y)</em>, so that:</p>
<p><em>A</em> = <em>L</em> * <em>Q</em></p>
<p>Here, <em>L</em> is lower triangular (upper triangle equal to zero) with nonzero diagonal, and <em>Q</em> is row-orthonormal, meaning that</p>
<p><em>Q</em> * <em>Q</em>\ :sup:<code>T</code></p>
<p>is equal to the identity matrix of shape <em>(x, x)</em>.</p>
<p>If <em>n&gt;2</em>, <em>gelqf</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>// Single LQ factorization    A = [[1., 2., 3.], [4., 5., 6.]]    Q, L = gelqf(A)    Q = [[-0.26726124, -0.53452248, -0.80178373],         [0.87287156, 0.21821789, -0.43643578]]    L = [[-3.74165739, 0.],         [-8.55235974, 1.96396101]]</p>
<p>// Batch LQ factorization    A = [[[1., 2., 3.], [4., 5., 6.]],         [[7., 8., 9.], [10., 11., 12.]]]    Q, L = gelqf(A)    Q = [[[-0.26726124, -0.53452248, -0.80178373],          [0.87287156, 0.21821789, -0.43643578]],         [[-0.50257071, -0.57436653, -0.64616234],          [0.7620735, 0.05862104, -0.64483142]]]    L = [[[-3.74165739, 0.],          [-8.55235974, 1.96396101]],         [[-13.92838828, 0.],          [-19.09768702, 0.52758934]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L529</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices to be factorized</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1539' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_gemm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.linalg_gemm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_gemm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>linalg_gemm(A, B, C, transpose_a, transpose_b, alpha, beta)
</code></pre>

<p>linalg_gemm is an alias of _linalg_gemm.</p>
<p>Performs general matrix multiplication and accumulation. Input are tensors <em>A</em>, <em>B</em>, <em>C</em>, each of dimension <em>n &gt;= 2</em> and having the same shape on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, the BLAS3 function <em>gemm</em> is performed:</p>
<p><em>out</em> = <em>alpha</em> * <em>op</em>\ (<em>A</em>) * <em>op</em>\ (<em>B</em>) + <em>beta</em> * <em>C</em></p>
<p>Here, <em>alpha</em> and <em>beta</em> are scalar parameters, and <em>op()</em> is either the identity or matrix transposition (depending on <em>transpose_a</em>, <em>transpose_b</em>).</p>
<p>If <em>n&gt;2</em>, <em>gemm</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>// Single matrix multiply-add    A = [[1.0, 1.0], [1.0, 1.0]]    B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]    C = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]    gemm(A, B, C, transpose_b=True, alpha=2.0, beta=10.0)            = [[14.0, 14.0, 14.0], [14.0, 14.0, 14.0]]</p>
<p>// Batch matrix multiply-add    A = [[[1.0, 1.0]], [[0.1, 0.1]]]    B = [[[1.0, 1.0]], [[0.1, 0.1]]]    C = [[[10.0]], [[0.01]]]    gemm(A, B, C, transpose_b=True, alpha=2.0 , beta=10.0)            = [[[104.0]], [[0.14]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L69</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>B::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>C::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>transpose_a::boolean, optional, default=0</code>: Multiply with transposed of first input (A).</li>
<li><code>transpose_b::boolean, optional, default=0</code>: Multiply with transposed of second input (B).</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor multiplied with A*B.</li>
<li><code>beta::double, optional, default=1</code>: Scalar factor multiplied with C.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1538' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_gemm2-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.linalg_gemm2-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_gemm2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>linalg_gemm2(A, B, transpose_a, transpose_b, alpha)
</code></pre>

<p>linalg_gemm2 is an alias of _linalg_gemm2.</p>
<p>Performs general matrix multiplication. Input are tensors <em>A</em>, <em>B</em>, each of dimension <em>n &gt;= 2</em> and having the same shape on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, the BLAS3 function <em>gemm</em> is performed:</p>
<p><em>out</em> = <em>alpha</em> * <em>op</em>\ (<em>A</em>) * <em>op</em>\ (<em>B</em>)</p>
<p>Here <em>alpha</em> is a scalar parameter and <em>op()</em> is either the identity or the matrix transposition (depending on <em>transpose_a</em>, <em>transpose_b</em>).</p>
<p>If <em>n&gt;2</em>, <em>gemm</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>// Single matrix multiply    A = [[1.0, 1.0], [1.0, 1.0]]    B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]    gemm2(A, B, transpose_b=True, alpha=2.0)             = [[4.0, 4.0, 4.0], [4.0, 4.0, 4.0]]</p>
<p>// Batch matrix multiply    A = [[[1.0, 1.0]], [[0.1, 0.1]]]    B = [[[1.0, 1.0]], [[0.1, 0.1]]]    gemm2(A, B, transpose_b=True, alpha=2.0)            = [[[4.0]], [[0.04 ]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L128</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>B::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>transpose_a::boolean, optional, default=0</code>: Multiply with transposed of first input (A).</li>
<li><code>transpose_b::boolean, optional, default=0</code>: Multiply with transposed of second input (B).</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor multiplied with A*B.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1532' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_potrf-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.linalg_potrf-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_potrf</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>linalg_potrf(A)
</code></pre>

<p>linalg_potrf is an alias of _linalg_potrf.</p>
<p>Performs Cholesky factorization of a symmetric positive-definite matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, the Cholesky factor <em>L</em> of the symmetric, positive definite matrix <em>A</em> is computed. <em>L</em> is lower triangular (entries of upper triangle are all zero), has positive diagonal entries, and:</p>
<p><em>A</em> = <em>L</em> * <em>L</em>\ :sup:<code>T</code></p>
<p>If <em>n&gt;2</em>, <em>potrf</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>// Single matrix factorization    A = [[4.0, 1.0], [1.0, 4.25]]    potrf(A) = [[2.0, 0], [0.5, 2.0]]</p>
<p>// Batch matrix factorization    A = [[[4.0, 1.0], [1.0, 4.25]], [[16.0, 4.0], [4.0, 17.0]]]    potrf(A) = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L178</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices to be decomposed</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1518' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_potri-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.linalg_potri-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_potri</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>linalg_potri(A)
</code></pre>

<p>linalg_potri is an alias of _linalg_potri.</p>
<p>Performs matrix inversion from a Cholesky factorization. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> is a lower triangular matrix (entries of upper triangle are all zero) with positive diagonal. We compute:</p>
<p><em>out</em> = <em>A</em>\ :sup:<code>-T</code> * <em>A</em>\ :sup:<code>-1</code></p>
<p>In other words, if <em>A</em> is the Cholesky factor of a symmetric positive definite matrix <em>B</em> (obtained by <em>potrf</em>), then</p>
<p><em>out</em> = <em>B</em>\ :sup:<code>-1</code></p>
<p>If <em>n&gt;2</em>, <em>potri</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>.. note:: Use this operator only if you are certain you need the inverse of <em>B</em>, and           cannot use the Cholesky factor <em>A</em> (<em>potrf</em>), together with backsubstitution           (<em>trsm</em>). The latter is numerically much safer, and also cheaper.</p>
<p>Examples::</p>
<p>// Single matrix inverse    A = [[2.0, 0], [0.5, 2.0]]    potri(A) = [[0.26563, -0.0625], [-0.0625, 0.25]]</p>
<p>// Batch matrix inverse    A = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]    potri(A) = [[[0.26563, -0.0625], [-0.0625, 0.25]],                [[0.06641, -0.01562], [-0.01562, 0,0625]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L236</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of lower triangular matrices</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1527' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_sumlogdiag-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.linalg_sumlogdiag-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_sumlogdiag</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>linalg_sumlogdiag(A)
</code></pre>

<p>linalg_sumlogdiag is an alias of _linalg_sumlogdiag.</p>
<p>Computes the sum of the logarithms of the diagonal elements of a square matrix. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> must be square with positive diagonal entries. We sum the natural logarithms of the diagonal elements, the result has shape (1,).</p>
<p>If <em>n&gt;2</em>, <em>sumlogdiag</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>// Single matrix reduction    A = [[1.0, 1.0], [1.0, 7.0]]    sumlogdiag(A) = [1.9459]</p>
<p>// Batch matrix reduction    A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]    sumlogdiag(A) = [1.9459, 3.9318]</p>
<p>Defined in src/operator/tensor/la_op.cc:L405</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of square matrices</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1515' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_syrk-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.linalg_syrk-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_syrk</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>linalg_syrk(A, transpose, alpha)
</code></pre>

<p>linalg_syrk is an alias of _linalg_syrk.</p>
<p>Multiplication of matrix with its transpose. Input is a tensor <em>A</em> of dimension <em>n &gt;= 2</em>.</p>
<p>If <em>n=2</em>, the operator performs the BLAS3 function <em>syrk</em>:</p>
<p><em>out</em> = <em>alpha</em> * <em>A</em> * <em>A</em>\ :sup:<code>T</code></p>
<p>if <em>transpose=False</em>, or</p>
<p><em>out</em> = <em>alpha</em> * <em>A</em>\ :sup:<code>T</code> \ * <em>A</em></p>
<p>if <em>transpose=True</em>.</p>
<p>If <em>n&gt;2</em>, <em>syrk</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>// Single matrix multiply    A = [[1., 2., 3.], [4., 5., 6.]]    syrk(A, alpha=1., transpose=False)             = [[14., 32.],                [32., 77.]]    syrk(A, alpha=1., transpose=True)             = [[17., 22., 27.],                [22., 29., 36.],                [27., 36., 45.]]</p>
<p>// Batch matrix multiply    A = [[[1., 1.]], [[0.1, 0.1]]]    syrk(A, alpha=2., transpose=False) = [[[4.]], [[0.04]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L461</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of input matrices</li>
<li><code>transpose::boolean, optional, default=0</code>: Use transpose of input matrix.</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor to be applied to the result.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1532' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_trmm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.linalg_trmm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_trmm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>linalg_trmm(A, B, transpose, rightside, alpha)
</code></pre>

<p>linalg_trmm is an alias of _linalg_trmm.</p>
<p>Performs multiplication with a lower triangular matrix. Input are tensors <em>A</em>, <em>B</em>, each of dimension <em>n &gt;= 2</em> and having the same shape on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, <em>A</em> must be lower triangular. The operator performs the BLAS3 function <em>trmm</em>:</p>
<p><em>out</em> = <em>alpha</em> * <em>op</em>\ (<em>A</em>) * <em>B</em></p>
<p>if <em>rightside=False</em>, or</p>
<p><em>out</em> = <em>alpha</em> * <em>B</em> * <em>op</em>\ (<em>A</em>)</p>
<p>if <em>rightside=True</em>. Here, <em>alpha</em> is a scalar parameter, and <em>op()</em> is either the identity or the matrix transposition (depending on <em>transpose</em>).</p>
<p>If <em>n&gt;2</em>, <em>trmm</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>// Single triangular matrix multiply    A = [[1.0, 0], [1.0, 1.0]]    B = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]    trmm(A, B, alpha=2.0) = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]</p>
<p>// Batch triangular matrix multiply    A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]    B = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]], [[0.5, 0.5, 0.5], [0.5, 0.5, 0.5]]]    trmm(A, B, alpha=2.0) = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],                             [[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L293</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of lower triangular matrices</li>
<li><code>B::NDArray-or-SymbolicNode</code>: Tensor of matrices</li>
<li><code>transpose::boolean, optional, default=0</code>: Use transposed of the triangular matrix</li>
<li><code>rightside::boolean, optional, default=0</code>: Multiply triangular matrix from the right to non-triangular one.</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor to be applied to the result.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1537' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.linalg_trsm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.linalg_trsm-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.linalg_trsm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>linalg_trsm(A, B, transpose, rightside, alpha)
</code></pre>

<p>linalg_trsm is an alias of _linalg_trsm.</p>
<p>Solves matrix equation involving a lower triangular matrix. Input are tensors <em>A</em>, <em>B</em>, each of dimension <em>n &gt;= 2</em> and having the same shape on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, <em>A</em> must be lower triangular. The operator performs the BLAS3 function <em>trsm</em>, solving for <em>out</em> in:</p>
<p><em>op</em>\ (<em>A</em>) * <em>out</em> = <em>alpha</em> * <em>B</em></p>
<p>if <em>rightside=False</em>, or</p>
<p><em>out</em> * <em>op</em>\ (<em>A</em>) = <em>alpha</em> * <em>B</em></p>
<p>if <em>rightside=True</em>. Here, <em>alpha</em> is a scalar parameter, and <em>op()</em> is either the identity or the matrix transposition (depending on <em>transpose</em>).</p>
<p>If <em>n&gt;2</em>, <em>trsm</em> is performed separately on the trailing two dimensions for all inputs (batch mode).</p>
<p>.. note:: The operator supports float32 and float64 data types only.</p>
<p>Examples::</p>
<p>// Single matrix solve    A = [[1.0, 0], [1.0, 1.0]]    B = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]    trsm(A, B, alpha=0.5) = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]</p>
<p>// Batch matrix solve    A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]    B = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],         [[4.0, 4.0, 4.0], [8.0, 8.0, 8.0]]]    trsm(A, B, alpha=0.5) = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]],                             [[2.0, 2.0, 2.0], [2.0, 2.0, 2.0]]]</p>
<p>Defined in src/operator/tensor/la_op.cc:L356</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A::NDArray-or-SymbolicNode</code>: Tensor of lower triangular matrices</li>
<li><code>B::NDArray-or-SymbolicNode</code>: Tensor of matrices</li>
<li><code>transpose::boolean, optional, default=0</code>: Use transposed of the triangular matrix</li>
<li><code>rightside::boolean, optional, default=0</code>: Multiply triangular matrix from the right to non-triangular one.</li>
<li><code>alpha::double, optional, default=1</code>: Scalar factor to be applied to the result.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1537' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.load-Tuple{AbstractString,Type{#s145} where #s145<:MXNet.mx.NDArray}' href='#MXNet.mx.load-Tuple{AbstractString,Type{#s145} where #s145<:MXNet.mx.NDArray}'>#</a>
<strong><code>MXNet.mx.load</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>load(filename, ::Type{NDArray})
</code></pre>

<p>Load NDArrays from binary file.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>filename::String</code>: the path of the file to load. It could be S3 or HDFS address.</li>
</ul>
<p>Returns either <code>Dict{Symbol, NDArray}</code> or <code>Vector{NDArray}</code>.</p>
<p><code>filename</code> can point to <code>s3</code> or <code>hdfs</code> resources if the <code>libmxnet</code> is built with the corresponding components enabled. Examples:</p>
<ul>
<li><code>s3://my-bucket/path/my-s3-ndarray</code></li>
<li><code>hdfs://my-bucket/path/my-hdfs-ndarray</code></li>
<li><code>/path-to/my-local-ndarray</code></li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L985-L1000' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.make_loss-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.make_loss-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.make_loss</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>make_loss(data)
</code></pre>

<p>Make your own loss function in network construction.</p>
<p>This operator accepts a customized loss function symbol as a terminal loss and the symbol should be an operator with no backward dependency. The output of this function is the gradient of loss with respect to the input data.</p>
<p>For example, if you are a making a cross entropy loss function. Assume $out$ is the predicted output and $label$ is the true label, then the cross entropy can be defined as::</p>
<p>cross_entropy = label * log(out) + (1 - label) * log(1 - out)   loss = make_loss(cross_entropy)</p>
<p>We will need to use $make_loss$ when we are creating our own loss function or we want to combine multiple loss functions. Also we may want to stop some variables' gradients from backpropagation. See more detail in $BlockGrad$ or $stop_gradient$.</p>
<p>The storage type of $make_loss$ output depends upon the input storage type:</p>
<ul>
<li>make_loss(default) = default</li>
<li>make_loss(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L200</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1514' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.mp_sgd_mom_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.mp_sgd_mom_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.mp_sgd_mom_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>mp_sgd_mom_update(weight, grad, mom, weight32, lr, momentum, wd, rescale_grad, clip_gradient)
</code></pre>

<p>Updater function for multi-precision sgd optimizer</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>mom::NDArray-or-SymbolicNode</code>: Momentum</li>
<li><code>weight32::NDArray-or-SymbolicNode</code>: Weight32</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>momentum::float, optional, default=0</code>: The decay rate of momentum estimates at each epoch.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1507' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.mp_sgd_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.mp_sgd_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.mp_sgd_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>mp_sgd_update(weight, grad, weight32, lr, wd, rescale_grad, clip_gradient)
</code></pre>

<p>Updater function for multi-precision sgd optimizer</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: gradient</li>
<li><code>weight32::NDArray-or-SymbolicNode</code>: Weight32</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1503' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.mul_to!-Tuple{MXNet.mx.NDArray,Union{MXNet.mx.NDArray, Real}}' href='#MXNet.mx.mul_to!-Tuple{MXNet.mx.NDArray,Union{MXNet.mx.NDArray, Real}}'>#</a>
<strong><code>MXNet.mx.mul_to!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>mul_to!(dst::NDArray, arg::NDArrayOrReal)
</code></pre>

<p>Elementwise multiplication into <code>dst</code> of either a scalar or an <code>NDArray</code> of the same shape. Inplace updating.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L656-L661' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.nanprod-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.nanprod-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.nanprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nanprod(data, axis, keepdims, exclude)
</code></pre>

<p>Computes the product of array elements over given axes treating Not a Numbers ($NaN$) as one.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L146</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape(tuple), optional, default=[]</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0`: Whether to perform reduction on axis that are NOT in axis instead.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1514' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.nansum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.nansum-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.nansum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nansum(data, axis, keepdims, exclude)
</code></pre>

<p>Computes the sum of array elements over given axes treating Not a Numbers ($NaN$) as zero.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L131</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape(tuple), optional, default=[]</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0`: Whether to perform reduction on axis that are NOT in axis instead.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1514' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.negative-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.negative-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.negative</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>negative(data)
</code></pre>

<p>Numerical negative of the argument, element-wise.</p>
<p>The storage type of $negative$ output depends upon the input storage type:</p>
<ul>
<li>negative(default) = default</li>
<li>negative(row_sparse) = row_sparse</li>
<li>negative(csr) = csr</li>
</ul>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1499' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.normal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.normal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.normal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>normal(loc, scale, shape, ctx, dtype)
</code></pre>

<p>normal is an alias of _random_normal.</p>
<p>Draw random samples from a normal (Gaussian) distribution.</p>
<p>.. note:: The existing alias $normal$ is deprecated.</p>
<p>Samples are distributed according to a normal distribution parametrized by <em>loc</em> (mean) and <em>scale</em> (standard deviation).</p>
<p>Example::</p>
<p>normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],                                           [-1.23474145,  1.55807114]]</p>
<p>Defined in src/operator/random/sample_op.cc:L85</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>loc::float, optional, default=0</code>: Mean of the distribution.</li>
<li><code>scale::float, optional, default=1</code>: Standard deviation of the distribution.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="../n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1513' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.one_hot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.one_hot-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.one_hot</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>one_hot(indices, depth, on_value, off_value, dtype)
</code></pre>

<p>Returns a one-hot array.</p>
<p>The locations represented by <code>indices</code> take value <code>on_value</code>, while all other locations take value <code>off_value</code>.</p>
<p><code>one_hot</code> operation with <code>indices</code> of shape $(i0, i1)$ and <code>depth</code>  of $d$ would result in an output array of shape $(i0, i1, d)$ with::</p>
<p>output[i,j,:] = off_value   output[i,j,indices[i,j]] = on_value</p>
<p>Examples::</p>
<p>one_hot([1,0,2,0], 3) = [[ 0.  1.  0.]                            [ 1.  0.  0.]                            [ 0.  0.  1.]                            [ 1.  0.  0.]]</p>
<p>one_hot([1,0,2,0], 3, on_value=8, off_value=1,           dtype='int32') = [[1 8 1]                             [8 1 1]                             [1 1 8]                             [8 1 1]]</p>
<p>one_hot([[1,0],[1,0],[2,0]], 3) = [[[ 0.  1.  0.]                                       [ 1.  0.  0.]]</p>
<pre><code>                                 [[ 0.  1.  0.]
                                  [ 1.  0.  0.]]

                                 [[ 0.  0.  1.]
                                  [ 1.  0.  0.]]]
</code></pre>

<p>Defined in src/operator/tensor/indexing_op.cc:L428</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>indices::NDArray-or-SymbolicNode</code>: array of locations where to set on_value</li>
<li><code>depth::int, required</code>: Depth of the one hot dimension.</li>
<li><code>on_value::double, optional, default=1</code>: The value assigned to the locations represented by indices.</li>
<li><code>off_value::double, optional, default=0</code>: The value assigned to the locations not represented by indices.</li>
<li><code>dtype::{'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='float32'</code>: DType of the output</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1533' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ones-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64,N}},MXNet.mx.Context}, Tuple{Tuple{Vararg{Int64,N}}}} where N' href='#MXNet.mx.ones-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64,N}},MXNet.mx.Context}, Tuple{Tuple{Vararg{Int64,N}}}} where N'>#</a>
<strong><code>MXNet.mx.ones</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ones(dims::Tuple[, ctx::Context = cpu()])
ones(dim1, dim2, ...)
</code></pre>

<p>Create an <code>NDArray</code> with specific shape and initialize with 1.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L211-L216' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ones-Union{Tuple{N}, Tuple{T}, Tuple{Type{T},Tuple{Vararg{Int64,N}},MXNet.mx.Context}, Tuple{Type{T},Tuple{Vararg{Int64,N}}}} where T<:Union{Float16, Float32, Float64, Int32, Int64, Int8, UInt8} where N' href='#MXNet.mx.ones-Union{Tuple{N}, Tuple{T}, Tuple{Type{T},Tuple{Vararg{Int64,N}},MXNet.mx.Context}, Tuple{Type{T},Tuple{Vararg{Int64,N}}}} where T<:Union{Float16, Float32, Float64, Int32, Int64, Int8, UInt8} where N'>#</a>
<strong><code>MXNet.mx.ones</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ones(DType, dims::Tuple[, ctx::Context = cpu()])
ones(DType, dim1, dim2...)
</code></pre>

<p>Create an <code>NDArray</code> with specific shape &amp; type, and initialize with 1.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L197-L202' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ones_like-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.ones_like-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.ones_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ones_like(data)
</code></pre>

<p>Return an array of ones with the same shape and type as the input array.</p>
<p>Examples::</p>
<p>x = [[ 0.,  0.,  0.],        [ 0.,  0.,  0.]]</p>
<p>ones_like(x) = [[ 1.,  1.,  1.],                   [ 1.,  1.,  1.]]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1502' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.pad-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.pad-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.pad</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>pad(data, mode, pad_width, constant_value)
</code></pre>

<p>pad is an alias of Pad.</p>
<p>Pads an input array with a constant or edge values of the array.</p>
<p>.. note:: <code>Pad</code> is deprecated. Use <code>pad</code> instead.</p>
<p>.. note:: Current implementation only supports 4D and 5D input arrays with padding applied    only on axes 1, 2 and 3. Expects axes 4 and 5 in <code>pad_width</code> to be zero.</p>
<p>This operation pads an input array with either a <code>constant_value</code> or edge values along each axis of the input array. The amount of padding is specified by <code>pad_width</code>.</p>
<p><code>pad_width</code> is a tuple of integer padding widths for each axis of the format $(before_1, after_1, ... , before_N, after_N)$. The <code>pad_width</code> should be of length $2*N$ where $N$ is the number of dimensions of the array.</p>
<p>For dimension $N$ of the input array, $before_N$ and $after_N$ indicates how many values to add before and after the elements of the array along dimension $N$. The widths of the higher two dimensions $before_1$, $after_1$, $before_2$, $after_2$ must be 0.</p>
<p>Example::</p>
<p>x = [[[[  1.   2.   3.]           [  4.   5.   6.]]</p>
<pre><code>     [[  7.   8.   9.]
      [ 10.  11.  12.]]]


    [[[ 11.  12.  13.]
      [ 14.  15.  16.]]

     [[ 17.  18.  19.]
      [ 20.  21.  22.]]]]
</code></pre>

<p>pad(x,mode="edge", pad_width=(0,0,0,0,1,1,1,1)) =</p>
<pre><code>     [[[[  1.   1.   2.   3.   3.]
        [  1.   1.   2.   3.   3.]
        [  4.   4.   5.   6.   6.]
        [  4.   4.   5.   6.   6.]]

       [[  7.   7.   8.   9.   9.]
        [  7.   7.   8.   9.   9.]
        [ 10.  10.  11.  12.  12.]
        [ 10.  10.  11.  12.  12.]]]


      [[[ 11.  11.  12.  13.  13.]
        [ 11.  11.  12.  13.  13.]
        [ 14.  14.  15.  16.  16.]
        [ 14.  14.  15.  16.  16.]]

       [[ 17.  17.  18.  19.  19.]
        [ 17.  17.  18.  19.  19.]
        [ 20.  20.  21.  22.  22.]
        [ 20.  20.  21.  22.  22.]]]]
</code></pre>

<p>pad(x, mode="constant", constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =</p>
<pre><code>     [[[[  0.   0.   0.   0.   0.]
        [  0.   1.   2.   3.   0.]
        [  0.   4.   5.   6.   0.]
        [  0.   0.   0.   0.   0.]]

       [[  0.   0.   0.   0.   0.]
        [  0.   7.   8.   9.   0.]
        [  0.  10.  11.  12.   0.]
        [  0.   0.   0.   0.   0.]]]


      [[[  0.   0.   0.   0.   0.]
        [  0.  11.  12.  13.   0.]
        [  0.  14.  15.  16.   0.]
        [  0.   0.   0.   0.   0.]]

       [[  0.   0.   0.   0.   0.]
        [  0.  17.  18.  19.   0.]
        [  0.  20.  21.  22.   0.]
        [  0.   0.   0.   0.   0.]]]]
</code></pre>

<p>Defined in src/operator/pad.cc:L766</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: An n-dimensional input array.</li>
<li><code>mode::{'constant', 'edge', 'reflect'}, required</code>: Padding type to use. "constant" pads with <code>constant_value</code> "edge" pads using the edge values of the input array "reflect" pads by reflecting values with respect to the edges.</li>
<li><code>pad_width::Shape(tuple), required</code>: Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format $(before_1, after_1, ... , before_N, after_N)$. It should be of length $2*N$ where $N$ is the number of dimensions of the array.This is equivalent to pad_width in numpy.pad, but flattened.</li>
<li><code>constant_value::double, optional, default=0</code>: The value used for padding when <code>mode</code> is "constant".</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1582' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.pick-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.pick-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.pick</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>pick(data, index, axis, keepdims)
</code></pre>

<p>Picks elements from an input array according to the input indices along the given axis.</p>
<p>Given an input array of shape $(d0, d1)$ and indices of shape $(i0,)$, the result will be an output array of shape $(i0,)$ with::</p>
<p>output[i] = input[i, indices[i]]</p>
<p>By default, if any index mentioned is too large, it is replaced by the index that addresses the last element along an axis (the <code>clip</code> mode).</p>
<p>This function supports n-dimensional input and (n-1)-dimensional indices arrays.</p>
<p>Examples::</p>
<p>x = [[ 1.,  2.],        [ 3.,  4.],        [ 5.,  6.]]</p>
<p>// picks elements with specified indices along axis 0   pick(x, y=[0,1], 0) = [ 1.,  4.]</p>
<p>// picks elements with specified indices along axis 1   pick(x, y=[0,1,0], 1) = [ 1.,  4.,  5.]</p>
<p>y = [[ 1.],        [ 0.],        [ 2.]]</p>
<p>// picks elements with specified indices along axis 1 and dims are maintained   pick(x,y, 1, keepdims=True) = [[ 2.],                                  [ 3.],                                  [ 6.]]</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L145</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>index::NDArray-or-SymbolicNode</code>: The index array</li>
<li><code>axis::int or None, optional, default='None'</code>: The axis along which to perform the reduction. Negative values means indexing from right to left. $Requires axis to be set as int, because global reduction is not supported yet.$</li>
<li><code>keepdims::boolean, optional, default=0</code>: If this is set to <code>True</code>, the reduced axis is left in the result as dimension with size one.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1532' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.radians-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.radians-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.radians</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>radians(data)
</code></pre>

<p>Converts each element of the input array from degrees to radians.</p>
<p>.. math::    radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]</p>
<p>The storage type of $radians$ output depends upon the input storage type:</p>
<ul>
<li>radians(default) = default</li>
<li>radians(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L182</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1503' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_exponential-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.random_exponential-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.random_exponential</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>random_exponential(lam, shape, ctx, dtype)
</code></pre>

<p>random_exponential is an alias of _random_exponential.</p>
<p>Draw random samples from an exponential distribution.</p>
<p>Samples are distributed according to an exponential distribution parametrized by <em>lambda</em> (rate).</p>
<p>Example::</p>
<p>exponential(lam=4, shape=(2,2)) = [[ 0.0097189 ,  0.08999364],                                       [ 0.04146638,  0.31715935]]</p>
<p>Defined in src/operator/random/sample_op.cc:L115</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lam::float, optional, default=1</code>: Lambda parameter (rate) of the exponential distribution.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="../n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1509' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_gamma-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.random_gamma-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.random_gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>random_gamma(alpha, beta, shape, ctx, dtype)
</code></pre>

<p>random_gamma is an alias of _random_gamma.</p>
<p>Draw random samples from a gamma distribution.</p>
<p>Samples are distributed according to a gamma distribution parametrized by <em>alpha</em> (shape) and <em>beta</em> (scale).</p>
<p>Example::</p>
<p>gamma(alpha=9, beta=0.5, shape=(2,2)) = [[ 7.10486984,  3.37695289],                                             [ 3.91697288,  3.65933681]]</p>
<p>Defined in src/operator/random/sample_op.cc:L100</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>alpha::float, optional, default=1</code>: Alpha parameter (shape) of the gamma distribution.</li>
<li><code>beta::float, optional, default=1</code>: Beta parameter (scale) of the gamma distribution.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="../n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1511' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_generalized_negative_binomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.random_generalized_negative_binomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.random_generalized_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>random_generalized_negative_binomial(mu, alpha, shape, ctx, dtype)
</code></pre>

<p>random_generalized_negative_binomial is an alias of _random_generalized_negative_binomial.</p>
<p>Draw random samples from a generalized negative binomial distribution.</p>
<p>Samples are distributed according to a generalized negative binomial distribution parametrized by <em>mu</em> (mean) and <em>alpha</em> (dispersion). <em>alpha</em> is defined as <em>1/k</em> where <em>k</em> is the failure limit of the number of unsuccessful experiments (generalized to real numbers). Samples will always be returned as a floating point data type.</p>
<p>Example::</p>
<p>generalized_negative_binomial(mu=2.0, alpha=0.3, shape=(2,2)) = [[ 2.,  1.],                                                                     [ 6.,  4.]]</p>
<p>Defined in src/operator/random/sample_op.cc:L168</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>mu::float, optional, default=1</code>: Mean of the negative binomial distribution.</li>
<li><code>alpha::float, optional, default=1</code>: Alpha (dispersion) parameter of the negative binomial distribution.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="../n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1514' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_negative_binomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.random_negative_binomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.random_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>random_negative_binomial(k, p, shape, ctx, dtype)
</code></pre>

<p>random_negative_binomial is an alias of _random_negative_binomial.</p>
<p>Draw random samples from a negative binomial distribution.</p>
<p>Samples are distributed according to a negative binomial distribution parametrized by <em>k</em> (limit of unsuccessful experiments) and <em>p</em> (failure probability in each experiment). Samples will always be returned as a floating point data type.</p>
<p>Example::</p>
<p>negative_binomial(k=3, p=0.4, shape=(2,2)) = [[ 4.,  7.],                                                  [ 2.,  5.]]</p>
<p>Defined in src/operator/random/sample_op.cc:L149</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>k::int, optional, default='1'</code>: Limit of unsuccessful experiments.</li>
<li><code>p::float, optional, default=1</code>: Failure probability in each experiment.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="../n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1513' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_normal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.random_normal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.random_normal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>random_normal(loc, scale, shape, ctx, dtype)
</code></pre>

<p>random_normal is an alias of _random_normal.</p>
<p>Draw random samples from a normal (Gaussian) distribution.</p>
<p>.. note:: The existing alias $normal$ is deprecated.</p>
<p>Samples are distributed according to a normal distribution parametrized by <em>loc</em> (mean) and <em>scale</em> (standard deviation).</p>
<p>Example::</p>
<p>normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],                                           [-1.23474145,  1.55807114]]</p>
<p>Defined in src/operator/random/sample_op.cc:L85</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>loc::float, optional, default=0</code>: Mean of the distribution.</li>
<li><code>scale::float, optional, default=1</code>: Standard deviation of the distribution.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="../n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1513' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_poisson-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.random_poisson-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.random_poisson</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>random_poisson(lam, shape, ctx, dtype)
</code></pre>

<p>random_poisson is an alias of _random_poisson.</p>
<p>Draw random samples from a Poisson distribution.</p>
<p>Samples are distributed according to a Poisson distribution parametrized by <em>lambda</em> (rate). Samples will always be returned as a floating point data type.</p>
<p>Example::</p>
<p>poisson(lam=4, shape=(2,2)) = [[ 5.,  2.],                                   [ 4.,  6.]]</p>
<p>Defined in src/operator/random/sample_op.cc:L132</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lam::float, optional, default=1</code>: Lambda parameter (rate) of the Poisson distribution.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="../n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1510' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.random_uniform-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.random_uniform-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.random_uniform</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>random_uniform(low, high, shape, ctx, dtype)
</code></pre>

<p>random_uniform is an alias of _random_uniform.</p>
<p>Draw random samples from a uniform distribution.</p>
<p>.. note:: The existing alias $uniform$ is deprecated.</p>
<p>Samples are uniformly distributed over the half-open interval <em>[low, high)</em> (includes <em>low</em>, but excludes <em>high</em>).</p>
<p>Example::</p>
<p>uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],                                           [ 0.54488319,  0.84725171]]</p>
<p>Defined in src/operator/random/sample_op.cc:L66</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>low::float, optional, default=0</code>: Lower bound of the distribution.</li>
<li><code>high::float, optional, default=1</code>: Upper bound of the distribution.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="../n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1515' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.rcbrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.rcbrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.rcbrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>rcbrt(data)
</code></pre>

<p>Returns element-wise inverse cube-root value of the input.</p>
<p>.. math::    rcbrt(x) = 1/\sqrt[3]{x}</p>
<p>Example::</p>
<p>rcbrt([1,8,-125]) = [1.0, 0.5, -0.2]</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L619</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1502' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.rdiv_from!-Tuple{Real,MXNet.mx.NDArray}' href='#MXNet.mx.rdiv_from!-Tuple{Real,MXNet.mx.NDArray}'>#</a>
<strong><code>MXNet.mx.rdiv_from!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>rdiv_from!(x:: Real, y::NDArray)
</code></pre>

<p>Elementwise divide a scalar by an <code>NDArray</code>. Inplace updating.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L715-L719' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.reciprocal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.reciprocal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.reciprocal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>reciprocal(data)
</code></pre>

<p>Returns the reciprocal of the argument, element-wise.</p>
<p>Calculates 1/x.</p>
<p>Example::</p>
<pre><code>reciprocal([-2, 1, 3, 1.6, 0.2]) = [-0.5, 1.0, 0.33333334, 0.625, 5.0]
</code></pre>

<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L364</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1501' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.reshape_like-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.reshape_like-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.reshape_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>reshape_like(lhs, rhs)
</code></pre>

<p>Reshape lhs to have the same shape as rhs.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lhs::NDArray-or-SymbolicNode</code>: First input.</li>
<li><code>rhs::NDArray-or-SymbolicNode</code>: Second input.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1493' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.rint-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.rint-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.rint</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>rint(data)
</code></pre>

<p>Returns element-wise rounded value to the nearest integer of the input.</p>
<p>.. note::</p>
<ul>
<li>For input $n.5$ $rint$ returns $n$ while $round$ returns $n+1$.</li>
<li>For input $-n.5$ both $rint$ and $round$ returns $-n-1$.</li>
</ul>
<p>Example::</p>
<p>rint([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  1., -2.,  2.,  2.]</p>
<p>The storage type of $rint$ output depends upon the input storage type:</p>
<ul>
<li>rint(default) = default</li>
<li>rint(row_sparse) = row_sparse</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L445</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.rmsprop_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.rmsprop_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.rmsprop_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>rmsprop_update(weight, grad, n, lr, gamma1, epsilon, wd, rescale_grad, clip_gradient, clip_weights)
</code></pre>

<p>Update function for <code>RMSProp</code> optimizer.</p>
<p><code>RMSprop</code> is a variant of stochastic gradient descent where the gradients are divided by a cache which grows with the sum of squares of recent gradients?</p>
<p><code>RMSProp</code> is similar to <code>AdaGrad</code>, a popular variant of <code>SGD</code> which adaptively tunes the learning rate of each parameter. <code>AdaGrad</code> lowers the learning rate for each parameter monotonically over the course of training. While this is analytically motivated for convex optimizations, it may not be ideal for non-convex problems. <code>RMSProp</code> deals with this heuristically by allowing the learning rates to rebound as the denominator decays over time.</p>
<p>Define the Root Mean Square (RMS) error criterion of the gradient as :math:<code>RMS[g]_t = \sqrt{E[g^2]_t + \epsilon}</code>, where :math:<code>g</code> represents gradient and :math:<code>E[g^2]_t</code> is the decaying average over past squared gradient.</p>
<p>The :math:<code>E[g^2]_t</code> is given by:</p>
<p>.. math::   E[g^2]<em t-1="t-1">t = \gamma * E[g^2]</em> + (1-\gamma) * g_t^2</p>
<p>The update step is</p>
<p>.. math::   \theta_{t+1} = \theta_t - \frac{\eta}{RMS[g]_t} g_t</p>
<p>The RMSProp code follows the version in http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf Tieleman &amp; Hinton, 2012.</p>
<p>Hinton suggests the momentum term :math:<code>\gamma</code> to be 0.9 and the learning rate :math:<code>\eta</code> to be 0.001.</p>
<p>Defined in src/operator/optimizer_op.cc:L229</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>n::NDArray-or-SymbolicNode</code>: n</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>gamma1::float, optional, default=0.95</code>: The decay rate of momentum estimates.</li>
<li><code>epsilon::float, optional, default=1e-08</code>: A small constant for numerical stability.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><code>clip_weights::float, optional, default=-1</code>: Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1544' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.rmspropalex_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.rmspropalex_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.rmspropalex_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>rmspropalex_update(weight, grad, n, g, delta, lr, gamma1, gamma2, epsilon, wd, rescale_grad, clip_gradient, clip_weights)
</code></pre>

<p>Update function for RMSPropAlex optimizer.</p>
<p><code>RMSPropAlex</code> is non-centered version of <code>RMSProp</code>.</p>
<p>Define :math:<code>E[g^2]_t</code> is the decaying average over past squared gradient and :math:<code>E[g]_t</code> is the decaying average over past gradient.</p>
<p>.. math::   E[g^2]<em t-1="t-1">t = \gamma_1 * E[g^2]</em> + (1 - \gamma_1) * g_t^2\
  E[g]<em t-1="t-1">t = \gamma_1 * E[g]</em> + (1 - \gamma_1) * g_t\
  \Delta_t = \gamma_2 * \Delta_{t-1} - \frac{\eta}{\sqrt{E[g^2]_t - E[g]_t^2 + \epsilon}} g_t\
 The update step is</p>
<p>.. math::   \theta_{t+1} = \theta_t + \Delta_t</p>
<p>The RMSPropAlex code follows the version in http://arxiv.org/pdf/1308.0850v5.pdf Eq(38) - Eq(45) by Alex Graves, 2013.</p>
<p>Graves suggests the momentum term :math:<code>\gamma_1</code> to be 0.95, :math:<code>\gamma_2</code> to be 0.9 and the learning rate :math:<code>\eta</code> to be 0.0001.</p>
<p>Defined in src/operator/optimizer_op.cc:L268</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>n::NDArray-or-SymbolicNode</code>: n</li>
<li><code>g::NDArray-or-SymbolicNode</code>: g</li>
<li><code>delta::NDArray-or-SymbolicNode</code>: delta</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>gamma1::float, optional, default=0.95</code>: Decay rate.</li>
<li><code>gamma2::float, optional, default=0.9</code>: Decay rate.</li>
<li><code>epsilon::float, optional, default=1e-08</code>: A small constant for numerical stability.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><code>clip_weights::float, optional, default=-1</code>: Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1539' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.rsqrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.rsqrt-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.rsqrt</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>rsqrt(data)
</code></pre>

<p>Returns element-wise inverse square-root value of the input.</p>
<p>.. math::    rsqrt(x) = 1/\sqrt{x}</p>
<p>Example::</p>
<p>rsqrt([4,9,16]) = [0.5, 0.33333334, 0.25]</p>
<p>The storage type of $rsqrt$ output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L585</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1504' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sample_exponential-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.sample_exponential-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.sample_exponential</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sample_exponential(lam, shape, dtype)
</code></pre>

<p>sample_exponential is an alias of _sample_exponential.</p>
<p>Concurrent sampling from multiple exponential distributions with parameters lambda (rate).</p>
<p>The parameters of the distributions are provided as an input array. Let <em>[s]</em> be the shape of the input array, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input array, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input value at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input array.</p>
<p>Examples::</p>
<p>lam = [ 1.0, 8.5 ]</p>
<p>// Draw a single sample for each distribution    sample_exponential(lam) = [ 0.51837951,  0.09994757]</p>
<p>// Draw a vector containing two samples for each distribution    sample_exponential(lam, shape=(2)) = [[ 0.51837951,  0.19866663],                                          [ 0.09994757,  0.50447971]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L284</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lam::NDArray-or-SymbolicNode</code>: Lambda (rate) parameters of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1523' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sample_gamma-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.sample_gamma-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.sample_gamma</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sample_gamma(alpha, shape, dtype, beta)
</code></pre>

<p>sample_gamma is an alias of _sample_gamma.</p>
<p>Concurrent sampling from multiple gamma distributions with parameters <em>alpha</em> (shape) and <em>beta</em> (scale).</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Examples::</p>
<p>alpha = [ 0.0, 2.5 ]    beta = [ 1.0, 0.7 ]</p>
<p>// Draw a single sample for each distribution    sample_gamma(alpha, beta) = [ 0.        ,  2.25797319]</p>
<p>// Draw a vector containing two samples for each distribution    sample_gamma(alpha, beta, shape=(2)) = [[ 0.        ,  0.        ],                                            [ 2.25797319,  1.70734084]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L282</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>alpha::NDArray-or-SymbolicNode</code>: Alpha (shape) parameters of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>beta::NDArray-or-SymbolicNode</code>: Beta (scale) parameters of the distributions.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1526' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sample_generalized_negative_binomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.sample_generalized_negative_binomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.sample_generalized_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sample_generalized_negative_binomial(mu, shape, dtype, alpha)
</code></pre>

<p>sample_generalized_negative_binomial is an alias of _sample_generalized_negative_binomial.</p>
<p>Concurrent sampling from multiple generalized negative binomial distributions with parameters <em>mu</em> (mean) and <em>alpha</em> (dispersion).</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Samples will always be returned as a floating point data type.</p>
<p>Examples::</p>
<p>mu = [ 2.0, 2.5 ]    alpha = [ 1.0, 0.1 ]</p>
<p>// Draw a single sample for each distribution    sample_generalized_negative_binomial(mu, alpha) = [ 0.,  3.]</p>
<p>// Draw a vector containing two samples for each distribution    sample_generalized_negative_binomial(mu, alpha, shape=(2)) = [[ 0.,  3.],                                                                  [ 3.,  1.]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L293</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>mu::NDArray-or-SymbolicNode</code>: Means of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>alpha::NDArray-or-SymbolicNode</code>: Alpha (dispersion) parameters of the distributions.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1528' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sample_multinomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.sample_multinomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.sample_multinomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sample_multinomial(data, shape, get_prob, dtype)
</code></pre>

<p>sample_multinomial is an alias of _sample_multinomial.</p>
<p>Concurrent sampling from multiple multinomial distributions.</p>
<p><em>data</em> is an <em>n</em> dimensional array whose last dimension has length <em>k</em>, where <em>k</em> is the number of possible outcomes of each multinomial distribution. This operator will draw <em>shape</em> samples from each distribution. If shape is empty one sample will be drawn from each distribution.</p>
<p>If <em>get_prob</em> is true, a second array containing log likelihood of the drawn samples will also be returned. This is usually used for reinforcement learning where you can provide reward as head gradient for this array to estimate gradient.</p>
<p>Note that the input distribution must be normalized, i.e. <em>data</em> must sum to 1 along its last axis.</p>
<p>Examples::</p>
<p>probs = [[0, 0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1, 0]]</p>
<p>// Draw a single sample for each distribution    sample_multinomial(probs) = [3, 0]</p>
<p>// Draw a vector containing two samples for each distribution    sample_multinomial(probs, shape=(2)) = [[4, 2],                                            [0, 0]]</p>
<p>// requests log likelihood    sample_multinomial(probs, get_prob=True) = [2, 1], [0.2, 0.3]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Distribution probabilities. Must sum to one on the last axis.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>get_prob::boolean, optional, default=0</code>: Whether to also return the log probability of sampled result. This is usually used for differentiating through stochastic variables, e.g. in reinforcement learning.</li>
<li><code>dtype::{'int32'},optional, default='int32'</code>: DType of the output in case this can't be inferred. Only support int32 for now.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1527' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sample_negative_binomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.sample_negative_binomial-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.sample_negative_binomial</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sample_negative_binomial(k, shape, dtype, p)
</code></pre>

<p>sample_negative_binomial is an alias of _sample_negative_binomial.</p>
<p>Concurrent sampling from multiple negative binomial distributions with parameters <em>k</em> (failure limit) and <em>p</em> (failure probability).</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Samples will always be returned as a floating point data type.</p>
<p>Examples::</p>
<p>k = [ 20, 49 ]    p = [ 0.4 , 0.77 ]</p>
<p>// Draw a single sample for each distribution    sample_negative_binomial(k, p) = [ 15.,  16.]</p>
<p>// Draw a vector containing two samples for each distribution    sample_negative_binomial(k, p, shape=(2)) = [[ 15.,  50.],                                                 [ 16.,  12.]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L289</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>k::NDArray-or-SymbolicNode</code>: Limits of unsuccessful experiments.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>p::NDArray-or-SymbolicNode</code>: Failure probabilities in each experiment.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1528' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sample_normal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.sample_normal-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.sample_normal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sample_normal(mu, shape, dtype, sigma)
</code></pre>

<p>sample_normal is an alias of _sample_normal.</p>
<p>Concurrent sampling from multiple normal distributions with parameters <em>mu</em> (mean) and <em>sigma</em> (standard deviation).</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Examples::</p>
<p>mu = [ 0.0, 2.5 ]    sigma = [ 1.0, 3.7 ]</p>
<p>// Draw a single sample for each distribution    sample_normal(mu, sigma) = [-0.56410581,  0.95934606]</p>
<p>// Draw a vector containing two samples for each distribution    sample_normal(mu, sigma, shape=(2)) = [[-0.56410581,  0.2928229 ],                                           [ 0.95934606,  4.48287058]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L279</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>mu::NDArray-or-SymbolicNode</code>: Means of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>sigma::NDArray-or-SymbolicNode</code>: Standard deviations of the distributions.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1526' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sample_poisson-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.sample_poisson-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.sample_poisson</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sample_poisson(lam, shape, dtype)
</code></pre>

<p>sample_poisson is an alias of _sample_poisson.</p>
<p>Concurrent sampling from multiple Poisson distributions with parameters lambda (rate).</p>
<p>The parameters of the distributions are provided as an input array. Let <em>[s]</em> be the shape of the input array, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input array, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input value at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input array.</p>
<p>Samples will always be returned as a floating point data type.</p>
<p>Examples::</p>
<p>lam = [ 1.0, 8.5 ]</p>
<p>// Draw a single sample for each distribution    sample_poisson(lam) = [  0.,  13.]</p>
<p>// Draw a vector containing two samples for each distribution    sample_poisson(lam, shape=(2)) = [[  0.,   4.],                                      [ 13.,   8.]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L286</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>lam::NDArray-or-SymbolicNode</code>: Lambda (rate) parameters of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1525' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sample_uniform-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.sample_uniform-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.sample_uniform</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sample_uniform(low, shape, dtype, high)
</code></pre>

<p>sample_uniform is an alias of _sample_uniform.</p>
<p>Concurrent sampling from multiple uniform distributions on the intervals given by <em>[low,high)</em>.</p>
<p>The parameters of the distributions are provided as input arrays. Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em> be the shape specified as the parameter of the operator, and <em>m</em> be the dimension of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em> will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution which is parameterized by the input values at index <em>i</em>. If the shape parameter of the operator is not set, then one sample will be drawn per distribution and the output array has the same shape as the input arrays.</p>
<p>Examples::</p>
<p>low = [ 0.0, 2.5 ]    high = [ 1.0, 3.7 ]</p>
<p>// Draw a single sample for each distribution    sample_uniform(low, high) = [ 0.40451524,  3.18687344]</p>
<p>// Draw a vector containing two samples for each distribution    sample_uniform(low, high, shape=(2)) = [[ 0.40451524,  0.18017688],                                            [ 3.18687344,  3.68352246]]</p>
<p>Defined in src/operator/random/multisample_op.cc:L277</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>low::NDArray-or-SymbolicNode</code>: Lower bounds of the distributions.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape to be sampled from each random distribution.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><code>high::NDArray-or-SymbolicNode</code>: Upper bounds of the distributions.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1526' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.save-Tuple{String,MXNet.mx.NDArray}' href='#MXNet.mx.save-Tuple{String,MXNet.mx.NDArray}'>#</a>
<strong><code>MXNet.mx.save</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>save(filename::AbstractString, data)
</code></pre>

<p>Save NDarrays to binary file. Filename could be S3 or HDFS address, if <code>libmxnet</code> is built with corresponding support (see <code>load</code>).</p>
<ul>
<li><code>filename::String</code>: path to the binary file to write to.</li>
<li><code>data</code>: data to save to file. Data can be a<code>NDArray</code>, a <code>Vector</code> of <code>NDArray</code>, or a <code>Dict{Symbol}</code> contains <code>NDArray</code>s.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1019-L1028' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.scatter_nd-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.scatter_nd-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.scatter_nd</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>scatter_nd(data, indices, shape)
</code></pre>

<p>Scatters data into a new tensor according to indices. <code>gather_nd</code> and <code>scatter_nd</code> are inverse functions to each other.</p>
<p>Given <code>data</code> with shape <code>(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})</code> and indices with shape <code>(M, Y_0, ..., Y_{K-1})</code>, the output will have shape <code>(X_0, X_1, ..., X_{N-1})</code>, where <code>M &lt;= N</code>. If <code>M == N</code>, data shape should simply be <code>(Y_0, ..., Y_{K-1})</code>.</p>
<p>The elements in output is defined as follows::</p>
<p>output[indices[0, y_0, ..., y_{K-1}],          ...,          indices[M-1, y_0, ..., y_{K-1}],          x_M, ..., x_{N-1}] = data[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}]</p>
<p>all other entries in output are 0.</p>
<p>Examples::</p>
<p>data = [2, 3, 0]   indices = [[1, 1, 0], [0, 1, 0]]   shape = (2, 2)   scatter_nd(data, indices, shape) = [[0, 0], [2, 3]]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: data</li>
<li><code>indices::NDArray-or-SymbolicNode</code>: indices</li>
<li><code>shape::Shape(tuple), required</code>: Shape of output.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1518' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sgd_mom_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.sgd_mom_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.sgd_mom_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sgd_mom_update(weight, grad, mom, lr, momentum, wd, rescale_grad, clip_gradient)
</code></pre>

<p>Momentum update function for Stochastic Gradient Descent (SDG) optimizer.</p>
<p>Momentum update has better convergence rates on neural networks. Mathematically it looks like below:</p>
<p>.. math::</p>
<p>v_1 = \alpha * \nabla J(W_0)\
  v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\
  W_t = W_{t-1} + v_t</p>
<p>It updates the weights using::</p>
<p>v = momentum * v - learning_rate * gradient   weight += v</p>
<p>Where the parameter $momentum$ is the decay rate of momentum estimates at each epoch.</p>
<p>If weight and momentum are both of $row_sparse$ storage type, only the row slices whose indices appear in grad.indices are updated (for both weight and momentum)::</p>
<p>for row in gradient.indices:       v[row] = momentum[row] * v[row] - learning_rate * gradient[row]       weight[row] += v[row]</p>
<p>Defined in src/operator/optimizer_op.cc:L93</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>mom::NDArray-or-SymbolicNode</code>: Momentum</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>momentum::float, optional, default=0</code>: The decay rate of momentum estimates at each epoch.</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1532' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sgd_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.sgd_update-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.sgd_update</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sgd_update(weight, grad, lr, wd, rescale_grad, clip_gradient)
</code></pre>

<p>Update function for Stochastic Gradient Descent (SDG) optimizer.</p>
<p>It updates the weights using::</p>
<p>weight = weight - learning_rate * gradient</p>
<p>If weight is of $row_sparse$ storage type, only the row slices whose indices appear in grad.indices are updated::</p>
<p>for row in gradient.indices:      weight[row] = weight[row] - learning_rate * gradient[row]</p>
<p>Defined in src/operator/optimizer_op.cc:L53</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>weight::NDArray-or-SymbolicNode</code>: Weight</li>
<li><code>grad::NDArray-or-SymbolicNode</code>: Gradient</li>
<li><code>lr::float, required</code>: Learning rate</li>
<li><code>wd::float, optional, default=0</code>: Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><code>rescale_grad::float, optional, default=1</code>: Rescale gradient to grad = rescale_grad*grad.</li>
<li><code>clip_gradient::float, optional, default=-1</code>: Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1515' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.slice-Tuple{MXNet.mx.NDArray,Colon}' href='#MXNet.mx.slice-Tuple{MXNet.mx.NDArray,Colon}'>#</a>
<strong><code>MXNet.mx.slice</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>slice(arr :: NDArray, start:stop)
</code></pre>

<p>Create a view into a sub-slice of an <code>NDArray</code>. Note only slicing at the slowest changing dimension is supported. In Julia's column-major perspective, this is the last dimension. For example, given an <code>NDArray</code> of shape (2,3,4), <code>slice(array, 2:3)</code> will create a <code>NDArray</code> of shape (2,3,2), sharing the data with the original array. This operation is used in data parallelization to split mini-batch into sub-batches for different devices.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L300-L308' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.slice-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.slice-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.slice</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>slice(data, begin, end, step)
</code></pre>

<p>Slices a region of the array.</p>
<p>.. note:: $crop$ is deprecated. Use $slice$ instead.</p>
<p>This function returns a sliced array between the indices given by <code>begin</code> and <code>end</code> with the corresponding <code>step</code>.</p>
<p>For an input array of $shape=(d_0, d_1, ..., d_n-1)$, slice operation with $begin=(b_0, b_1...b_m-1)$, $end=(e_0, e_1, ..., e_m-1)$, and $step=(s_0, s_1, ..., s_m-1)$, where m &lt;= n, results in an array with the shape $(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)$.</p>
<p>The resulting array's <em>k</em>-th dimension contains elements from the <em>k</em>-th dimension of the input array starting from index $b_k$ (inclusive) with step $s_k$ until reaching $e_k$ (exclusive).</p>
<p>If the <em>k</em>-th elements are <code>None</code> in the sequence of <code>begin</code>, <code>end</code>, and <code>step</code>, the following rule will be used to set default values. If <code>s_k</code> is <code>None</code>, set <code>s_k=1</code>. If <code>s_k &gt; 0</code>, set <code>b_k=0</code>, <code>e_k=d_k</code>; else, set <code>b_k=d_k-1</code>, <code>e_k=-1</code>.</p>
<p>The storage type of $slice$ output depends on storage types of inputs</p>
<ul>
<li>slice(csr) = csr</li>
<li>otherwise, $slice$ generates output with default storage</li>
</ul>
<p>.. note:: When input data storage type is csr, it only supports step=(), or step=(None,), or step=(1,) to generate a csr output. For other step parameter values, it falls back to slicing a dense tensor.</p>
<p>Example::</p>
<p>x = [[  1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.],        [  9.,  10.,  11.,  12.]]</p>
<p>slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],                                      [ 6.,  7.,  8.]]   slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],                                                             [5.,  7.],                                                             [1.,  3.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L355</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>begin::Shape(tuple), required</code>: starting indices for the slice operation, supports negative indices.</li>
<li><code>end::Shape(tuple), required</code>: ending indices for the slice operation, supports negative indices.</li>
<li><code>step::Shape(tuple), optional, default=[]</code>: step for the slice operation, supports negative values.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1543' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.slice_axis-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.slice_axis-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.slice_axis</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>slice_axis(data, axis, begin, end)
</code></pre>

<p>Slices along a given axis.</p>
<p>Returns an array slice along a given <code>axis</code> starting from the <code>begin</code> index to the <code>end</code> index.</p>
<p>Examples::</p>
<p>x = [[  1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.],        [  9.,  10.,  11.,  12.]]</p>
<p>slice_axis(x, axis=0, begin=1, end=3) = [[  5.,   6.,   7.,   8.],                                            [  9.,  10.,  11.,  12.]]</p>
<p>slice_axis(x, axis=1, begin=0, end=2) = [[  1.,   2.],                                            [  5.,   6.],                                            [  9.,  10.]]</p>
<p>slice_axis(x, axis=1, begin=-3, end=-1) = [[  2.,   3.],                                              [  6.,   7.],                                              [ 10.,  11.]]</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L442</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Source input</li>
<li><code>axis::int, required</code>: Axis along which to be sliced, supports negative indexes.</li>
<li><code>begin::int, required</code>: The beginning index along the axis to be sliced,  supports negative indexes.</li>
<li><code>end::int or None, required</code>: The ending index along the axis to be sliced,  supports negative indexes.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1520' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.smooth_l1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.smooth_l1-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.smooth_l1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>smooth_l1(data, scalar)
</code></pre>

<p>Calculate Smooth L1 Loss(lhs, scalar) by summing</p>
<p>.. math::</p>
<pre><code>f(x) =
\begin{cases}
(\sigma x)^2/2,&amp; \text{if }x &lt; 1/\sigma^2\\
|x|-0.5/\sigma^2,&amp; \text{otherwise}
\end{cases}
</code></pre>

<p>where :math:<code>x</code> is an element of the tensor <em>lhs</em> and :math:<code>\sigma</code> is the scalar.</p>
<p>Example::</p>
<p>smooth_l1([1, 2, 3, 4], sigma=1) = [0.5, 1.5, 2.5, 3.5]</p>
<p>Defined in src/operator/tensor/elemwise_binary_scalar_op_extended.cc:L103</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: source input</li>
<li><code>scalar::float</code>: scalar input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1511' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.softmax_cross_entropy-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.softmax_cross_entropy-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.softmax_cross_entropy</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>softmax_cross_entropy(data, label)
</code></pre>

<p>Calculate cross entropy of softmax output and one-hot label.</p>
<ul>
<li>
<p>This operator computes the cross entropy in two steps:</p>
<ul>
<li>Applies softmax function on the input array.</li>
<li>Computes and returns the cross entropy loss between the softmax output and the labels.</li>
<li>
<p>The softmax function and cross entropy loss is given by:</p>
</li>
<li>
<p>Softmax Function:</p>
</li>
</ul>
<p>.. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}</p>
<ul>
<li>Cross Entropy Function:</li>
</ul>
<p>.. math:: \text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)</p>
</li>
</ul>
<p>Example::</p>
<p>x = [[1, 2, 3],        [11, 7, 5]]</p>
<p>label = [2, 0]</p>
<p>softmax(x) = [[0.09003057, 0.24472848, 0.66524094],                 [0.97962922, 0.01794253, 0.00242826]]</p>
<p>softmax_cross_entropy(data, label) = - log(0.66524084) - log(0.97962922) = 0.4281871</p>
<p>Defined in src/operator/loss_binary_op.cc:L59</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data</li>
<li><code>label::NDArray-or-SymbolicNode</code>: Input label</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1523' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.square-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.square-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.square</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>square(data)
</code></pre>

<p>Returns element-wise squared value of the input.</p>
<p>.. math::    square(x) = x^2</p>
<p>Example::</p>
<p>square([2, 3, 4]) = [4, 9, 16]</p>
<p>The storage type of $square$ output depends upon the input storage type:</p>
<ul>
<li>square(default) = default</li>
<li>square(row_sparse) = row_sparse</li>
<li>square(csr) = csr</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L542</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.stack-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.stack-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.stack</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>stack(data, axis, num_args)
</code></pre>

<p><strong>Note</strong>: stack takes variable number of positional inputs. So instead of calling as stack([x, y, z], num_args=3), one should call via stack(x, y, z), and num_args will be determined automatically.</p>
<p>Join a sequence of arrays along a new axis.</p>
<p>The axis parameter specifies the index of the new axis in the dimensions of the result. For example, if axis=0 it will be the first dimension and if axis=-1 it will be the last dimension.</p>
<p>Examples::</p>
<p>x = [1, 2]   y = [3, 4]</p>
<p>stack(x, y) = [[1, 2],                  [3, 4]]   stack(x, y, axis=1) = [[1, 3],                          [2, 4]]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode[]</code>: List of arrays to stack</li>
<li><code>axis::int, optional, default='0'</code>: The axis in the result array along which the input arrays are stacked.</li>
<li><code>num_args::int, required</code>: Number of inputs to be stacked.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1512' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.stop_gradient-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.stop_gradient-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.stop_gradient</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>stop_gradient(data)
</code></pre>

<p>stop_gradient is an alias of BlockGrad.</p>
<p>Stops gradient computation.</p>
<p>Stops the accumulated gradient of the inputs from flowing through this operator in the backward direction. In other words, this operator prevents the contribution of its inputs to be taken into account for computing gradients.</p>
<p>Example::</p>
<p>v1 = [1, 2]   v2 = [0, 1]   a = Variable('a')   b = Variable('b')   b_stop_grad = stop_gradient(3 * b)   loss = MakeLoss(b_stop_grad + a)</p>
<p>executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))   executor.forward(is_train=True, a=v1, b=v2)   executor.outputs   [ 1.  5.]</p>
<p>executor.backward()   executor.grad_arrays   [ 0.  0.]   [ 1.  1.]</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L167</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1520' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sub_from!-Tuple{MXNet.mx.NDArray,Union{MXNet.mx.NDArray, Real}}' href='#MXNet.mx.sub_from!-Tuple{MXNet.mx.NDArray,Union{MXNet.mx.NDArray, Real}}'>#</a>
<strong><code>MXNet.mx.sub_from!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sub_from!(dst::NDArray, args::NDArrayOrReal...)
</code></pre>

<p>Subtract a bunch of arguments from <code>dst</code>. Inplace updating.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L623-L627' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.sum_axis-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.sum_axis-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.sum_axis</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sum_axis(data, axis, keepdims, exclude)
</code></pre>

<p>sum_axis is an alias of sum.</p>
<p>Computes the sum of array elements over given axes.</p>
<p>.. Note::</p>
<p><code>sum</code> and <code>sum_axis</code> are equivalent.   For ndarray of csr storage type summation along axis 0 and axis 1 is supported.   Setting keepdims or exclude to True will cause a fallback to dense operator.</p>
<p>Example::</p>
<p>data = [[[1,2],[2,3],[1,3]],           [[1,4],[4,3],[5,2]],           [[7,1],[7,2],[7,3]]]</p>
<p>sum(data, axis=1)   [[  4.   8.]    [ 10.   9.]    [ 21.   6.]]</p>
<p>sum(data, axis=[1,2])   [ 12.  19.  27.]</p>
<p>data = [[1,2,0],           [3,0,1],           [4,1,0]]</p>
<p>csr = cast_storage(data, 'csr')</p>
<p>sum(csr, axis=0)   [ 8.  2.  2.]</p>
<p>sum(csr, axis=1)   [ 3.  4.  5.]</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L85</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
<li>
<p><code>axis::Shape(tuple), optional, default=[]</code>: The axis or axes along which to perform the reduction.</p>
<p><code>``
The default,</code>axis=()<code>, will compute over all elements into a
scalar array with shape</code>(1,)`.</p>
<p>If <code>axis</code> is int, a reduction is performed on a particular axis.</p>
<p>If <code>axis</code> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <code>exclude</code> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.
<code>``
  *</code>keepdims::boolean, optional, default=0<code>: If this is set to</code>True<code>, the reduced axes are left in the result as dimension with size one.
  *</code>exclude::boolean, optional, default=0`: Whether to perform reduction on axis that are NOT in axis instead.</p>
</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1548' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.swapaxes-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.swapaxes-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.swapaxes</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>swapaxes(data, dim1, dim2)
</code></pre>

<p>swapaxes is an alias of SwapAxis.</p>
<p>Interchanges two axes of an array.</p>
<p>Examples::</p>
<p>x = [[1, 2, 3]])   swapaxes(x, 0, 1) = [[ 1],                        [ 2],                        [ 3]]</p>
<p>x = [[[ 0, 1],         [ 2, 3]],        [[ 4, 5],         [ 6, 7]]]  // (2,2,2) array</p>
<p>swapaxes(x, 0, 2) = [[[ 0, 4],                        [ 2, 6]],                       [[ 1, 5],                        [ 3, 7]]]</p>
<p>Defined in src/operator/swapaxis.cc:L70</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input array.</li>
<li><code>dim1::int (non-negative), optional, default=0</code>: the first axis to be swapped.</li>
<li><code>dim2::int (non-negative), optional, default=0</code>: the second axis to be swapped.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1517' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.take-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.take-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.take</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>take(a, indices, axis, mode)
</code></pre>

<p>Takes elements from an input array along the given axis.</p>
<p>This function slices the input array along a particular axis with the provided indices.</p>
<p>Given an input array with shape $(d0, d1, d2)$ and indices with shape $(i0, i1)$, the output will have shape $(i0, i1, d1, d2)$, computed by::</p>
<p>output[i,j,:,:] = input[indices[i,j],:,:]</p>
<p>.. note::</p>
<ul>
<li><code>axis</code>- Only slicing along axis 0 is supported for now.</li>
<li><code>mode</code>- Only <code>clip</code> mode is supported for now.</li>
</ul>
<p>Examples::</p>
<p>x = [[ 1.,  2.],        [ 3.,  4.],        [ 5.,  6.]]</p>
<p>// takes elements with specified indices along axis 0   take(x, [[0,1],[1,2]]) = [[[ 1.,  2.],                              [ 3.,  4.]],</p>
<pre><code>                        [[ 3.,  4.],
                         [ 5.,  6.]]]
</code></pre>

<p>Defined in src/operator/tensor/indexing_op.cc:L327</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a::NDArray-or-SymbolicNode</code>: The input array.</li>
<li><code>indices::NDArray-or-SymbolicNode</code>: The indices of the values to be extracted.</li>
<li><code>axis::int, optional, default='0'</code>: The axis of input array to be taken.</li>
<li><code>mode::{'clip', 'raise', 'wrap'},optional, default='clip'</code>: Specify how out-of-bound indices bahave. "clip" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  "wrap" means to wrap around.  "raise" means to raise an error.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1525' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.tile-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.tile-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.tile</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>tile(data, reps)
</code></pre>

<p>Repeats the whole array multiple times.</p>
<p>If $reps$ has length <em>d</em>, and input array has dimension of <em>n</em>. There are three cases:</p>
<ul>
<li>
<p><strong>n=d</strong>. Repeat <em>i</em>-th dimension of the input by $reps[i]$ times::</p>
<p>x = [[1, 2],        [3, 4]]</p>
<p>tile(x, reps=(2,3)) = [[ 1.,  2.,  1.,  2.,  1.,  2.],                          [ 3.,  4.,  3.,  4.,  3.,  4.],                          [ 1.,  2.,  1.,  2.,  1.,  2.],                          [ 3.,  4.,  3.,  4.,  3.,  4.]]
  * <strong>n&gt;d</strong>. $reps$ is promoted to length <em>n</em> by pre-pending 1's to it. Thus for an input shape $(2,3)$, $repos=(2,)$ is treated as $(1,2)$::</p>
</li>
</ul>
<pre><code>tile(x, reps=(2,)) = [[ 1.,  2.,  1.,  2.],
                      [ 3.,  4.,  3.,  4.]]
</code></pre>

<ul>
<li>
<p><strong>n&lt;d</strong>. The input is promoted to be d-dimensional by prepending new axes. So a shape $(2,2)$ array is promoted to $(1,2,2)$ for 3-D replication::</p>
<p>tile(x, reps=(2,2,3)) = [[[ 1.,  2.,  1.,  2.,  1.,  2.],                             [ 3.,  4.,  3.,  4.,  3.,  4.],                             [ 1.,  2.,  1.,  2.,  1.,  2.],                             [ 3.,  4.,  3.,  4.,  3.,  4.]],</p>
<p><code>[[ 1.,  2.,  1.,  2.,  1.,  2.],
                        [ 3.,  4.,  3.,  4.,  3.,  4.],
                        [ 1.,  2.,  1.,  2.,  1.,  2.],
                        [ 3.,  4.,  3.,  4.,  3.,  4.]]]</code></p>
</li>
</ul>
<p>Defined in src/operator/tensor/matrix_op.cc:L621</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: Input data array</li>
<li><code>reps::Shape(tuple), required</code>: The number of times for repeating the tensor a. If reps has length d, the result will have dimension of max(d, a.ndim); If a.ndim &lt; d, a is promoted to be d-dimensional by prepending new axes. If a.ndim &gt; d, reps is promoted to a.ndim by pre-pending 1's to it.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1529' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.topk-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.topk-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.topk</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>topk(data, axis, k, ret_typ, is_ascend)
</code></pre>

<p>Returns the top <em>k</em> elements in an input array along the given axis.</p>
<p>Examples::</p>
<p>x = [[ 0.3,  0.2,  0.4],        [ 0.1,  0.3,  0.2]]</p>
<p>// returns an index of the largest element on last axis   topk(x) = [[ 2.],              [ 1.]]</p>
<p>// returns the value of top-2 largest elements on last axis   topk(x, ret_typ='value', k=2) = [[ 0.4,  0.3],                                    [ 0.3,  0.2]]</p>
<p>// returns the value of top-2 smallest elements on last axis   topk(x, ret_typ='value', k=2, is_ascend=1) = [[ 0.2 ,  0.3],                                                [ 0.1 ,  0.2]]</p>
<p>// returns the value of top-2 largest elements on axis 0   topk(x, axis=0, ret_typ='value', k=2) = [[ 0.3,  0.3,  0.4],                                            [ 0.1,  0.2,  0.2]]</p>
<p>// flattens and then returns list of both values and indices   topk(x, ret_typ='both', k=2) = [[[ 0.4,  0.3], [ 0.3,  0.2]] ,  [[ 2.,  0.], [ 1.,  2.]]]</p>
<p>Defined in src/operator/tensor/ordering_op.cc:L63</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input array</li>
<li><code>axis::int or None, optional, default='-1'</code>: Axis along which to choose the top k indices. If not given, the flattened array is used. Default is -1.</li>
<li><code>k::int, optional, default='1'</code>: Number of top elements to select, should be always smaller than or equal to the element number in the given axis. A global sort is performed if set k &lt; 1.</li>
<li><code>ret_typ::{'both', 'indices', 'mask', 'value'},optional, default='indices'</code>: The return type.</li>
</ul>
<p>"value" means to return the top k values, "indices" means to return the indices of the top k values, "mask" means to return a mask array containing 0 and 1. 1 means the top k values. "both" means to return a list of both values and indices of top k elements.</p>
<ul>
<li><code>is_ascend::boolean, optional, default=0</code>: Whether to choose k largest or k smallest elements. Top K largest elements will be chosen if set to false.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1528' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.try_get_shared-Tuple{MXNet.mx.NDArray}' href='#MXNet.mx.try_get_shared-Tuple{MXNet.mx.NDArray}'>#</a>
<strong><code>MXNet.mx.try_get_shared</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>try_get_shared(arr; sync=:nop)
</code></pre>

<p>Try to create a Julia array by sharing the data with the underlying <code>NDArray</code>.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>arr::NDArray</code>: the array to be shared.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The returned array does not guarantee to share data with the underlying <code>NDArray</code>. In particular, data sharing is possible only when the <code>NDArray</code> lives on CPU.</p>
</div>
<ul>
<li><code>sync::Symbol</code>: <code>:nop</code>,<code>:write</code>, <code>:read</code> On CPU, invoke <code>_wait_to_read</code> if <code>:read</code>; invoke <code>_wait_to_write</code> if <code>:write</code>.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L930-L946' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.uniform-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.uniform-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.uniform</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>uniform(low, high, shape, ctx, dtype)
</code></pre>

<p>uniform is an alias of _random_uniform.</p>
<p>Draw random samples from a uniform distribution.</p>
<p>.. note:: The existing alias $uniform$ is deprecated.</p>
<p>Samples are uniformly distributed over the half-open interval <em>[low, high)</em> (includes <em>low</em>, but excludes <em>high</em>).</p>
<p>Example::</p>
<p>uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],                                           [ 0.54488319,  0.84725171]]</p>
<p>Defined in src/operator/random/sample_op.cc:L66</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>low::float, optional, default=0</code>: Lower bound of the distribution.</li>
<li><code>high::float, optional, default=1</code>: Upper bound of the distribution.</li>
<li><code>shape::Shape(tuple), optional, default=[]</code>: Shape of the output.</li>
<li><code>ctx::string, optional, default=''</code>: Context of output, in format <a href="../n">cpu|gpu|cpu_pinned</a>. Only used for imperative calls.</li>
<li><code>dtype::{'None', 'float16', 'float32', 'float64'},optional, default='None'</code>: DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1515' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.where-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.where-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.where</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>where(condition, x, y)
</code></pre>

<p>Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y, depending on the elements from condition are true or false. x and y must have the same shape. If condition has the same shape as x, each element in the output array is from x if the corresponding element in the condition is true, and from y if false. If condition does not have the same shape as x, it must be a 1D array whose size is the same as x's first dimension size. Each row of the output array is from x's row if the corresponding element from condition is true, and from y's row if false.</p>
<p>From:src/operator/tensor/control_flow_op.cc:40</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>condition::NDArray-or-SymbolicNode</code>: condition array</li>
<li><code>x::NDArray-or-SymbolicNode</code>:</li>
<li><code>y::NDArray-or-SymbolicNode</code>:</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1497' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.zeros-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64,N}},MXNet.mx.Context}, Tuple{Tuple{Vararg{Int64,N}}}} where N' href='#MXNet.mx.zeros-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64,N}},MXNet.mx.Context}, Tuple{Tuple{Vararg{Int64,N}}}} where N'>#</a>
<strong><code>MXNet.mx.zeros</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>zeros(dims[, ctx::Context = cpu()])
zeros(dims...)
</code></pre>

<p>Create zero-ed <code>NDArray</code> with specific shape.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L187-L192' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.zeros-Union{Tuple{N}, Tuple{T}, Tuple{Type{T},Tuple{Vararg{Int64,N}},MXNet.mx.Context}, Tuple{Type{T},Tuple{Vararg{Int64,N}}}} where T<:Union{Float16, Float32, Float64, Int32, Int64, Int8, UInt8} where N' href='#MXNet.mx.zeros-Union{Tuple{N}, Tuple{T}, Tuple{Type{T},Tuple{Vararg{Int64,N}},MXNet.mx.Context}, Tuple{Type{T},Tuple{Vararg{Int64,N}}}} where T<:Union{Float16, Float32, Float64, Int32, Int64, Int8, UInt8} where N'>#</a>
<strong><code>MXNet.mx.zeros</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>zeros(DType, dims[, ctx::Context = cpu()])
zeros(DType, dims...)
</code></pre>

<p>Create zero-ed <code>NDArray</code> with specific shape and type.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L173-L178' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.zeros_like-Tuple{Vararg{MXNet.mx.NDArray,N} where N}' href='#MXNet.mx.zeros_like-Tuple{Vararg{MXNet.mx.NDArray,N} where N}'>#</a>
<strong><code>MXNet.mx.zeros_like</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>zeros_like(data)
</code></pre>

<p>Return an array of zeros with the same shape and type as the input array.</p>
<p>The storage type of $zeros_like$ output depends on the storage type of the input</p>
<ul>
<li>zeros_like(row_sparse) = row_sparse</li>
<li>zeros_like(csr) = csr</li>
<li>zeros_like(default) = default</li>
</ul>
<p>Examples::</p>
<p>x = [[ 1.,  1.,  1.],        [ 1.,  1.,  1.]]</p>
<p>zeros_like(x) = [[ 0.,  0.,  0.],                    [ 0.,  0.,  0.]]</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>data::NDArray-or-SymbolicNode</code>: The input</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1484-L1508' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{Base.#acos,MXNet.mx.NDArray}' href='#TakingBroadcastSeriously.broadcast_-Tuple{Base.#acos,MXNet.mx.NDArray}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1220' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{Base.#acosh,MXNet.mx.NDArray}' href='#TakingBroadcastSeriously.broadcast_-Tuple{Base.#acosh,MXNet.mx.NDArray}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1228' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{Base.#asin,MXNet.mx.NDArray}' href='#TakingBroadcastSeriously.broadcast_-Tuple{Base.#asin,MXNet.mx.NDArray}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1219' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{Base.#asinh,MXNet.mx.NDArray}' href='#TakingBroadcastSeriously.broadcast_-Tuple{Base.#asinh,MXNet.mx.NDArray}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1227' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{Base.#atan,MXNet.mx.NDArray}' href='#TakingBroadcastSeriously.broadcast_-Tuple{Base.#atan,MXNet.mx.NDArray}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1221' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{Base.#atanh,MXNet.mx.NDArray}' href='#TakingBroadcastSeriously.broadcast_-Tuple{Base.#atanh,MXNet.mx.NDArray}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1229' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{Base.#cos,MXNet.mx.NDArray}' href='#TakingBroadcastSeriously.broadcast_-Tuple{Base.#cos,MXNet.mx.NDArray}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1217' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{Base.#cosh,MXNet.mx.NDArray}' href='#TakingBroadcastSeriously.broadcast_-Tuple{Base.#cosh,MXNet.mx.NDArray}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1225' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{Base.#sin,MXNet.mx.NDArray}' href='#TakingBroadcastSeriously.broadcast_-Tuple{Base.#sin,MXNet.mx.NDArray}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1216' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{Base.#sinh,MXNet.mx.NDArray}' href='#TakingBroadcastSeriously.broadcast_-Tuple{Base.#sinh,MXNet.mx.NDArray}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1224' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{Base.#tan,MXNet.mx.NDArray}' href='#TakingBroadcastSeriously.broadcast_-Tuple{Base.#tan,MXNet.mx.NDArray}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1218' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{Base.#tanh,MXNet.mx.NDArray}' href='#TakingBroadcastSeriously.broadcast_-Tuple{Base.#tanh,MXNet.mx.NDArray}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1226' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{MXNet.mx.#log_softmax,MXNet.mx.NDArray,Int64}' href='#TakingBroadcastSeriously.broadcast_-Tuple{MXNet.mx.#log_softmax,MXNet.mx.NDArray,Int64}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1290' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{MXNet.mx.#log_softmax,MXNet.mx.NDArray}' href='#TakingBroadcastSeriously.broadcast_-Tuple{MXNet.mx.#log_softmax,MXNet.mx.NDArray}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1289' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{MXNet.mx.#relu,MXNet.mx.NDArray}' href='#TakingBroadcastSeriously.broadcast_-Tuple{MXNet.mx.#relu,MXNet.mx.NDArray}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1256' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{MXNet.mx.#sigmoid,MXNet.mx.NDArray}' href='#TakingBroadcastSeriously.broadcast_-Tuple{MXNet.mx.#sigmoid,MXNet.mx.NDArray}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1245' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{MXNet.mx.#softmax,MXNet.mx.NDArray,Int64}' href='#TakingBroadcastSeriously.broadcast_-Tuple{MXNet.mx.#softmax,MXNet.mx.NDArray,Int64}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1271' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{MXNet.mx.#softmax,MXNet.mx.NDArray}' href='#TakingBroadcastSeriously.broadcast_-Tuple{MXNet.mx.#softmax,MXNet.mx.NDArray}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1270' class='documenter-source'>source</a><br></p>
<p><a id='TakingBroadcastSeriously.broadcast_-Tuple{MXNet.mx.#σ,MXNet.mx.NDArray}' href='#TakingBroadcastSeriously.broadcast_-Tuple{MXNet.mx.#σ,MXNet.mx.NDArray}'>#</a>
<strong><code>TakingBroadcastSeriously.broadcast_</code></strong> &mdash; <em>Method</em>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L1244' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.@inplace-Tuple{Any}' href='#MXNet.mx.@inplace-Tuple{Any}'>#</a>
<strong><code>MXNet.mx.@inplace</code></strong> &mdash; <em>Macro</em>.</p>
<pre><code>@inplace
</code></pre>

<p>Julia does not support re-definiton of <code>+=</code> operator (like <code>__iadd__</code> in python), When one write <code>a += b</code>, it gets translated to <code>a = a+b</code>. <code>a+b</code> will allocate new memory for the results, and the newly allocated <code>NDArray</code> object is then assigned back to a, while the original contents in a is discarded. This is very inefficient when we want to do inplace update.</p>
<p>This macro is a simple utility to implement this behavior. Write</p>
<pre><code class="julia">  @mx.inplace a += b
</code></pre>

<p>will translate into</p>
<pre><code class="julia">  mx.add_to!(a, b)
</code></pre>

<p>which will do inplace adding of the contents of <code>b</code> into <code>a</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L551-L573' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.@nd_as_jl-Tuple' href='#MXNet.mx.@nd_as_jl-Tuple'>#</a>
<strong><code>MXNet.mx.@nd_as_jl</code></strong> &mdash; <em>Macro</em>.</p>
<p><strong>Manipulating as Julia Arrays</strong></p>
<pre><code>@nd_as_jl(captures..., statement)
</code></pre>

<p>A convenient macro that allows to operate <code>NDArray</code> as Julia Arrays. For example,</p>
<pre><code class="julia">  x = mx.zeros(3,4)
  y = mx.ones(3,4)
  z = mx.zeros((3,4), mx.gpu())

  @mx.nd_as_jl ro=(x,y) rw=z begin
    # now x, y, z are just ordinary Julia Arrays
    z[:,1] = y[:,2]
    z[:,2] = 5
  end
</code></pre>

<p>Under the hood, the macro convert all the declared captures from <code>NDArray</code> into Julia Arrays, by using <code>try_get_shared</code>. And automatically commit the modifications back into the <code>NDArray</code> that is declared as <code>rw</code>. This is useful for fast prototyping and when implement non-critical computations, such as <code>AbstractEvalMetric</code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
</div>
<ul>
<li>Multiple <code>rw</code> and / or <code>ro</code> capture declaration could be made.</li>
<li>The macro does <strong>not</strong> check to make sure that <code>ro</code> captures are not modified. If the original <code>NDArray</code> lives in CPU memory, then it is very likely the corresponding Julia Array shares data with the <code>NDArray</code>, so modifying the Julia Array will also modify the underlying <code>NDArray</code>.</li>
<li>More importantly, since the <code>NDArray</code> is asynchronized, we will wait for <em>writing</em> for <code>rw</code> variables but wait only for <em>reading</em> in <code>ro</code> variables. If we write into those <code>ro</code> variables, <strong>and</strong> if the memory is shared, racing condition might happen, and the behavior is undefined.</li>
<li>When an <code>NDArray</code> is declared to be captured as <code>rw</code>, its contents is always sync back in the end.</li>
<li>The execution results of the expanded macro is always <code>nothing</code>.</li>
<li>The statements are wrapped in a <code>let</code>, thus locally introduced new variables will not be available after the statements. So you will need to declare the variables before calling the macro if needed.</li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/d3cdbf6702fd8250456ffd7cbda94028948ad24e/src/ndarray.jl#L802-L843' class='documenter-source'>source</a><br></p>
                
                  
                
              
              
                
              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../io/" title="Data Providers" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Data Providers
              </span>
            </div>
          </a>
        
        
          <a href="../symbolic-node/" title="Symbolic API" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Symbolic API
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="http://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
        
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.cae2244d.js"></script>
      
      <script>app.initialize({version:"0.17.2",url:{base:"../.."}})</script>
      
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
      
        <script src="../../assets/mathjaxhelper.js"></script>
      
    
    
      
    
  </body>
</html>